/* automatically generated by rust-bindgen */

# [ repr ( C ) ] # [ derive ( Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd ) ] pub struct __BindgenBitfieldUnit < Storage , Align > where Storage : AsRef < [ u8 ] > + AsMut < [ u8 ] >, { storage : Storage , align : [ Align ; 0 ] , } impl < Storage , Align > __BindgenBitfieldUnit < Storage , Align > where Storage : AsRef < [ u8 ] > + AsMut < [ u8 ] >, { # [ inline ] pub fn new ( storage : Storage ) -> Self { Self { storage , align : [ ] , } } # [ inline ] pub fn get_bit ( & self , index : usize ) -> bool { debug_assert ! ( index / 8 < self . storage . as_ref ( ) . len ( ) ) ; let byte_index = index / 8 ; let byte = self . storage . as_ref ( ) [ byte_index ] ; let bit_index = if cfg ! ( target_endian = "big" ) { 7 - ( index % 8 ) } else { index % 8 } ; let mask = 1 << bit_index ; byte & mask == mask } # [ inline ] pub fn set_bit ( & mut self , index : usize , val : bool ) { debug_assert ! ( index / 8 < self . storage . as_ref ( ) . len ( ) ) ; let byte_index = index / 8 ; let byte = & mut self . storage . as_mut ( ) [ byte_index ] ; let bit_index = if cfg ! ( target_endian = "big" ) { 7 - ( index % 8 ) } else { index % 8 } ; let mask = 1 << bit_index ; if val { * byte |= mask ; } else { * byte &= ! mask ; } } # [ inline ] pub fn get ( & self , bit_offset : usize , bit_width : u8 ) -> u64 { debug_assert ! ( bit_width <= 64 ) ; debug_assert ! ( bit_offset / 8 < self . storage . as_ref ( ) . len ( ) ) ; debug_assert ! ( ( bit_offset + ( bit_width as usize ) ) / 8 <= self . storage . as_ref ( ) . len ( ) ) ; let mut val = 0 ; for i in 0 .. ( bit_width as usize ) { if self . get_bit ( i + bit_offset ) { let index = if cfg ! ( target_endian = "big" ) { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [ inline ] pub fn set ( & mut self , bit_offset : usize , bit_width : u8 , val : u64 ) { debug_assert ! ( bit_width <= 64 ) ; debug_assert ! ( bit_offset / 8 < self . storage . as_ref ( ) . len ( ) ) ; debug_assert ! ( ( bit_offset + ( bit_width as usize ) ) / 8 <= self . storage . as_ref ( ) . len ( ) ) ; for i in 0 .. ( bit_width as usize ) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! ( target_endian = "big" ) { bit_width as usize - 1 - i } else { i } ; self . set_bit ( index + bit_offset , val_bit_is_set ) ; } } } # [ repr ( C ) ] # [ derive ( Default ) ] pub struct __IncompleteArrayField < T > ( :: std :: marker :: PhantomData < T > , [ T ; 0 ] ) ; impl < T > __IncompleteArrayField < T > { # [ inline ] pub fn new ( ) -> Self { __IncompleteArrayField ( :: std :: marker :: PhantomData , [ ] ) } # [ inline ] pub unsafe fn as_ptr ( & self ) -> * const T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut_ptr ( & mut self ) -> * mut T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_slice ( & self , len : usize ) -> & [ T ] { :: std :: slice :: from_raw_parts ( self . as_ptr ( ) , len ) } # [ inline ] pub unsafe fn as_mut_slice ( & mut self , len : usize ) -> & mut [ T ] { :: std :: slice :: from_raw_parts_mut ( self . as_mut_ptr ( ) , len ) } } impl < T > :: std :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter < '_ > ) -> :: std :: fmt :: Result { fmt . write_str ( "__IncompleteArrayField" ) } } impl < T > :: std :: clone :: Clone for __IncompleteArrayField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } extern "C" { pub fn __assert_fail ( __assertion : * const libc :: c_char , __file : * const libc :: c_char , __line : libc :: c_uint , __function : * const libc :: c_char ) ; } extern "C" { pub fn __assert_perror_fail ( __errnum : libc :: c_int , __file : * const libc :: c_char , __line : libc :: c_uint , __function : * const libc :: c_char ) ; } extern "C" { pub fn __assert ( __assertion : * const libc :: c_char , __file : * const libc :: c_char , __line : libc :: c_int ) ; } pub type __u_char = libc :: c_uchar ; pub type __u_short = libc :: c_ushort ; pub type __u_int = libc :: c_uint ; pub type __u_long = libc :: c_ulong ; pub type __int8_t = libc :: c_schar ; pub type __uint8_t = libc :: c_uchar ; pub type __int16_t = libc :: c_short ; pub type __uint16_t = libc :: c_ushort ; pub type __int32_t = libc :: c_int ; pub type __uint32_t = libc :: c_uint ; pub type __int64_t = libc :: c_long ; pub type __uint64_t = libc :: c_ulong ; pub type __quad_t = libc :: c_long ; pub type __u_quad_t = libc :: c_ulong ; pub type __intmax_t = libc :: c_long ; pub type __uintmax_t = libc :: c_ulong ; pub type __dev_t = libc :: c_ulong ; pub type __uid_t = libc :: c_uint ; pub type __gid_t = libc :: c_uint ; pub type __ino_t = libc :: c_ulong ; pub type __ino64_t = libc :: c_ulong ; pub type __mode_t = libc :: c_uint ; pub type __nlink_t = libc :: c_ulong ; pub type __off_t = libc :: c_long ; pub type __off64_t = libc :: c_long ; pub type __pid_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ libc :: c_int ; 2usize ] , } pub type __clock_t = libc :: c_long ; pub type __rlim_t = libc :: c_ulong ; pub type __rlim64_t = libc :: c_ulong ; pub type __id_t = libc :: c_uint ; pub type __time_t = libc :: c_long ; pub type __useconds_t = libc :: c_uint ; pub type __suseconds_t = libc :: c_long ; pub type __daddr_t = libc :: c_int ; pub type __key_t = libc :: c_int ; pub type __clockid_t = libc :: c_int ; pub type __timer_t = * mut libc :: c_void ; pub type __blksize_t = libc :: c_long ; pub type __blkcnt_t = libc :: c_long ; pub type __blkcnt64_t = libc :: c_long ; pub type __fsblkcnt_t = libc :: c_ulong ; pub type __fsblkcnt64_t = libc :: c_ulong ; pub type __fsfilcnt_t = libc :: c_ulong ; pub type __fsfilcnt64_t = libc :: c_ulong ; pub type __fsword_t = libc :: c_long ; pub type __ssize_t = libc :: c_long ; pub type __syscall_slong_t = libc :: c_long ; pub type __syscall_ulong_t = libc :: c_ulong ; pub type __loff_t = __off64_t ; pub type __caddr_t = * mut libc :: c_char ; pub type __intptr_t = libc :: c_long ; pub type __socklen_t = libc :: c_uint ; pub type __sig_atomic_t = libc :: c_int ; pub const _ISupper : _bindgen_ty_1 = 256 ; pub const _ISlower : _bindgen_ty_1 = 512 ; pub const _ISalpha : _bindgen_ty_1 = 1024 ; pub const _ISdigit : _bindgen_ty_1 = 2048 ; pub const _ISxdigit : _bindgen_ty_1 = 4096 ; pub const _ISspace : _bindgen_ty_1 = 8192 ; pub const _ISprint : _bindgen_ty_1 = 16384 ; pub const _ISgraph : _bindgen_ty_1 = 32768 ; pub const _ISblank : _bindgen_ty_1 = 1 ; pub const _IScntrl : _bindgen_ty_1 = 2 ; pub const _ISpunct : _bindgen_ty_1 = 4 ; pub const _ISalnum : _bindgen_ty_1 = 8 ; pub type _bindgen_ty_1 = u32 ; extern "C" { pub fn __ctype_b_loc ( ) -> * mut * const libc :: c_ushort ; } extern "C" { pub fn __ctype_tolower_loc ( ) -> * mut * const __int32_t ; } extern "C" { pub fn __ctype_toupper_loc ( ) -> * mut * const __int32_t ; } extern "C" { pub fn isalnum ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isalpha ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn iscntrl ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isdigit ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn islower ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isgraph ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isprint ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ispunct ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isspace ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isupper ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isxdigit ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tolower ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn toupper ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isblank ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isascii ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn toascii ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _toupper ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _tolower ( arg1 : libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const libc :: c_ushort , pub __ctype_tolower : * const libc :: c_int , pub __ctype_toupper : * const libc :: c_int , pub __names : [ * const libc :: c_char ; 13usize ] , } impl Default for __locale_struct { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { pub fn isalnum_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isalpha_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn iscntrl_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isdigit_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn islower_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isgraph_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isprint_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn ispunct_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isspace_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isupper_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isxdigit_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isblank_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn __tolower_l ( __c : libc :: c_int , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn tolower_l ( __c : libc :: c_int , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn __toupper_l ( __c : libc :: c_int , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn toupper_l ( __c : libc :: c_int , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn __errno_location ( ) -> * mut libc :: c_int ; } pub type int_least8_t = libc :: c_schar ; pub type int_least16_t = libc :: c_short ; pub type int_least32_t = libc :: c_int ; pub type int_least64_t = libc :: c_long ; pub type uint_least8_t = libc :: c_uchar ; pub type uint_least16_t = libc :: c_ushort ; pub type uint_least32_t = libc :: c_uint ; pub type uint_least64_t = libc :: c_ulong ; pub type int_fast8_t = libc :: c_schar ; pub type int_fast16_t = libc :: c_long ; pub type int_fast32_t = libc :: c_long ; pub type int_fast64_t = libc :: c_long ; pub type uint_fast8_t = libc :: c_uchar ; pub type uint_fast16_t = libc :: c_ulong ; pub type uint_fast32_t = libc :: c_ulong ; pub type uint_fast64_t = libc :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; pub type __gwchar_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct imaxdiv_t { pub quot : libc :: c_long , pub rem : libc :: c_long , } extern "C" { pub fn imaxabs ( __n : intmax_t ) -> intmax_t ; } extern "C" { pub fn imaxdiv ( __numer : intmax_t , __denom : intmax_t ) -> imaxdiv_t ; } extern "C" { pub fn strtoimax ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> intmax_t ; } extern "C" { pub fn strtoumax ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> uintmax_t ; } extern "C" { pub fn wcstoimax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : libc :: c_int ) -> intmax_t ; } extern "C" { pub fn wcstoumax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : libc :: c_int ) -> uintmax_t ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; pub type wchar_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : libc :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 , } pub type __FILE = _IO_FILE ; pub type FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : libc :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : libc :: c_uint , pub __wchb : [ libc :: c_char ; 4usize ] , _bindgen_union_align : u32 , } impl Default for __mbstate_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for __mbstate_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } impl Default for _G_fpos_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } impl Default for _G_fpos64_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t { _unused : [ u8 ; 0 ] , } pub type _IO_lock_t = libc :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : libc :: c_int , } impl Default for _IO_marker { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const __codecvt_result___codecvt_ok : __codecvt_result = 0 ; pub const __codecvt_result___codecvt_partial : __codecvt_result = 1 ; pub const __codecvt_result___codecvt_error : __codecvt_result = 2 ; pub const __codecvt_result___codecvt_noconv : __codecvt_result = 3 ; pub type __codecvt_result = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE { pub _flags : libc :: c_int , pub _IO_read_ptr : * mut libc :: c_char , pub _IO_read_end : * mut libc :: c_char , pub _IO_read_base : * mut libc :: c_char , pub _IO_write_base : * mut libc :: c_char , pub _IO_write_ptr : * mut libc :: c_char , pub _IO_write_end : * mut libc :: c_char , pub _IO_buf_base : * mut libc :: c_char , pub _IO_buf_end : * mut libc :: c_char , pub _IO_save_base : * mut libc :: c_char , pub _IO_backup_base : * mut libc :: c_char , pub _IO_save_end : * mut libc :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : libc :: c_int , pub _flags2 : libc :: c_int , pub _old_offset : __off_t , pub _cur_column : libc :: c_ushort , pub _vtable_offset : libc :: c_schar , pub _shortbuf : [ libc :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut libc :: c_void , pub __pad2 : * mut libc :: c_void , pub __pad3 : * mut libc :: c_void , pub __pad4 : * mut libc :: c_void , pub __pad5 : usize , pub _mode : libc :: c_int , pub _unused2 : [ libc :: c_char ; 20usize ] , } impl Default for _IO_FILE { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE_plus { _unused : [ u8 ; 0 ] , } pub type __io_read_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut libc :: c_void , __buf : * mut libc :: c_char , __nbytes : usize ) -> __ssize_t > ; pub type __io_write_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut libc :: c_void , __buf : * const libc :: c_char , __n : usize ) -> __ssize_t > ; pub type __io_seek_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut libc :: c_void , __pos : * mut __off64_t , __w : libc :: c_int ) -> libc :: c_int > ; pub type __io_close_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut libc :: c_void ) -> libc :: c_int > ; extern "C" { pub fn __underflow ( arg1 : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn __uflow ( arg1 : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn __overflow ( arg1 : * mut _IO_FILE , arg2 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _IO_getc ( __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_putc ( __c : libc :: c_int , __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_feof ( __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_ferror ( __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_peekc_locked ( __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_flockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_funlockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_ftrylockfile ( arg1 : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_vfscanf ( arg1 : * mut _IO_FILE , arg2 : * const libc :: c_char , arg3 : * mut __va_list_tag , arg4 : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _IO_vfprintf ( arg1 : * mut _IO_FILE , arg2 : * const libc :: c_char , arg3 : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn _IO_padn ( arg1 : * mut _IO_FILE , arg2 : libc :: c_int , arg3 : __ssize_t ) -> __ssize_t ; } extern "C" { pub fn _IO_sgetn ( arg1 : * mut _IO_FILE , arg2 : * mut libc :: c_void , arg3 : usize ) -> usize ; } extern "C" { pub fn _IO_seekoff ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : libc :: c_int , arg4 : libc :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_seekpos ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : libc :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_free_backup_area ( arg1 : * mut _IO_FILE ) ; } pub type off_t = __off_t ; pub type fpos_t = _G_fpos_t ; extern "C" { pub fn remove ( __filename : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn rename ( __old : * const libc :: c_char , __new : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn renameat ( __oldfd : libc :: c_int , __old : * const libc :: c_char , __newfd : libc :: c_int , __new : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { pub fn tmpnam ( __s : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn tmpnam_r ( __s : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn tempnam ( __dir : * const libc :: c_char , __pfx : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn fclose ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fflush ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fflush_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fopen ( __filename : * const libc :: c_char , __modes : * const libc :: c_char ) -> * mut FILE ; } extern "C" { pub fn freopen ( __filename : * const libc :: c_char , __modes : * const libc :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn fdopen ( __fd : libc :: c_int , __modes : * const libc :: c_char ) -> * mut FILE ; } extern "C" { pub fn fmemopen ( __s : * mut libc :: c_void , __len : usize , __modes : * const libc :: c_char ) -> * mut FILE ; } extern "C" { pub fn open_memstream ( __bufloc : * mut * mut libc :: c_char , __sizeloc : * mut usize ) -> * mut FILE ; } extern "C" { pub fn setbuf ( __stream : * mut FILE , __buf : * mut libc :: c_char ) ; } extern "C" { pub fn setvbuf ( __stream : * mut FILE , __buf : * mut libc :: c_char , __modes : libc :: c_int , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn setbuffer ( __stream : * mut FILE , __buf : * mut libc :: c_char , __size : usize ) ; } extern "C" { pub fn setlinebuf ( __stream : * mut FILE ) ; } extern "C" { pub fn fprintf ( __stream : * mut FILE , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn printf ( __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn sprintf ( __s : * mut libc :: c_char , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn vfprintf ( __s : * mut FILE , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vprintf ( __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vsprintf ( __s : * mut libc :: c_char , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn snprintf ( __s : * mut libc :: c_char , __maxlen : usize , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn vsnprintf ( __s : * mut libc :: c_char , __maxlen : usize , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vdprintf ( __fd : libc :: c_int , __fmt : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn dprintf ( __fd : libc :: c_int , __fmt : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn fscanf ( __stream : * mut FILE , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn scanf ( __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn sscanf ( __s : * const libc :: c_char , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn vfscanf ( __s : * mut FILE , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vscanf ( __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vsscanf ( __s : * const libc :: c_char , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn fgetc ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn getc ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn getchar ( ) -> libc :: c_int ; } extern "C" { pub fn getc_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn getchar_unlocked ( ) -> libc :: c_int ; } extern "C" { pub fn fgetc_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fputc ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putc ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putchar ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn fputc_unlocked ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putc_unlocked ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putchar_unlocked ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getw ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putw ( __w : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fgets ( __s : * mut libc :: c_char , __n : libc :: c_int , __stream : * mut FILE ) -> * mut libc :: c_char ; } extern "C" { pub fn __getdelim ( __lineptr : * mut * mut libc :: c_char , __n : * mut usize , __delimiter : libc :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getdelim ( __lineptr : * mut * mut libc :: c_char , __n : * mut usize , __delimiter : libc :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getline ( __lineptr : * mut * mut libc :: c_char , __n : * mut usize , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn fputs ( __s : * const libc :: c_char , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn puts ( __s : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn ungetc ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fread ( __ptr : * mut libc :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite ( __ptr : * const libc :: c_void , __size : usize , __n : usize , __s : * mut FILE ) -> usize ; } extern "C" { pub fn fread_unlocked ( __ptr : * mut libc :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite_unlocked ( __ptr : * const libc :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fseek ( __stream : * mut FILE , __off : libc :: c_long , __whence : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ftell ( __stream : * mut FILE ) -> libc :: c_long ; } extern "C" { pub fn rewind ( __stream : * mut FILE ) ; } extern "C" { pub fn fseeko ( __stream : * mut FILE , __off : __off_t , __whence : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ftello ( __stream : * mut FILE ) -> __off_t ; } extern "C" { pub fn fgetpos ( __stream : * mut FILE , __pos : * mut fpos_t ) -> libc :: c_int ; } extern "C" { pub fn fsetpos ( __stream : * mut FILE , __pos : * const fpos_t ) -> libc :: c_int ; } extern "C" { pub fn clearerr ( __stream : * mut FILE ) ; } extern "C" { pub fn feof ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn ferror ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn clearerr_unlocked ( __stream : * mut FILE ) ; } extern "C" { pub fn feof_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn ferror_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn perror ( __s : * const libc :: c_char ) ; } extern "C" { pub fn fileno ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fileno_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn popen ( __command : * const libc :: c_char , __modes : * const libc :: c_char ) -> * mut FILE ; } extern "C" { pub fn pclose ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn ctermid ( __s : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn flockfile ( __stream : * mut FILE ) ; } extern "C" { pub fn ftrylockfile ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn funlockfile ( __stream : * mut FILE ) ; } pub const idtype_t_P_ALL : idtype_t = 0 ; pub const idtype_t_P_PID : idtype_t = 1 ; pub const idtype_t_P_PGID : idtype_t = 2 ; pub type idtype_t = u32 ; pub type _Float32 = f32 ; pub type _Float64 = f64 ; pub type _Float32x = f64 ; pub type _Float64x = f64 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct div_t { pub quot : libc :: c_int , pub rem : libc :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ldiv_t { pub quot : libc :: c_long , pub rem : libc :: c_long , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct lldiv_t { pub quot : libc :: c_longlong , pub rem : libc :: c_longlong , } extern "C" { pub fn __ctype_get_mb_cur_max ( ) -> usize ; } extern "C" { pub fn atof ( __nptr : * const libc :: c_char ) -> f64 ; } extern "C" { pub fn atoi ( __nptr : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn atol ( __nptr : * const libc :: c_char ) -> libc :: c_long ; } extern "C" { pub fn atoll ( __nptr : * const libc :: c_char ) -> libc :: c_longlong ; } extern "C" { pub fn strtod ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char ) -> f64 ; } extern "C" { pub fn strtof ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char ) -> f32 ; } extern "C" { pub fn strtold ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char ) -> f64 ; } extern "C" { pub fn strtol ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_long ; } extern "C" { pub fn strtoul ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_ulong ; } extern "C" { pub fn strtoq ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_longlong ; } extern "C" { pub fn strtouq ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_ulonglong ; } extern "C" { pub fn strtoll ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_longlong ; } extern "C" { pub fn strtoull ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_ulonglong ; } extern "C" { pub fn l64a ( __n : libc :: c_long ) -> * mut libc :: c_char ; } extern "C" { pub fn a64l ( __s : * const libc :: c_char ) -> libc :: c_long ; } pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type clockid_t = __clockid_t ; pub type time_t = __time_t ; pub type timer_t = __timer_t ; pub type ulong = libc :: c_ulong ; pub type ushort = libc :: c_ushort ; pub type uint = libc :: c_uint ; pub type u_int8_t = libc :: c_uchar ; pub type u_int16_t = libc :: c_ushort ; pub type u_int32_t = libc :: c_uint ; pub type u_int64_t = libc :: c_ulong ; pub type register_t = libc :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ libc :: c_ulong ; 16usize ] , } pub type sigset_t = __sigset_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = libc :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask ; 16usize ] , } pub type fd_mask = __fd_mask ; extern "C" { pub fn select ( __nfds : libc :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval ) -> libc :: c_int ; } extern "C" { pub fn pselect ( __nfds : libc :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t ) -> libc :: c_int ; } extern "C" { pub fn gnu_dev_major ( __dev : __dev_t ) -> libc :: c_uint ; } extern "C" { pub fn gnu_dev_minor ( __dev : __dev_t ) -> libc :: c_uint ; } extern "C" { pub fn gnu_dev_makedev ( __major : libc :: c_uint , __minor : libc :: c_uint ) -> __dev_t ; } pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_rwlock_arch_t { pub __readers : libc :: c_uint , pub __writers : libc :: c_uint , pub __wrphase_futex : libc :: c_uint , pub __writers_futex : libc :: c_uint , pub __pad3 : libc :: c_uint , pub __pad4 : libc :: c_uint , pub __cur_writer : libc :: c_int , pub __shared : libc :: c_int , pub __rwelision : libc :: c_schar , pub __pad1 : [ libc :: c_uchar ; 7usize ] , pub __pad2 : libc :: c_ulong , pub __flags : libc :: c_uint , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } impl Default for __pthread_internal_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_mutex_s { pub __lock : libc :: c_int , pub __count : libc :: c_uint , pub __owner : libc :: c_int , pub __nusers : libc :: c_uint , pub __kind : libc :: c_int , pub __spins : libc :: c_short , pub __elision : libc :: c_short , pub __list : __pthread_list_t , } impl Default for __pthread_mutex_s { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __pthread_cond_s { pub __bindgen_anon_1 : __pthread_cond_s__bindgen_ty_1 , pub __bindgen_anon_2 : __pthread_cond_s__bindgen_ty_2 , pub __g_refs : [ libc :: c_uint ; 2usize ] , pub __g_size : [ libc :: c_uint ; 2usize ] , pub __g1_orig_size : libc :: c_uint , pub __wrefs : libc :: c_uint , pub __g_signals : [ libc :: c_uint ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_1 { pub __wseq : libc :: c_ulonglong , pub __wseq32 : __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 { pub __low : libc :: c_uint , pub __high : libc :: c_uint , } impl Default for __pthread_cond_s__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_2 { pub __g1_start : libc :: c_ulonglong , pub __g1_start32 : __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 { pub __low : libc :: c_uint , pub __high : libc :: c_uint , } impl Default for __pthread_cond_s__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for __pthread_cond_s { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_t = libc :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ libc :: c_char ; 4usize ] , pub __align : libc :: c_int , _bindgen_union_align : u32 , } impl Default for pthread_mutexattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ libc :: c_char ; 4usize ] , pub __align : libc :: c_int , _bindgen_union_align : u32 , } impl Default for pthread_condattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_key_t = libc :: c_uint ; pub type pthread_once_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ libc :: c_char ; 56usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } impl Default for pthread_attr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [ libc :: c_char ; 40usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } impl Default for pthread_mutex_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [ libc :: c_char ; 48usize ] , pub __align : libc :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } impl Default for pthread_cond_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : __pthread_rwlock_arch_t , pub __size : [ libc :: c_char ; 56usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } impl Default for pthread_rwlock_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ libc :: c_char ; 8usize ] , pub __align : libc :: c_long , _bindgen_union_align : u64 , } impl Default for pthread_rwlockattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_spinlock_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ libc :: c_char ; 32usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } impl Default for pthread_barrier_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ libc :: c_char ; 4usize ] , pub __align : libc :: c_int , _bindgen_union_align : u32 , } impl Default for pthread_barrierattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn random ( ) -> libc :: c_long ; } extern "C" { pub fn srandom ( __seed : libc :: c_uint ) ; } extern "C" { pub fn initstate ( __seed : libc :: c_uint , __statebuf : * mut libc :: c_char , __statelen : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn setstate ( __statebuf : * mut libc :: c_char ) -> * mut libc :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : libc :: c_int , pub rand_deg : libc :: c_int , pub rand_sep : libc :: c_int , pub end_ptr : * mut i32 , } impl Default for random_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn random_r ( __buf : * mut random_data , __result : * mut i32 ) -> libc :: c_int ; } extern "C" { pub fn srandom_r ( __seed : libc :: c_uint , __buf : * mut random_data ) -> libc :: c_int ; } extern "C" { pub fn initstate_r ( __seed : libc :: c_uint , __statebuf : * mut libc :: c_char , __statelen : usize , __buf : * mut random_data ) -> libc :: c_int ; } extern "C" { pub fn setstate_r ( __statebuf : * mut libc :: c_char , __buf : * mut random_data ) -> libc :: c_int ; } extern "C" { pub fn rand ( ) -> libc :: c_int ; } extern "C" { pub fn srand ( __seed : libc :: c_uint ) ; } extern "C" { pub fn rand_r ( __seed : * mut libc :: c_uint ) -> libc :: c_int ; } extern "C" { pub fn drand48 ( ) -> f64 ; } extern "C" { pub fn erand48 ( __xsubi : * mut libc :: c_ushort ) -> f64 ; } extern "C" { pub fn lrand48 ( ) -> libc :: c_long ; } extern "C" { pub fn nrand48 ( __xsubi : * mut libc :: c_ushort ) -> libc :: c_long ; } extern "C" { pub fn mrand48 ( ) -> libc :: c_long ; } extern "C" { pub fn jrand48 ( __xsubi : * mut libc :: c_ushort ) -> libc :: c_long ; } extern "C" { pub fn srand48 ( __seedval : libc :: c_long ) ; } extern "C" { pub fn seed48 ( __seed16v : * mut libc :: c_ushort ) -> * mut libc :: c_ushort ; } extern "C" { pub fn lcong48 ( __param : * mut libc :: c_ushort ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct drand48_data { pub __x : [ libc :: c_ushort ; 3usize ] , pub __old_x : [ libc :: c_ushort ; 3usize ] , pub __c : libc :: c_ushort , pub __init : libc :: c_ushort , pub __a : libc :: c_ulonglong , } extern "C" { pub fn drand48_r ( __buffer : * mut drand48_data , __result : * mut f64 ) -> libc :: c_int ; } extern "C" { pub fn erand48_r ( __xsubi : * mut libc :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64 ) -> libc :: c_int ; } extern "C" { pub fn lrand48_r ( __buffer : * mut drand48_data , __result : * mut libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn nrand48_r ( __xsubi : * mut libc :: c_ushort , __buffer : * mut drand48_data , __result : * mut libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn mrand48_r ( __buffer : * mut drand48_data , __result : * mut libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn jrand48_r ( __xsubi : * mut libc :: c_ushort , __buffer : * mut drand48_data , __result : * mut libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn srand48_r ( __seedval : libc :: c_long , __buffer : * mut drand48_data ) -> libc :: c_int ; } extern "C" { pub fn seed48_r ( __seed16v : * mut libc :: c_ushort , __buffer : * mut drand48_data ) -> libc :: c_int ; } extern "C" { pub fn lcong48_r ( __param : * mut libc :: c_ushort , __buffer : * mut drand48_data ) -> libc :: c_int ; } extern "C" { pub fn malloc ( __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn calloc ( __nmemb : usize , __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn realloc ( __ptr : * mut libc :: c_void , __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn free ( __ptr : * mut libc :: c_void ) ; } extern "C" { pub fn alloca ( __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn valloc ( __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn posix_memalign ( __memptr : * mut * mut libc :: c_void , __alignment : usize , __size : usize ) -> libc :: c_int ; } extern "C" { pub fn aligned_alloc ( __alignment : usize , __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn abort ( ) ; } extern "C" { pub fn atexit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> libc :: c_int ; } extern "C" { pub fn at_quick_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> libc :: c_int ; } extern "C" { pub fn on_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( __status : libc :: c_int , __arg : * mut libc :: c_void ) > , __arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn exit ( __status : libc :: c_int ) ; } extern "C" { pub fn quick_exit ( __status : libc :: c_int ) ; } extern "C" { pub fn _Exit ( __status : libc :: c_int ) ; } extern "C" { pub fn getenv ( __name : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn putenv ( __string : * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn setenv ( __name : * const libc :: c_char , __value : * const libc :: c_char , __replace : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn unsetenv ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn clearenv ( ) -> libc :: c_int ; } extern "C" { pub fn mktemp ( __template : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn mkstemp ( __template : * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn mkstemps ( __template : * mut libc :: c_char , __suffixlen : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn mkdtemp ( __template : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn system ( __command : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn realpath ( __name : * const libc :: c_char , __resolved : * mut libc :: c_char ) -> * mut libc :: c_char ; } pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const libc :: c_void , arg2 : * const libc :: c_void ) -> libc :: c_int > ; extern "C" { pub fn bsearch ( __key : * const libc :: c_void , __base : * const libc :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) -> * mut libc :: c_void ; } extern "C" { pub fn qsort ( __base : * mut libc :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) ; } extern "C" { pub fn abs ( __x : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn labs ( __x : libc :: c_long ) -> libc :: c_long ; } extern "C" { pub fn llabs ( __x : libc :: c_longlong ) -> libc :: c_longlong ; } extern "C" { pub fn div ( __numer : libc :: c_int , __denom : libc :: c_int ) -> div_t ; } extern "C" { pub fn ldiv ( __numer : libc :: c_long , __denom : libc :: c_long ) -> ldiv_t ; } extern "C" { pub fn lldiv ( __numer : libc :: c_longlong , __denom : libc :: c_longlong ) -> lldiv_t ; } extern "C" { pub fn ecvt ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn fcvt ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn gcvt ( __value : f64 , __ndigit : libc :: c_int , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn qecvt ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn qfcvt ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn qgcvt ( __value : f64 , __ndigit : libc :: c_int , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn ecvt_r ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn fcvt_r ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn qecvt_r ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn qfcvt_r ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn mblen ( __s : * const libc :: c_char , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn mbtowc ( __pwc : * mut wchar_t , __s : * const libc :: c_char , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn wctomb ( __s : * mut libc :: c_char , __wchar : wchar_t ) -> libc :: c_int ; } extern "C" { pub fn mbstowcs ( __pwcs : * mut wchar_t , __s : * const libc :: c_char , __n : usize ) -> usize ; } extern "C" { pub fn wcstombs ( __s : * mut libc :: c_char , __pwcs : * const wchar_t , __n : usize ) -> usize ; } extern "C" { pub fn rpmatch ( __response : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getsubopt ( __optionp : * mut * mut libc :: c_char , __tokens : * const * mut libc :: c_char , __valuep : * mut * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getloadavg ( __loadavg : * mut f64 , __nelem : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn memcpy ( __dest : * mut libc :: c_void , __src : * const libc :: c_void , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn memmove ( __dest : * mut libc :: c_void , __src : * const libc :: c_void , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn memccpy ( __dest : * mut libc :: c_void , __src : * const libc :: c_void , __c : libc :: c_int , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn memset ( __s : * mut libc :: c_void , __c : libc :: c_int , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn memcmp ( __s1 : * const libc :: c_void , __s2 : * const libc :: c_void , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn memchr ( __s : * const libc :: c_void , __c : libc :: c_int , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn strcpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strncpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn strcat ( __dest : * mut libc :: c_char , __src : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strncat ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn strcmp ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn strncmp ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn strcoll ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn strxfrm ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> libc :: c_ulong ; } extern "C" { pub fn strcoll_l ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn strxfrm_l ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize , __l : locale_t ) -> usize ; } extern "C" { pub fn strdup ( __s : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strndup ( __string : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn strchr ( __s : * const libc :: c_char , __c : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn strrchr ( __s : * const libc :: c_char , __c : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn strcspn ( __s : * const libc :: c_char , __reject : * const libc :: c_char ) -> libc :: c_ulong ; } extern "C" { pub fn strspn ( __s : * const libc :: c_char , __accept : * const libc :: c_char ) -> libc :: c_ulong ; } extern "C" { pub fn strpbrk ( __s : * const libc :: c_char , __accept : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strstr ( __haystack : * const libc :: c_char , __needle : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strtok ( __s : * mut libc :: c_char , __delim : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn __strtok_r ( __s : * mut libc :: c_char , __delim : * const libc :: c_char , __save_ptr : * mut * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strtok_r ( __s : * mut libc :: c_char , __delim : * const libc :: c_char , __save_ptr : * mut * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strlen ( __s : * const libc :: c_char ) -> libc :: c_ulong ; } extern "C" { pub fn strnlen ( __string : * const libc :: c_char , __maxlen : usize ) -> usize ; } extern "C" { pub fn strerror ( __errnum : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn strerror_r ( __errnum : libc :: c_int , __buf : * mut libc :: c_char , __buflen : usize ) -> libc :: c_int ; } extern "C" { pub fn strerror_l ( __errnum : libc :: c_int , __l : locale_t ) -> * mut libc :: c_char ; } extern "C" { pub fn bcmp ( __s1 : * const libc :: c_void , __s2 : * const libc :: c_void , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn bcopy ( __src : * const libc :: c_void , __dest : * mut libc :: c_void , __n : usize ) ; } extern "C" { pub fn bzero ( __s : * mut libc :: c_void , __n : usize ) ; } extern "C" { pub fn index ( __s : * const libc :: c_char , __c : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn rindex ( __s : * const libc :: c_char , __c : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn ffs ( __i : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ffsl ( __l : libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn ffsll ( __ll : libc :: c_longlong ) -> libc :: c_int ; } extern "C" { pub fn strcasecmp ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn strncasecmp ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn strcasecmp_l ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __loc : locale_t ) -> libc :: c_int ; } extern "C" { pub fn strncasecmp_l ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __n : usize , __loc : locale_t ) -> libc :: c_int ; } extern "C" { pub fn explicit_bzero ( __s : * mut libc :: c_void , __n : usize ) ; } extern "C" { pub fn strsep ( __stringp : * mut * mut libc :: c_char , __delim : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strsignal ( __sig : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn __stpcpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn stpcpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn __stpncpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn stpncpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tm { pub tm_sec : libc :: c_int , pub tm_min : libc :: c_int , pub tm_hour : libc :: c_int , pub tm_mday : libc :: c_int , pub tm_mon : libc :: c_int , pub tm_year : libc :: c_int , pub tm_wday : libc :: c_int , pub tm_yday : libc :: c_int , pub tm_isdst : libc :: c_int , pub tm_gmtoff : libc :: c_long , pub tm_zone : * const libc :: c_char , } impl Default for tm { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct itimerspec { pub it_interval : timespec , pub it_value : timespec , } extern "C" { pub fn clock ( ) -> clock_t ; } extern "C" { pub fn time ( __timer : * mut time_t ) -> time_t ; } extern "C" { pub fn difftime ( __time1 : time_t , __time0 : time_t ) -> f64 ; } extern "C" { pub fn mktime ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn strftime ( __s : * mut libc :: c_char , __maxsize : usize , __format : * const libc :: c_char , __tp : * const tm ) -> usize ; } extern "C" { pub fn strftime_l ( __s : * mut libc :: c_char , __maxsize : usize , __format : * const libc :: c_char , __tp : * const tm , __loc : locale_t ) -> usize ; } extern "C" { pub fn gmtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { pub fn localtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { pub fn gmtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { pub fn localtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { pub fn asctime ( __tp : * const tm ) -> * mut libc :: c_char ; } extern "C" { pub fn ctime ( __timer : * const time_t ) -> * mut libc :: c_char ; } extern "C" { pub fn asctime_r ( __tp : * const tm , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn ctime_r ( __timer : * const time_t , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn tzset ( ) ; } extern "C" { pub fn stime ( __when : * const time_t ) -> libc :: c_int ; } extern "C" { pub fn timegm ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn timelocal ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn dysize ( __year : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn nanosleep ( __requested_time : * const timespec , __remaining : * mut timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_getres ( __clock_id : clockid_t , __res : * mut timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_gettime ( __clock_id : clockid_t , __tp : * mut timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_settime ( __clock_id : clockid_t , __tp : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_nanosleep ( __clock_id : clockid_t , __flags : libc :: c_int , __req : * const timespec , __rem : * mut timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_getcpuclockid ( __pid : pid_t , __clock_id : * mut clockid_t ) -> libc :: c_int ; } extern "C" { pub fn timer_create ( __clock_id : clockid_t , __evp : * mut sigevent , __timerid : * mut timer_t ) -> libc :: c_int ; } extern "C" { pub fn timer_delete ( __timerid : timer_t ) -> libc :: c_int ; } extern "C" { pub fn timer_settime ( __timerid : timer_t , __flags : libc :: c_int , __value : * const itimerspec , __ovalue : * mut itimerspec ) -> libc :: c_int ; } extern "C" { pub fn timer_gettime ( __timerid : timer_t , __value : * mut itimerspec ) -> libc :: c_int ; } extern "C" { pub fn timer_getoverrun ( __timerid : timer_t ) -> libc :: c_int ; } extern "C" { pub fn timespec_get ( __ts : * mut timespec , __base : libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct iovec { pub iov_base : * mut libc :: c_void , pub iov_len : usize , } impl Default for iovec { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type socklen_t = __socklen_t ; pub const __socket_type_SOCK_STREAM : __socket_type = 1 ; pub const __socket_type_SOCK_DGRAM : __socket_type = 2 ; pub const __socket_type_SOCK_RAW : __socket_type = 3 ; pub const __socket_type_SOCK_RDM : __socket_type = 4 ; pub const __socket_type_SOCK_SEQPACKET : __socket_type = 5 ; pub const __socket_type_SOCK_DCCP : __socket_type = 6 ; pub const __socket_type_SOCK_PACKET : __socket_type = 10 ; pub const __socket_type_SOCK_CLOEXEC : __socket_type = 524288 ; pub const __socket_type_SOCK_NONBLOCK : __socket_type = 2048 ; pub type __socket_type = u32 ; pub type sa_family_t = libc :: c_ushort ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sockaddr { pub sa_family : sa_family_t , pub sa_data : [ libc :: c_char ; 14usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_storage { pub ss_family : sa_family_t , pub __ss_padding : [ libc :: c_char ; 118usize ] , pub __ss_align : libc :: c_ulong , } impl Default for sockaddr_storage { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const MSG_OOB : _bindgen_ty_2 = 1 ; pub const MSG_PEEK : _bindgen_ty_2 = 2 ; pub const MSG_DONTROUTE : _bindgen_ty_2 = 4 ; pub const MSG_CTRUNC : _bindgen_ty_2 = 8 ; pub const MSG_PROXY : _bindgen_ty_2 = 16 ; pub const MSG_TRUNC : _bindgen_ty_2 = 32 ; pub const MSG_DONTWAIT : _bindgen_ty_2 = 64 ; pub const MSG_EOR : _bindgen_ty_2 = 128 ; pub const MSG_WAITALL : _bindgen_ty_2 = 256 ; pub const MSG_FIN : _bindgen_ty_2 = 512 ; pub const MSG_SYN : _bindgen_ty_2 = 1024 ; pub const MSG_CONFIRM : _bindgen_ty_2 = 2048 ; pub const MSG_RST : _bindgen_ty_2 = 4096 ; pub const MSG_ERRQUEUE : _bindgen_ty_2 = 8192 ; pub const MSG_NOSIGNAL : _bindgen_ty_2 = 16384 ; pub const MSG_MORE : _bindgen_ty_2 = 32768 ; pub const MSG_WAITFORONE : _bindgen_ty_2 = 65536 ; pub const MSG_BATCH : _bindgen_ty_2 = 262144 ; pub const MSG_ZEROCOPY : _bindgen_ty_2 = 67108864 ; pub const MSG_FASTOPEN : _bindgen_ty_2 = 536870912 ; pub const MSG_CMSG_CLOEXEC : _bindgen_ty_2 = 1073741824 ; pub type _bindgen_ty_2 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct msghdr { pub msg_name : * mut libc :: c_void , pub msg_namelen : socklen_t , pub msg_iov : * mut iovec , pub msg_iovlen : usize , pub msg_control : * mut libc :: c_void , pub msg_controllen : usize , pub msg_flags : libc :: c_int , } impl Default for msghdr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct cmsghdr { pub cmsg_len : usize , pub cmsg_level : libc :: c_int , pub cmsg_type : libc :: c_int , pub __cmsg_data : __IncompleteArrayField < libc :: c_uchar > , } extern "C" { pub fn __cmsg_nxthdr ( __mhdr : * mut msghdr , __cmsg : * mut cmsghdr ) -> * mut cmsghdr ; } pub const SCM_RIGHTS : _bindgen_ty_3 = 1 ; pub type _bindgen_ty_3 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct linger { pub l_onoff : libc :: c_int , pub l_linger : libc :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct osockaddr { pub sa_family : libc :: c_ushort , pub sa_data : [ libc :: c_uchar ; 14usize ] , } pub const SHUT_RD : _bindgen_ty_4 = 0 ; pub const SHUT_WR : _bindgen_ty_4 = 1 ; pub const SHUT_RDWR : _bindgen_ty_4 = 2 ; pub type _bindgen_ty_4 = u32 ; extern "C" { pub fn socket ( __domain : libc :: c_int , __type : libc :: c_int , __protocol : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn socketpair ( __domain : libc :: c_int , __type : libc :: c_int , __protocol : libc :: c_int , __fds : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn bind ( __fd : libc :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> libc :: c_int ; } extern "C" { pub fn getsockname ( __fd : libc :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> libc :: c_int ; } extern "C" { pub fn connect ( __fd : libc :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> libc :: c_int ; } extern "C" { pub fn getpeername ( __fd : libc :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> libc :: c_int ; } extern "C" { pub fn send ( __fd : libc :: c_int , __buf : * const libc :: c_void , __n : usize , __flags : libc :: c_int ) -> isize ; } extern "C" { pub fn recv ( __fd : libc :: c_int , __buf : * mut libc :: c_void , __n : usize , __flags : libc :: c_int ) -> isize ; } extern "C" { pub fn sendto ( __fd : libc :: c_int , __buf : * const libc :: c_void , __n : usize , __flags : libc :: c_int , __addr : * const sockaddr , __addr_len : socklen_t ) -> isize ; } extern "C" { pub fn recvfrom ( __fd : libc :: c_int , __buf : * mut libc :: c_void , __n : usize , __flags : libc :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> isize ; } extern "C" { pub fn sendmsg ( __fd : libc :: c_int , __message : * const msghdr , __flags : libc :: c_int ) -> isize ; } extern "C" { pub fn recvmsg ( __fd : libc :: c_int , __message : * mut msghdr , __flags : libc :: c_int ) -> isize ; } extern "C" { pub fn getsockopt ( __fd : libc :: c_int , __level : libc :: c_int , __optname : libc :: c_int , __optval : * mut libc :: c_void , __optlen : * mut socklen_t ) -> libc :: c_int ; } extern "C" { pub fn setsockopt ( __fd : libc :: c_int , __level : libc :: c_int , __optname : libc :: c_int , __optval : * const libc :: c_void , __optlen : socklen_t ) -> libc :: c_int ; } extern "C" { pub fn listen ( __fd : libc :: c_int , __n : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn accept ( __fd : libc :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> libc :: c_int ; } extern "C" { pub fn shutdown ( __fd : libc :: c_int , __how : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sockatmark ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isfdtype ( __fd : libc :: c_int , __fdtype : libc :: c_int ) -> libc :: c_int ; } pub type in_addr_t = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct in_addr { pub s_addr : in_addr_t , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ip_opts { pub ip_dst : in_addr , pub ip_opts : [ libc :: c_char ; 40usize ] , } impl Default for ip_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreqn { pub imr_multiaddr : in_addr , pub imr_address : in_addr , pub imr_ifindex : libc :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct in_pktinfo { pub ipi_ifindex : libc :: c_int , pub ipi_spec_dst : in_addr , pub ipi_addr : in_addr , } pub const IPPROTO_IP : _bindgen_ty_5 = 0 ; pub const IPPROTO_ICMP : _bindgen_ty_5 = 1 ; pub const IPPROTO_IGMP : _bindgen_ty_5 = 2 ; pub const IPPROTO_IPIP : _bindgen_ty_5 = 4 ; pub const IPPROTO_TCP : _bindgen_ty_5 = 6 ; pub const IPPROTO_EGP : _bindgen_ty_5 = 8 ; pub const IPPROTO_PUP : _bindgen_ty_5 = 12 ; pub const IPPROTO_UDP : _bindgen_ty_5 = 17 ; pub const IPPROTO_IDP : _bindgen_ty_5 = 22 ; pub const IPPROTO_TP : _bindgen_ty_5 = 29 ; pub const IPPROTO_DCCP : _bindgen_ty_5 = 33 ; pub const IPPROTO_IPV6 : _bindgen_ty_5 = 41 ; pub const IPPROTO_RSVP : _bindgen_ty_5 = 46 ; pub const IPPROTO_GRE : _bindgen_ty_5 = 47 ; pub const IPPROTO_ESP : _bindgen_ty_5 = 50 ; pub const IPPROTO_AH : _bindgen_ty_5 = 51 ; pub const IPPROTO_MTP : _bindgen_ty_5 = 92 ; pub const IPPROTO_BEETPH : _bindgen_ty_5 = 94 ; pub const IPPROTO_ENCAP : _bindgen_ty_5 = 98 ; pub const IPPROTO_PIM : _bindgen_ty_5 = 103 ; pub const IPPROTO_COMP : _bindgen_ty_5 = 108 ; pub const IPPROTO_SCTP : _bindgen_ty_5 = 132 ; pub const IPPROTO_UDPLITE : _bindgen_ty_5 = 136 ; pub const IPPROTO_MPLS : _bindgen_ty_5 = 137 ; pub const IPPROTO_RAW : _bindgen_ty_5 = 255 ; pub const IPPROTO_MAX : _bindgen_ty_5 = 256 ; pub type _bindgen_ty_5 = u32 ; pub const IPPROTO_HOPOPTS : _bindgen_ty_6 = 0 ; pub const IPPROTO_ROUTING : _bindgen_ty_6 = 43 ; pub const IPPROTO_FRAGMENT : _bindgen_ty_6 = 44 ; pub const IPPROTO_ICMPV6 : _bindgen_ty_6 = 58 ; pub const IPPROTO_NONE : _bindgen_ty_6 = 59 ; pub const IPPROTO_DSTOPTS : _bindgen_ty_6 = 60 ; pub const IPPROTO_MH : _bindgen_ty_6 = 135 ; pub type _bindgen_ty_6 = u32 ; pub type in_port_t = u16 ; pub const IPPORT_ECHO : _bindgen_ty_7 = 7 ; pub const IPPORT_DISCARD : _bindgen_ty_7 = 9 ; pub const IPPORT_SYSTAT : _bindgen_ty_7 = 11 ; pub const IPPORT_DAYTIME : _bindgen_ty_7 = 13 ; pub const IPPORT_NETSTAT : _bindgen_ty_7 = 15 ; pub const IPPORT_FTP : _bindgen_ty_7 = 21 ; pub const IPPORT_TELNET : _bindgen_ty_7 = 23 ; pub const IPPORT_SMTP : _bindgen_ty_7 = 25 ; pub const IPPORT_TIMESERVER : _bindgen_ty_7 = 37 ; pub const IPPORT_NAMESERVER : _bindgen_ty_7 = 42 ; pub const IPPORT_WHOIS : _bindgen_ty_7 = 43 ; pub const IPPORT_MTP : _bindgen_ty_7 = 57 ; pub const IPPORT_TFTP : _bindgen_ty_7 = 69 ; pub const IPPORT_RJE : _bindgen_ty_7 = 77 ; pub const IPPORT_FINGER : _bindgen_ty_7 = 79 ; pub const IPPORT_TTYLINK : _bindgen_ty_7 = 87 ; pub const IPPORT_SUPDUP : _bindgen_ty_7 = 95 ; pub const IPPORT_EXECSERVER : _bindgen_ty_7 = 512 ; pub const IPPORT_LOGINSERVER : _bindgen_ty_7 = 513 ; pub const IPPORT_CMDSERVER : _bindgen_ty_7 = 514 ; pub const IPPORT_EFSSERVER : _bindgen_ty_7 = 520 ; pub const IPPORT_BIFFUDP : _bindgen_ty_7 = 512 ; pub const IPPORT_WHOSERVER : _bindgen_ty_7 = 513 ; pub const IPPORT_ROUTESERVER : _bindgen_ty_7 = 520 ; pub const IPPORT_RESERVED : _bindgen_ty_7 = 1024 ; pub const IPPORT_USERRESERVED : _bindgen_ty_7 = 5000 ; pub type _bindgen_ty_7 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct in6_addr { pub __in6_u : in6_addr__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union in6_addr__bindgen_ty_1 { pub __u6_addr8 : [ u8 ; 16usize ] , pub __u6_addr16 : [ u16 ; 8usize ] , pub __u6_addr32 : [ u32 ; 4usize ] , _bindgen_union_align : [ u32 ; 4usize ] , } impl Default for in6_addr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for in6_addr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sockaddr_in { pub sin_family : sa_family_t , pub sin_port : in_port_t , pub sin_addr : in_addr , pub sin_zero : [ libc :: c_uchar ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_in6 { pub sin6_family : sa_family_t , pub sin6_port : in_port_t , pub sin6_flowinfo : u32 , pub sin6_addr : in6_addr , pub sin6_scope_id : u32 , } impl Default for sockaddr_in6 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreq { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreq_source { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , pub imr_sourceaddr : in_addr , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ipv6_mreq { pub ipv6mr_multiaddr : in6_addr , pub ipv6mr_interface : libc :: c_uint , } impl Default for ipv6_mreq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_req { pub gr_interface : u32 , pub gr_group : sockaddr_storage , } impl Default for group_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_source_req { pub gsr_interface : u32 , pub gsr_group : sockaddr_storage , pub gsr_source : sockaddr_storage , } impl Default for group_source_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_msfilter { pub imsf_multiaddr : in_addr , pub imsf_interface : in_addr , pub imsf_fmode : u32 , pub imsf_numsrc : u32 , pub imsf_slist : [ in_addr ; 1usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_filter { pub gf_interface : u32 , pub gf_group : sockaddr_storage , pub gf_fmode : u32 , pub gf_numsrc : u32 , pub gf_slist : [ sockaddr_storage ; 1usize ] , } impl Default for group_filter { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn ntohl ( __netlong : u32 ) -> u32 ; } extern "C" { pub fn ntohs ( __netshort : u16 ) -> u16 ; } extern "C" { pub fn htonl ( __hostlong : u32 ) -> u32 ; } extern "C" { pub fn htons ( __hostshort : u16 ) -> u16 ; } extern "C" { pub fn bindresvport ( __sockfd : libc :: c_int , __sock_in : * mut sockaddr_in ) -> libc :: c_int ; } extern "C" { pub fn bindresvport6 ( __sockfd : libc :: c_int , __sock_in : * mut sockaddr_in6 ) -> libc :: c_int ; } extern "C" { pub fn inet_addr ( __cp : * const libc :: c_char ) -> in_addr_t ; } extern "C" { pub fn inet_lnaof ( __in : in_addr ) -> in_addr_t ; } extern "C" { pub fn inet_makeaddr ( __net : in_addr_t , __host : in_addr_t ) -> in_addr ; } extern "C" { pub fn inet_netof ( __in : in_addr ) -> in_addr_t ; } extern "C" { pub fn inet_network ( __cp : * const libc :: c_char ) -> in_addr_t ; } extern "C" { pub fn inet_ntoa ( __in : in_addr ) -> * mut libc :: c_char ; } extern "C" { pub fn inet_pton ( __af : libc :: c_int , __cp : * const libc :: c_char , __buf : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn inet_ntop ( __af : libc :: c_int , __cp : * const libc :: c_void , __buf : * mut libc :: c_char , __len : socklen_t ) -> * const libc :: c_char ; } extern "C" { pub fn inet_aton ( __cp : * const libc :: c_char , __inp : * mut in_addr ) -> libc :: c_int ; } extern "C" { pub fn inet_neta ( __net : in_addr_t , __buf : * mut libc :: c_char , __len : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn inet_net_ntop ( __af : libc :: c_int , __cp : * const libc :: c_void , __bits : libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn inet_net_pton ( __af : libc :: c_int , __cp : * const libc :: c_char , __buf : * mut libc :: c_void , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn inet_nsap_addr ( __cp : * const libc :: c_char , __buf : * mut libc :: c_uchar , __len : libc :: c_int ) -> libc :: c_uint ; } extern "C" { pub fn inet_nsap_ntoa ( __len : libc :: c_int , __cp : * const libc :: c_uchar , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct dirent { pub d_ino : __ino_t , pub d_off : __off_t , pub d_reclen : libc :: c_ushort , pub d_type : libc :: c_uchar , pub d_name : [ libc :: c_char ; 256usize ] , } impl Default for dirent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const DT_UNKNOWN : _bindgen_ty_8 = 0 ; pub const DT_FIFO : _bindgen_ty_8 = 1 ; pub const DT_CHR : _bindgen_ty_8 = 2 ; pub const DT_DIR : _bindgen_ty_8 = 4 ; pub const DT_BLK : _bindgen_ty_8 = 6 ; pub const DT_REG : _bindgen_ty_8 = 8 ; pub const DT_LNK : _bindgen_ty_8 = 10 ; pub const DT_SOCK : _bindgen_ty_8 = 12 ; pub const DT_WHT : _bindgen_ty_8 = 14 ; pub type _bindgen_ty_8 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __dirstream { _unused : [ u8 ; 0 ] , } pub type DIR = __dirstream ; extern "C" { pub fn opendir ( __name : * const libc :: c_char ) -> * mut DIR ; } extern "C" { pub fn fdopendir ( __fd : libc :: c_int ) -> * mut DIR ; } extern "C" { pub fn closedir ( __dirp : * mut DIR ) -> libc :: c_int ; } extern "C" { pub fn readdir ( __dirp : * mut DIR ) -> * mut dirent ; } extern "C" { pub fn readdir_r ( __dirp : * mut DIR , __entry : * mut dirent , __result : * mut * mut dirent ) -> libc :: c_int ; } extern "C" { pub fn rewinddir ( __dirp : * mut DIR ) ; } extern "C" { pub fn seekdir ( __dirp : * mut DIR , __pos : libc :: c_long ) ; } extern "C" { pub fn telldir ( __dirp : * mut DIR ) -> libc :: c_long ; } extern "C" { pub fn dirfd ( __dirp : * mut DIR ) -> libc :: c_int ; } extern "C" { pub fn scandir ( __dir : * const libc :: c_char , __namelist : * mut * mut * mut dirent , __selector : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const dirent ) -> libc :: c_int > , __cmp : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut * const dirent , arg2 : * mut * const dirent ) -> libc :: c_int > ) -> libc :: c_int ; } extern "C" { pub fn alphasort ( __e1 : * mut * const dirent , __e2 : * mut * const dirent ) -> libc :: c_int ; } extern "C" { pub fn getdirentries ( __fd : libc :: c_int , __buf : * mut libc :: c_char , __nbytes : usize , __basep : * mut __off_t ) -> __ssize_t ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct flock { pub l_type : libc :: c_short , pub l_whence : libc :: c_short , pub l_start : __off_t , pub l_len : __off_t , pub l_pid : __pid_t , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct stat { pub st_dev : __dev_t , pub st_ino : __ino_t , pub st_nlink : __nlink_t , pub st_mode : __mode_t , pub st_uid : __uid_t , pub st_gid : __gid_t , pub __pad0 : libc :: c_int , pub st_rdev : __dev_t , pub st_size : __off_t , pub st_blksize : __blksize_t , pub st_blocks : __blkcnt_t , pub st_atim : timespec , pub st_mtim : timespec , pub st_ctim : timespec , pub __glibc_reserved : [ __syscall_slong_t ; 3usize ] , } extern "C" { pub fn fcntl ( __fd : libc :: c_int , __cmd : libc :: c_int , ... ) -> libc :: c_int ; } extern "C" { pub fn open ( __file : * const libc :: c_char , __oflag : libc :: c_int , ... ) -> libc :: c_int ; } extern "C" { pub fn openat ( __fd : libc :: c_int , __file : * const libc :: c_char , __oflag : libc :: c_int , ... ) -> libc :: c_int ; } extern "C" { pub fn creat ( __file : * const libc :: c_char , __mode : mode_t ) -> libc :: c_int ; } extern "C" { pub fn lockf ( __fd : libc :: c_int , __cmd : libc :: c_int , __len : off_t ) -> libc :: c_int ; } extern "C" { pub fn posix_fadvise ( __fd : libc :: c_int , __offset : off_t , __len : off_t , __advise : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn posix_fallocate ( __fd : libc :: c_int , __offset : off_t , __len : off_t ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifaddrs { pub ifa_next : * mut ifaddrs , pub ifa_name : * mut libc :: c_char , pub ifa_flags : libc :: c_uint , pub ifa_addr : * mut sockaddr , pub ifa_netmask : * mut sockaddr , pub ifa_ifu : ifaddrs__bindgen_ty_1 , pub ifa_data : * mut libc :: c_void , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifaddrs__bindgen_ty_1 { pub ifu_broadaddr : * mut sockaddr , pub ifu_dstaddr : * mut sockaddr , _bindgen_union_align : u64 , } impl Default for ifaddrs__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for ifaddrs { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn getifaddrs ( __ifap : * mut * mut ifaddrs ) -> libc :: c_int ; } extern "C" { pub fn freeifaddrs ( __ifa : * mut ifaddrs ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rpcent { pub r_name : * mut libc :: c_char , pub r_aliases : * mut * mut libc :: c_char , pub r_number : libc :: c_int , } impl Default for rpcent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn setrpcent ( __stayopen : libc :: c_int ) ; } extern "C" { pub fn endrpcent ( ) ; } extern "C" { pub fn getrpcbyname ( __name : * const libc :: c_char ) -> * mut rpcent ; } extern "C" { pub fn getrpcbynumber ( __number : libc :: c_int ) -> * mut rpcent ; } extern "C" { pub fn getrpcent ( ) -> * mut rpcent ; } extern "C" { pub fn getrpcbyname_r ( __name : * const libc :: c_char , __result_buf : * mut rpcent , __buffer : * mut libc :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> libc :: c_int ; } extern "C" { pub fn getrpcbynumber_r ( __number : libc :: c_int , __result_buf : * mut rpcent , __buffer : * mut libc :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> libc :: c_int ; } extern "C" { pub fn getrpcent_r ( __result_buf : * mut rpcent , __buffer : * mut libc :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct netent { pub n_name : * mut libc :: c_char , pub n_aliases : * mut * mut libc :: c_char , pub n_addrtype : libc :: c_int , pub n_net : u32 , } impl Default for netent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn __h_errno_location ( ) -> * mut libc :: c_int ; } extern "C" { pub fn herror ( __str : * const libc :: c_char ) ; } extern "C" { pub fn hstrerror ( __err_num : libc :: c_int ) -> * const libc :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hostent { pub h_name : * mut libc :: c_char , pub h_aliases : * mut * mut libc :: c_char , pub h_addrtype : libc :: c_int , pub h_length : libc :: c_int , pub h_addr_list : * mut * mut libc :: c_char , } impl Default for hostent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sethostent ( __stay_open : libc :: c_int ) ; } extern "C" { pub fn endhostent ( ) ; } extern "C" { pub fn gethostent ( ) -> * mut hostent ; } extern "C" { pub fn gethostbyaddr ( __addr : * const libc :: c_void , __len : __socklen_t , __type : libc :: c_int ) -> * mut hostent ; } extern "C" { pub fn gethostbyname ( __name : * const libc :: c_char ) -> * mut hostent ; } extern "C" { pub fn gethostbyname2 ( __name : * const libc :: c_char , __af : libc :: c_int ) -> * mut hostent ; } extern "C" { pub fn gethostent_r ( __result_buf : * mut hostent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn gethostbyaddr_r ( __addr : * const libc :: c_void , __len : __socklen_t , __type : libc :: c_int , __result_buf : * mut hostent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn gethostbyname_r ( __name : * const libc :: c_char , __result_buf : * mut hostent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn gethostbyname2_r ( __name : * const libc :: c_char , __af : libc :: c_int , __result_buf : * mut hostent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn setnetent ( __stay_open : libc :: c_int ) ; } extern "C" { pub fn endnetent ( ) ; } extern "C" { pub fn getnetent ( ) -> * mut netent ; } extern "C" { pub fn getnetbyaddr ( __net : u32 , __type : libc :: c_int ) -> * mut netent ; } extern "C" { pub fn getnetbyname ( __name : * const libc :: c_char ) -> * mut netent ; } extern "C" { pub fn getnetent_r ( __result_buf : * mut netent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getnetbyaddr_r ( __net : u32 , __type : libc :: c_int , __result_buf : * mut netent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getnetbyname_r ( __name : * const libc :: c_char , __result_buf : * mut netent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct servent { pub s_name : * mut libc :: c_char , pub s_aliases : * mut * mut libc :: c_char , pub s_port : libc :: c_int , pub s_proto : * mut libc :: c_char , } impl Default for servent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn setservent ( __stay_open : libc :: c_int ) ; } extern "C" { pub fn endservent ( ) ; } extern "C" { pub fn getservent ( ) -> * mut servent ; } extern "C" { pub fn getservbyname ( __name : * const libc :: c_char , __proto : * const libc :: c_char ) -> * mut servent ; } extern "C" { pub fn getservbyport ( __port : libc :: c_int , __proto : * const libc :: c_char ) -> * mut servent ; } extern "C" { pub fn getservent_r ( __result_buf : * mut servent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut servent ) -> libc :: c_int ; } extern "C" { pub fn getservbyname_r ( __name : * const libc :: c_char , __proto : * const libc :: c_char , __result_buf : * mut servent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut servent ) -> libc :: c_int ; } extern "C" { pub fn getservbyport_r ( __port : libc :: c_int , __proto : * const libc :: c_char , __result_buf : * mut servent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut servent ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct protoent { pub p_name : * mut libc :: c_char , pub p_aliases : * mut * mut libc :: c_char , pub p_proto : libc :: c_int , } impl Default for protoent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn setprotoent ( __stay_open : libc :: c_int ) ; } extern "C" { pub fn endprotoent ( ) ; } extern "C" { pub fn getprotoent ( ) -> * mut protoent ; } extern "C" { pub fn getprotobyname ( __name : * const libc :: c_char ) -> * mut protoent ; } extern "C" { pub fn getprotobynumber ( __proto : libc :: c_int ) -> * mut protoent ; } extern "C" { pub fn getprotoent_r ( __result_buf : * mut protoent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> libc :: c_int ; } extern "C" { pub fn getprotobyname_r ( __name : * const libc :: c_char , __result_buf : * mut protoent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> libc :: c_int ; } extern "C" { pub fn getprotobynumber_r ( __proto : libc :: c_int , __result_buf : * mut protoent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> libc :: c_int ; } extern "C" { pub fn setnetgrent ( __netgroup : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn endnetgrent ( ) ; } extern "C" { pub fn getnetgrent ( __hostp : * mut * mut libc :: c_char , __userp : * mut * mut libc :: c_char , __domainp : * mut * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn innetgr ( __netgroup : * const libc :: c_char , __host : * const libc :: c_char , __user : * const libc :: c_char , __domain : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getnetgrent_r ( __hostp : * mut * mut libc :: c_char , __userp : * mut * mut libc :: c_char , __domainp : * mut * mut libc :: c_char , __buffer : * mut libc :: c_char , __buflen : usize ) -> libc :: c_int ; } extern "C" { pub fn rcmd ( __ahost : * mut * mut libc :: c_char , __rport : libc :: c_ushort , __locuser : * const libc :: c_char , __remuser : * const libc :: c_char , __cmd : * const libc :: c_char , __fd2p : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn rcmd_af ( __ahost : * mut * mut libc :: c_char , __rport : libc :: c_ushort , __locuser : * const libc :: c_char , __remuser : * const libc :: c_char , __cmd : * const libc :: c_char , __fd2p : * mut libc :: c_int , __af : sa_family_t ) -> libc :: c_int ; } extern "C" { pub fn rexec ( __ahost : * mut * mut libc :: c_char , __rport : libc :: c_int , __name : * const libc :: c_char , __pass : * const libc :: c_char , __cmd : * const libc :: c_char , __fd2p : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn rexec_af ( __ahost : * mut * mut libc :: c_char , __rport : libc :: c_int , __name : * const libc :: c_char , __pass : * const libc :: c_char , __cmd : * const libc :: c_char , __fd2p : * mut libc :: c_int , __af : sa_family_t ) -> libc :: c_int ; } extern "C" { pub fn ruserok ( __rhost : * const libc :: c_char , __suser : libc :: c_int , __remuser : * const libc :: c_char , __locuser : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn ruserok_af ( __rhost : * const libc :: c_char , __suser : libc :: c_int , __remuser : * const libc :: c_char , __locuser : * const libc :: c_char , __af : sa_family_t ) -> libc :: c_int ; } extern "C" { pub fn iruserok ( __raddr : u32 , __suser : libc :: c_int , __remuser : * const libc :: c_char , __locuser : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn iruserok_af ( __raddr : * const libc :: c_void , __suser : libc :: c_int , __remuser : * const libc :: c_char , __locuser : * const libc :: c_char , __af : sa_family_t ) -> libc :: c_int ; } extern "C" { pub fn rresvport ( __alport : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn rresvport_af ( __alport : * mut libc :: c_int , __af : sa_family_t ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct addrinfo { pub ai_flags : libc :: c_int , pub ai_family : libc :: c_int , pub ai_socktype : libc :: c_int , pub ai_protocol : libc :: c_int , pub ai_addrlen : socklen_t , pub ai_addr : * mut sockaddr , pub ai_canonname : * mut libc :: c_char , pub ai_next : * mut addrinfo , } impl Default for addrinfo { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn getaddrinfo ( __name : * const libc :: c_char , __service : * const libc :: c_char , __req : * const addrinfo , __pai : * mut * mut addrinfo ) -> libc :: c_int ; } extern "C" { pub fn freeaddrinfo ( __ai : * mut addrinfo ) ; } extern "C" { pub fn gai_strerror ( __ecode : libc :: c_int ) -> * const libc :: c_char ; } extern "C" { pub fn getnameinfo ( __sa : * const sockaddr , __salen : socklen_t , __host : * mut libc :: c_char , __hostlen : socklen_t , __serv : * mut libc :: c_char , __servlen : socklen_t , __flags : libc :: c_int ) -> libc :: c_int ; } pub type nfds_t = libc :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct pollfd { pub fd : libc :: c_int , pub events : libc :: c_short , pub revents : libc :: c_short , } extern "C" { pub fn poll ( __fds : * mut pollfd , __nfds : nfds_t , __timeout : libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sched_param { pub sched_priority : libc :: c_int , } pub type __cpu_mask = libc :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct cpu_set_t { pub __bits : [ __cpu_mask ; 16usize ] , } extern "C" { pub fn __sched_cpucount ( __setsize : usize , __setp : * const cpu_set_t ) -> libc :: c_int ; } extern "C" { pub fn __sched_cpualloc ( __count : usize ) -> * mut cpu_set_t ; } extern "C" { pub fn __sched_cpufree ( __set : * mut cpu_set_t ) ; } extern "C" { pub fn sched_setparam ( __pid : __pid_t , __param : * const sched_param ) -> libc :: c_int ; } extern "C" { pub fn sched_getparam ( __pid : __pid_t , __param : * mut sched_param ) -> libc :: c_int ; } extern "C" { pub fn sched_setscheduler ( __pid : __pid_t , __policy : libc :: c_int , __param : * const sched_param ) -> libc :: c_int ; } extern "C" { pub fn sched_getscheduler ( __pid : __pid_t ) -> libc :: c_int ; } extern "C" { pub fn sched_yield ( ) -> libc :: c_int ; } extern "C" { pub fn sched_get_priority_max ( __algorithm : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sched_get_priority_min ( __algorithm : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sched_rr_get_interval ( __pid : __pid_t , __t : * mut timespec ) -> libc :: c_int ; } pub type __jmp_buf = [ libc :: c_long ; 8usize ] ; pub const PTHREAD_CREATE_JOINABLE : _bindgen_ty_9 = 0 ; pub const PTHREAD_CREATE_DETACHED : _bindgen_ty_9 = 1 ; pub type _bindgen_ty_9 = u32 ; pub const PTHREAD_MUTEX_TIMED_NP : _bindgen_ty_10 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE_NP : _bindgen_ty_10 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK_NP : _bindgen_ty_10 = 2 ; pub const PTHREAD_MUTEX_ADAPTIVE_NP : _bindgen_ty_10 = 3 ; pub const PTHREAD_MUTEX_NORMAL : _bindgen_ty_10 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE : _bindgen_ty_10 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK : _bindgen_ty_10 = 2 ; pub const PTHREAD_MUTEX_DEFAULT : _bindgen_ty_10 = 0 ; pub type _bindgen_ty_10 = u32 ; pub const PTHREAD_MUTEX_STALLED : _bindgen_ty_11 = 0 ; pub const PTHREAD_MUTEX_STALLED_NP : _bindgen_ty_11 = 0 ; pub const PTHREAD_MUTEX_ROBUST : _bindgen_ty_11 = 1 ; pub const PTHREAD_MUTEX_ROBUST_NP : _bindgen_ty_11 = 1 ; pub type _bindgen_ty_11 = u32 ; pub const PTHREAD_PRIO_NONE : _bindgen_ty_12 = 0 ; pub const PTHREAD_PRIO_INHERIT : _bindgen_ty_12 = 1 ; pub const PTHREAD_PRIO_PROTECT : _bindgen_ty_12 = 2 ; pub type _bindgen_ty_12 = u32 ; pub const PTHREAD_RWLOCK_PREFER_READER_NP : _bindgen_ty_13 = 0 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NP : _bindgen_ty_13 = 1 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP : _bindgen_ty_13 = 2 ; pub const PTHREAD_RWLOCK_DEFAULT_NP : _bindgen_ty_13 = 0 ; pub type _bindgen_ty_13 = u32 ; pub const PTHREAD_INHERIT_SCHED : _bindgen_ty_14 = 0 ; pub const PTHREAD_EXPLICIT_SCHED : _bindgen_ty_14 = 1 ; pub type _bindgen_ty_14 = u32 ; pub const PTHREAD_SCOPE_SYSTEM : _bindgen_ty_15 = 0 ; pub const PTHREAD_SCOPE_PROCESS : _bindgen_ty_15 = 1 ; pub type _bindgen_ty_15 = u32 ; pub const PTHREAD_PROCESS_PRIVATE : _bindgen_ty_16 = 0 ; pub const PTHREAD_PROCESS_SHARED : _bindgen_ty_16 = 1 ; pub type _bindgen_ty_16 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _pthread_cleanup_buffer { pub __routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) > , pub __arg : * mut libc :: c_void , pub __canceltype : libc :: c_int , pub __prev : * mut _pthread_cleanup_buffer , } impl Default for _pthread_cleanup_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const PTHREAD_CANCEL_ENABLE : _bindgen_ty_17 = 0 ; pub const PTHREAD_CANCEL_DISABLE : _bindgen_ty_17 = 1 ; pub type _bindgen_ty_17 = u32 ; pub const PTHREAD_CANCEL_DEFERRED : _bindgen_ty_18 = 0 ; pub const PTHREAD_CANCEL_ASYNCHRONOUS : _bindgen_ty_18 = 1 ; pub type _bindgen_ty_18 = u32 ; extern "C" { pub fn pthread_create ( __newthread : * mut pthread_t , __attr : * const pthread_attr_t , __start_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) -> * mut libc :: c_void > , __arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_exit ( __retval : * mut libc :: c_void ) ; } extern "C" { pub fn pthread_join ( __th : pthread_t , __thread_return : * mut * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_detach ( __th : pthread_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_self ( ) -> pthread_t ; } extern "C" { pub fn pthread_equal ( __thread1 : pthread_t , __thread2 : pthread_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_init ( __attr : * mut pthread_attr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_destroy ( __attr : * mut pthread_attr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getdetachstate ( __attr : * const pthread_attr_t , __detachstate : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setdetachstate ( __attr : * mut pthread_attr_t , __detachstate : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getguardsize ( __attr : * const pthread_attr_t , __guardsize : * mut usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setguardsize ( __attr : * mut pthread_attr_t , __guardsize : usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getschedparam ( __attr : * const pthread_attr_t , __param : * mut sched_param ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setschedparam ( __attr : * mut pthread_attr_t , __param : * const sched_param ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getschedpolicy ( __attr : * const pthread_attr_t , __policy : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setschedpolicy ( __attr : * mut pthread_attr_t , __policy : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getinheritsched ( __attr : * const pthread_attr_t , __inherit : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setinheritsched ( __attr : * mut pthread_attr_t , __inherit : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getscope ( __attr : * const pthread_attr_t , __scope : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setscope ( __attr : * mut pthread_attr_t , __scope : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getstackaddr ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setstackaddr ( __attr : * mut pthread_attr_t , __stackaddr : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getstacksize ( __attr : * const pthread_attr_t , __stacksize : * mut usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setstacksize ( __attr : * mut pthread_attr_t , __stacksize : usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getstack ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut libc :: c_void , __stacksize : * mut usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setstack ( __attr : * mut pthread_attr_t , __stackaddr : * mut libc :: c_void , __stacksize : usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_setschedparam ( __target_thread : pthread_t , __policy : libc :: c_int , __param : * const sched_param ) -> libc :: c_int ; } extern "C" { pub fn pthread_getschedparam ( __target_thread : pthread_t , __policy : * mut libc :: c_int , __param : * mut sched_param ) -> libc :: c_int ; } extern "C" { pub fn pthread_setschedprio ( __target_thread : pthread_t , __prio : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_once ( __once_control : * mut pthread_once_t , __init_routine : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> libc :: c_int ; } extern "C" { pub fn pthread_setcancelstate ( __state : libc :: c_int , __oldstate : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_setcanceltype ( __type : libc :: c_int , __oldtype : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_cancel ( __th : pthread_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_testcancel ( ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_unwind_buf_t { pub __cancel_jmp_buf : [ __pthread_unwind_buf_t__bindgen_ty_1 ; 1usize ] , pub __pad : [ * mut libc :: c_void ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_unwind_buf_t__bindgen_ty_1 { pub __cancel_jmp_buf : __jmp_buf , pub __mask_was_saved : libc :: c_int , } impl Default for __pthread_unwind_buf_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cleanup_frame { pub __cancel_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) > , pub __cancel_arg : * mut libc :: c_void , pub __do_it : libc :: c_int , pub __cancel_type : libc :: c_int , } impl Default for __pthread_cleanup_frame { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn __pthread_register_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { pub fn __pthread_unregister_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { pub fn __pthread_unwind_next ( __buf : * mut __pthread_unwind_buf_t ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __jmp_buf_tag { _unused : [ u8 ; 0 ] , } extern "C" { pub fn __sigsetjmp ( __env : * mut __jmp_buf_tag , __savemask : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_init ( __mutex : * mut pthread_mutex_t , __mutexattr : * const pthread_mutexattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_destroy ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_trylock ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_lock ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_timedlock ( __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_unlock ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_getprioceiling ( __mutex : * const pthread_mutex_t , __prioceiling : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_setprioceiling ( __mutex : * mut pthread_mutex_t , __prioceiling : libc :: c_int , __old_ceiling : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_consistent ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_init ( __attr : * mut pthread_mutexattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_destroy ( __attr : * mut pthread_mutexattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_getpshared ( __attr : * const pthread_mutexattr_t , __pshared : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_setpshared ( __attr : * mut pthread_mutexattr_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_gettype ( __attr : * const pthread_mutexattr_t , __kind : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_settype ( __attr : * mut pthread_mutexattr_t , __kind : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_getprotocol ( __attr : * const pthread_mutexattr_t , __protocol : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_setprotocol ( __attr : * mut pthread_mutexattr_t , __protocol : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_getprioceiling ( __attr : * const pthread_mutexattr_t , __prioceiling : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_setprioceiling ( __attr : * mut pthread_mutexattr_t , __prioceiling : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_getrobust ( __attr : * const pthread_mutexattr_t , __robustness : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_setrobust ( __attr : * mut pthread_mutexattr_t , __robustness : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_init ( __rwlock : * mut pthread_rwlock_t , __attr : * const pthread_rwlockattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_destroy ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_rdlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_tryrdlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_timedrdlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_wrlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_trywrlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_timedwrlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_unlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_init ( __attr : * mut pthread_rwlockattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_destroy ( __attr : * mut pthread_rwlockattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_getpshared ( __attr : * const pthread_rwlockattr_t , __pshared : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_setpshared ( __attr : * mut pthread_rwlockattr_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_getkind_np ( __attr : * const pthread_rwlockattr_t , __pref : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_setkind_np ( __attr : * mut pthread_rwlockattr_t , __pref : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_init ( __cond : * mut pthread_cond_t , __cond_attr : * const pthread_condattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_destroy ( __cond : * mut pthread_cond_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_signal ( __cond : * mut pthread_cond_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_broadcast ( __cond : * mut pthread_cond_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_wait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_timedwait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_init ( __attr : * mut pthread_condattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_destroy ( __attr : * mut pthread_condattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_getpshared ( __attr : * const pthread_condattr_t , __pshared : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_setpshared ( __attr : * mut pthread_condattr_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_getclock ( __attr : * const pthread_condattr_t , __clock_id : * mut __clockid_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_setclock ( __attr : * mut pthread_condattr_t , __clock_id : __clockid_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_init ( __lock : * mut pthread_spinlock_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_destroy ( __lock : * mut pthread_spinlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_lock ( __lock : * mut pthread_spinlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_trylock ( __lock : * mut pthread_spinlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_unlock ( __lock : * mut pthread_spinlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrier_init ( __barrier : * mut pthread_barrier_t , __attr : * const pthread_barrierattr_t , __count : libc :: c_uint ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrier_destroy ( __barrier : * mut pthread_barrier_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrier_wait ( __barrier : * mut pthread_barrier_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrierattr_init ( __attr : * mut pthread_barrierattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrierattr_destroy ( __attr : * mut pthread_barrierattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrierattr_getpshared ( __attr : * const pthread_barrierattr_t , __pshared : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrierattr_setpshared ( __attr : * mut pthread_barrierattr_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_key_create ( __key : * mut pthread_key_t , __destr_function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) > ) -> libc :: c_int ; } extern "C" { pub fn pthread_key_delete ( __key : pthread_key_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_getspecific ( __key : pthread_key_t ) -> * mut libc :: c_void ; } extern "C" { pub fn pthread_setspecific ( __key : pthread_key_t , __pointer : * const libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_getcpuclockid ( __thread_id : pthread_t , __clock_id : * mut __clockid_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_atfork ( __prepare : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __parent : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __child : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sem_t { pub __size : [ libc :: c_char ; 32usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } impl Default for sem_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sem_init ( __sem : * mut sem_t , __pshared : libc :: c_int , __value : libc :: c_uint ) -> libc :: c_int ; } extern "C" { pub fn sem_destroy ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_open ( __name : * const libc :: c_char , __oflag : libc :: c_int , ... ) -> * mut sem_t ; } extern "C" { pub fn sem_close ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_unlink ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn sem_wait ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_timedwait ( __sem : * mut sem_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn sem_trywait ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_post ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_getvalue ( __sem : * mut sem_t , __sval : * mut libc :: c_int ) -> libc :: c_int ; } pub type sig_atomic_t = __sig_atomic_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigval { pub sival_int : libc :: c_int , pub sival_ptr : * mut libc :: c_void , _bindgen_union_align : u64 , } impl Default for sigval { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __sigval_t = sigval ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t { pub si_signo : libc :: c_int , pub si_errno : libc :: c_int , pub si_code : libc :: c_int , pub __pad0 : libc :: c_int , pub _sifields : siginfo_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union siginfo_t__bindgen_ty_1 { pub _pad : [ libc :: c_int ; 28usize ] , pub _kill : siginfo_t__bindgen_ty_1__bindgen_ty_1 , pub _timer : siginfo_t__bindgen_ty_1__bindgen_ty_2 , pub _rt : siginfo_t__bindgen_ty_1__bindgen_ty_3 , pub _sigchld : siginfo_t__bindgen_ty_1__bindgen_ty_4 , pub _sigfault : siginfo_t__bindgen_ty_1__bindgen_ty_5 , pub _sigpoll : siginfo_t__bindgen_ty_1__bindgen_ty_6 , pub _sigsys : siginfo_t__bindgen_ty_1__bindgen_ty_7 , _bindgen_union_align : [ u64 ; 14usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 { pub si_pid : __pid_t , pub si_uid : __uid_t , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 { pub si_tid : libc :: c_int , pub si_overrun : libc :: c_int , pub si_sigval : __sigval_t , } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_sigval : __sigval_t , } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_status : libc :: c_int , pub si_utime : __clock_t , pub si_stime : __clock_t , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 { pub si_addr : * mut libc :: c_void , pub si_addr_lsb : libc :: c_short , pub _bounds : siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 { pub _addr_bnd : siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , pub _pkey : __uint32_t , _bindgen_union_align : [ u64 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 { pub _lower : * mut libc :: c_void , pub _upper : * mut libc :: c_void , } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 { pub si_band : libc :: c_long , pub si_fd : libc :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 { pub _call_addr : * mut libc :: c_void , pub _syscall : libc :: c_int , pub _arch : libc :: c_uint , } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for siginfo_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for siginfo_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const SI_ASYNCNL : _bindgen_ty_19 = -60 ; pub const SI_TKILL : _bindgen_ty_19 = -6 ; pub const SI_SIGIO : _bindgen_ty_19 = -5 ; pub const SI_ASYNCIO : _bindgen_ty_19 = -4 ; pub const SI_MESGQ : _bindgen_ty_19 = -3 ; pub const SI_TIMER : _bindgen_ty_19 = -2 ; pub const SI_QUEUE : _bindgen_ty_19 = -1 ; pub const SI_USER : _bindgen_ty_19 = 0 ; pub const SI_KERNEL : _bindgen_ty_19 = 128 ; pub type _bindgen_ty_19 = i32 ; pub const ILL_ILLOPC : _bindgen_ty_20 = 1 ; pub const ILL_ILLOPN : _bindgen_ty_20 = 2 ; pub const ILL_ILLADR : _bindgen_ty_20 = 3 ; pub const ILL_ILLTRP : _bindgen_ty_20 = 4 ; pub const ILL_PRVOPC : _bindgen_ty_20 = 5 ; pub const ILL_PRVREG : _bindgen_ty_20 = 6 ; pub const ILL_COPROC : _bindgen_ty_20 = 7 ; pub const ILL_BADSTK : _bindgen_ty_20 = 8 ; pub type _bindgen_ty_20 = u32 ; pub const FPE_INTDIV : _bindgen_ty_21 = 1 ; pub const FPE_INTOVF : _bindgen_ty_21 = 2 ; pub const FPE_FLTDIV : _bindgen_ty_21 = 3 ; pub const FPE_FLTOVF : _bindgen_ty_21 = 4 ; pub const FPE_FLTUND : _bindgen_ty_21 = 5 ; pub const FPE_FLTRES : _bindgen_ty_21 = 6 ; pub const FPE_FLTINV : _bindgen_ty_21 = 7 ; pub const FPE_FLTSUB : _bindgen_ty_21 = 8 ; pub type _bindgen_ty_21 = u32 ; pub const SEGV_MAPERR : _bindgen_ty_22 = 1 ; pub const SEGV_ACCERR : _bindgen_ty_22 = 2 ; pub const SEGV_BNDERR : _bindgen_ty_22 = 3 ; pub const SEGV_PKUERR : _bindgen_ty_22 = 4 ; pub type _bindgen_ty_22 = u32 ; pub const BUS_ADRALN : _bindgen_ty_23 = 1 ; pub const BUS_ADRERR : _bindgen_ty_23 = 2 ; pub const BUS_OBJERR : _bindgen_ty_23 = 3 ; pub const BUS_MCEERR_AR : _bindgen_ty_23 = 4 ; pub const BUS_MCEERR_AO : _bindgen_ty_23 = 5 ; pub type _bindgen_ty_23 = u32 ; pub const CLD_EXITED : _bindgen_ty_24 = 1 ; pub const CLD_KILLED : _bindgen_ty_24 = 2 ; pub const CLD_DUMPED : _bindgen_ty_24 = 3 ; pub const CLD_TRAPPED : _bindgen_ty_24 = 4 ; pub const CLD_STOPPED : _bindgen_ty_24 = 5 ; pub const CLD_CONTINUED : _bindgen_ty_24 = 6 ; pub type _bindgen_ty_24 = u32 ; pub const POLL_IN : _bindgen_ty_25 = 1 ; pub const POLL_OUT : _bindgen_ty_25 = 2 ; pub const POLL_MSG : _bindgen_ty_25 = 3 ; pub const POLL_ERR : _bindgen_ty_25 = 4 ; pub const POLL_PRI : _bindgen_ty_25 = 5 ; pub const POLL_HUP : _bindgen_ty_25 = 6 ; pub type _bindgen_ty_25 = u32 ; pub type sigval_t = __sigval_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigevent { pub sigev_value : __sigval_t , pub sigev_signo : libc :: c_int , pub sigev_notify : libc :: c_int , pub _sigev_un : sigevent__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigevent__bindgen_ty_1 { pub _pad : [ libc :: c_int ; 12usize ] , pub _tid : __pid_t , pub _sigev_thread : sigevent__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigevent__bindgen_ty_1__bindgen_ty_1 { pub _function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : __sigval_t ) > , pub _attribute : * mut pthread_attr_t , } impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for sigevent__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for sigevent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type sigevent_t = sigevent ; pub const SIGEV_SIGNAL : _bindgen_ty_26 = 0 ; pub const SIGEV_NONE : _bindgen_ty_26 = 1 ; pub const SIGEV_THREAD : _bindgen_ty_26 = 2 ; pub const SIGEV_THREAD_ID : _bindgen_ty_26 = 4 ; pub type _bindgen_ty_26 = u32 ; pub type __sighandler_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : libc :: c_int ) > ; extern "C" { pub fn __sysv_signal ( __sig : libc :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { pub fn signal ( __sig : libc :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { pub fn kill ( __pid : __pid_t , __sig : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn killpg ( __pgrp : __pid_t , __sig : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn raise ( __sig : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ssignal ( __sig : libc :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { pub fn gsignal ( __sig : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn psignal ( __sig : libc :: c_int , __s : * const libc :: c_char ) ; } extern "C" { pub fn psiginfo ( __pinfo : * const siginfo_t , __s : * const libc :: c_char ) ; } extern "C" { pub fn sigblock ( __mask : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sigsetmask ( __mask : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn siggetmask ( ) -> libc :: c_int ; } pub type sig_t = __sighandler_t ; extern "C" { pub fn sigemptyset ( __set : * mut sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigfillset ( __set : * mut sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigaddset ( __set : * mut sigset_t , __signo : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sigdelset ( __set : * mut sigset_t , __signo : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sigismember ( __set : * const sigset_t , __signo : libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigaction { pub __sigaction_handler : sigaction__bindgen_ty_1 , pub sa_mask : __sigset_t , pub sa_flags : libc :: c_int , pub sa_restorer : :: std :: option :: Option < unsafe extern "C" fn ( ) > , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigaction__bindgen_ty_1 { pub sa_handler : __sighandler_t , pub sa_sigaction : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : libc :: c_int , arg2 : * mut siginfo_t , arg3 : * mut libc :: c_void ) > , _bindgen_union_align : u64 , } impl Default for sigaction__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for sigaction { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sigprocmask ( __how : libc :: c_int , __set : * const sigset_t , __oset : * mut sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigsuspend ( __set : * const sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigaction ( __sig : libc :: c_int , __act : * const sigaction , __oact : * mut sigaction ) -> libc :: c_int ; } extern "C" { pub fn sigpending ( __set : * mut sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigwait ( __set : * const sigset_t , __sig : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sigwaitinfo ( __set : * const sigset_t , __info : * mut siginfo_t ) -> libc :: c_int ; } extern "C" { pub fn sigtimedwait ( __set : * const sigset_t , __info : * mut siginfo_t , __timeout : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn sigqueue ( __pid : __pid_t , __sig : libc :: c_int , __val : sigval ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpx_sw_bytes { pub magic1 : __uint32_t , pub extended_size : __uint32_t , pub xstate_bv : __uint64_t , pub xstate_size : __uint32_t , pub __glibc_reserved1 : [ __uint32_t ; 7usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpreg { pub significand : [ libc :: c_ushort ; 4usize ] , pub exponent : libc :: c_ushort , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpxreg { pub significand : [ libc :: c_ushort ; 4usize ] , pub exponent : libc :: c_ushort , pub __glibc_reserved1 : [ libc :: c_ushort ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _fpxreg ; 8usize ] , pub _xmm : [ _xmmreg ; 16usize ] , pub __glibc_reserved1 : [ __uint32_t ; 24usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigcontext { pub r8 : __uint64_t , pub r9 : __uint64_t , pub r10 : __uint64_t , pub r11 : __uint64_t , pub r12 : __uint64_t , pub r13 : __uint64_t , pub r14 : __uint64_t , pub r15 : __uint64_t , pub rdi : __uint64_t , pub rsi : __uint64_t , pub rbp : __uint64_t , pub rbx : __uint64_t , pub rdx : __uint64_t , pub rax : __uint64_t , pub rcx : __uint64_t , pub rsp : __uint64_t , pub rip : __uint64_t , pub eflags : __uint64_t , pub cs : libc :: c_ushort , pub gs : libc :: c_ushort , pub fs : libc :: c_ushort , pub __pad0 : libc :: c_ushort , pub err : __uint64_t , pub trapno : __uint64_t , pub oldmask : __uint64_t , pub cr2 : __uint64_t , pub __bindgen_anon_1 : sigcontext__bindgen_ty_1 , pub __reserved1 : [ __uint64_t ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigcontext__bindgen_ty_1 { pub fpstate : * mut _fpstate , pub __fpstate_word : __uint64_t , _bindgen_union_align : u64 , } impl Default for sigcontext__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for sigcontext { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _xsave_hdr { pub xstate_bv : __uint64_t , pub __glibc_reserved1 : [ __uint64_t ; 2usize ] , pub __glibc_reserved2 : [ __uint64_t ; 5usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _ymmh_state { pub ymmh_space : [ __uint32_t ; 64usize ] , } impl Default for _ymmh_state { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _xstate { pub fpstate : _fpstate , pub xstate_hdr : _xsave_hdr , pub ymmh : _ymmh_state , } impl Default for _xstate { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sigreturn ( __scp : * mut sigcontext ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct stack_t { pub ss_sp : * mut libc :: c_void , pub ss_flags : libc :: c_int , pub ss_size : usize , } impl Default for stack_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type greg_t = libc :: c_longlong ; pub type gregset_t = [ greg_t ; 23usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_fpxreg { pub significand : [ libc :: c_ushort ; 4usize ] , pub exponent : libc :: c_ushort , pub __glibc_reserved1 : [ libc :: c_ushort ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _libc_fpxreg ; 8usize ] , pub _xmm : [ _libc_xmmreg ; 16usize ] , pub __glibc_reserved1 : [ __uint32_t ; 24usize ] , } pub type fpregset_t = * mut _libc_fpstate ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mcontext_t { pub gregs : gregset_t , pub fpregs : fpregset_t , pub __reserved1 : [ libc :: c_ulonglong ; 8usize ] , } impl Default for mcontext_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ucontext_t { pub uc_flags : libc :: c_ulong , pub uc_link : * mut ucontext_t , pub uc_stack : stack_t , pub uc_mcontext : mcontext_t , pub uc_sigmask : sigset_t , pub __fpregs_mem : _libc_fpstate , } impl Default for ucontext_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn siginterrupt ( __sig : libc :: c_int , __interrupt : libc :: c_int ) -> libc :: c_int ; } pub const SS_ONSTACK : _bindgen_ty_27 = 1 ; pub const SS_DISABLE : _bindgen_ty_27 = 2 ; pub type _bindgen_ty_27 = u32 ; extern "C" { pub fn sigaltstack ( __ss : * const stack_t , __oss : * mut stack_t ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigstack { pub ss_sp : * mut libc :: c_void , pub ss_onstack : libc :: c_int , } impl Default for sigstack { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sigstack ( __ss : * mut sigstack , __oss : * mut sigstack ) -> libc :: c_int ; } extern "C" { pub fn pthread_sigmask ( __how : libc :: c_int , __newmask : * const __sigset_t , __oldmask : * mut __sigset_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_kill ( __threadid : pthread_t , __signo : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn __libc_current_sigrtmin ( ) -> libc :: c_int ; } extern "C" { pub fn __libc_current_sigrtmax ( ) -> libc :: c_int ; } extern "C" { pub fn closelog ( ) ; } extern "C" { pub fn openlog ( __ident : * const libc :: c_char , __option : libc :: c_int , __facility : libc :: c_int ) ; } extern "C" { pub fn setlogmask ( __mask : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn syslog ( __pri : libc :: c_int , __fmt : * const libc :: c_char , ... ) ; } extern "C" { pub fn vsyslog ( __pri : libc :: c_int , __fmt : * const libc :: c_char , __ap : * mut __va_list_tag ) ; } pub type cc_t = libc :: c_uchar ; pub type speed_t = libc :: c_uint ; pub type tcflag_t = libc :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct termios { pub c_iflag : tcflag_t , pub c_oflag : tcflag_t , pub c_cflag : tcflag_t , pub c_lflag : tcflag_t , pub c_line : cc_t , pub c_cc : [ cc_t ; 32usize ] , pub c_ispeed : speed_t , pub c_ospeed : speed_t , } extern "C" { pub fn cfgetospeed ( __termios_p : * const termios ) -> speed_t ; } extern "C" { pub fn cfgetispeed ( __termios_p : * const termios ) -> speed_t ; } extern "C" { pub fn cfsetospeed ( __termios_p : * mut termios , __speed : speed_t ) -> libc :: c_int ; } extern "C" { pub fn cfsetispeed ( __termios_p : * mut termios , __speed : speed_t ) -> libc :: c_int ; } extern "C" { pub fn cfsetspeed ( __termios_p : * mut termios , __speed : speed_t ) -> libc :: c_int ; } extern "C" { pub fn tcgetattr ( __fd : libc :: c_int , __termios_p : * mut termios ) -> libc :: c_int ; } extern "C" { pub fn tcsetattr ( __fd : libc :: c_int , __optional_actions : libc :: c_int , __termios_p : * const termios ) -> libc :: c_int ; } extern "C" { pub fn cfmakeraw ( __termios_p : * mut termios ) ; } extern "C" { pub fn tcsendbreak ( __fd : libc :: c_int , __duration : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tcdrain ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tcflush ( __fd : libc :: c_int , __queue_selector : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tcflow ( __fd : libc :: c_int , __action : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tcgetsid ( __fd : libc :: c_int ) -> __pid_t ; } pub type useconds_t = __useconds_t ; extern "C" { pub fn access ( __name : * const libc :: c_char , __type : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn faccessat ( __fd : libc :: c_int , __file : * const libc :: c_char , __type : libc :: c_int , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn lseek ( __fd : libc :: c_int , __offset : __off_t , __whence : libc :: c_int ) -> __off_t ; } extern "C" { pub fn close ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn read ( __fd : libc :: c_int , __buf : * mut libc :: c_void , __nbytes : usize ) -> isize ; } extern "C" { pub fn write ( __fd : libc :: c_int , __buf : * const libc :: c_void , __n : usize ) -> isize ; } extern "C" { pub fn pread ( __fd : libc :: c_int , __buf : * mut libc :: c_void , __nbytes : usize , __offset : __off_t ) -> isize ; } extern "C" { pub fn pwrite ( __fd : libc :: c_int , __buf : * const libc :: c_void , __n : usize , __offset : __off_t ) -> isize ; } extern "C" { pub fn pipe ( __pipedes : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn alarm ( __seconds : libc :: c_uint ) -> libc :: c_uint ; } extern "C" { pub fn sleep ( __seconds : libc :: c_uint ) -> libc :: c_uint ; } extern "C" { pub fn ualarm ( __value : __useconds_t , __interval : __useconds_t ) -> __useconds_t ; } extern "C" { pub fn usleep ( __useconds : __useconds_t ) -> libc :: c_int ; } extern "C" { pub fn pause ( ) -> libc :: c_int ; } extern "C" { pub fn chown ( __file : * const libc :: c_char , __owner : __uid_t , __group : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn fchown ( __fd : libc :: c_int , __owner : __uid_t , __group : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn lchown ( __file : * const libc :: c_char , __owner : __uid_t , __group : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn fchownat ( __fd : libc :: c_int , __file : * const libc :: c_char , __owner : __uid_t , __group : __gid_t , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn chdir ( __path : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn fchdir ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getcwd ( __buf : * mut libc :: c_char , __size : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn getwd ( __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn dup ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn dup2 ( __fd : libc :: c_int , __fd2 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn execve ( __path : * const libc :: c_char , __argv : * const * mut libc :: c_char , __envp : * const * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn fexecve ( __fd : libc :: c_int , __argv : * const * mut libc :: c_char , __envp : * const * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn execv ( __path : * const libc :: c_char , __argv : * const * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn execle ( __path : * const libc :: c_char , __arg : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn execl ( __path : * const libc :: c_char , __arg : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn execvp ( __file : * const libc :: c_char , __argv : * const * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn execlp ( __file : * const libc :: c_char , __arg : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn nice ( __inc : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _exit ( __status : libc :: c_int ) ; } pub const _PC_LINK_MAX : _bindgen_ty_28 = 0 ; pub const _PC_MAX_CANON : _bindgen_ty_28 = 1 ; pub const _PC_MAX_INPUT : _bindgen_ty_28 = 2 ; pub const _PC_NAME_MAX : _bindgen_ty_28 = 3 ; pub const _PC_PATH_MAX : _bindgen_ty_28 = 4 ; pub const _PC_PIPE_BUF : _bindgen_ty_28 = 5 ; pub const _PC_CHOWN_RESTRICTED : _bindgen_ty_28 = 6 ; pub const _PC_NO_TRUNC : _bindgen_ty_28 = 7 ; pub const _PC_VDISABLE : _bindgen_ty_28 = 8 ; pub const _PC_SYNC_IO : _bindgen_ty_28 = 9 ; pub const _PC_ASYNC_IO : _bindgen_ty_28 = 10 ; pub const _PC_PRIO_IO : _bindgen_ty_28 = 11 ; pub const _PC_SOCK_MAXBUF : _bindgen_ty_28 = 12 ; pub const _PC_FILESIZEBITS : _bindgen_ty_28 = 13 ; pub const _PC_REC_INCR_XFER_SIZE : _bindgen_ty_28 = 14 ; pub const _PC_REC_MAX_XFER_SIZE : _bindgen_ty_28 = 15 ; pub const _PC_REC_MIN_XFER_SIZE : _bindgen_ty_28 = 16 ; pub const _PC_REC_XFER_ALIGN : _bindgen_ty_28 = 17 ; pub const _PC_ALLOC_SIZE_MIN : _bindgen_ty_28 = 18 ; pub const _PC_SYMLINK_MAX : _bindgen_ty_28 = 19 ; pub const _PC_2_SYMLINKS : _bindgen_ty_28 = 20 ; pub type _bindgen_ty_28 = u32 ; pub const _SC_ARG_MAX : _bindgen_ty_29 = 0 ; pub const _SC_CHILD_MAX : _bindgen_ty_29 = 1 ; pub const _SC_CLK_TCK : _bindgen_ty_29 = 2 ; pub const _SC_NGROUPS_MAX : _bindgen_ty_29 = 3 ; pub const _SC_OPEN_MAX : _bindgen_ty_29 = 4 ; pub const _SC_STREAM_MAX : _bindgen_ty_29 = 5 ; pub const _SC_TZNAME_MAX : _bindgen_ty_29 = 6 ; pub const _SC_JOB_CONTROL : _bindgen_ty_29 = 7 ; pub const _SC_SAVED_IDS : _bindgen_ty_29 = 8 ; pub const _SC_REALTIME_SIGNALS : _bindgen_ty_29 = 9 ; pub const _SC_PRIORITY_SCHEDULING : _bindgen_ty_29 = 10 ; pub const _SC_TIMERS : _bindgen_ty_29 = 11 ; pub const _SC_ASYNCHRONOUS_IO : _bindgen_ty_29 = 12 ; pub const _SC_PRIORITIZED_IO : _bindgen_ty_29 = 13 ; pub const _SC_SYNCHRONIZED_IO : _bindgen_ty_29 = 14 ; pub const _SC_FSYNC : _bindgen_ty_29 = 15 ; pub const _SC_MAPPED_FILES : _bindgen_ty_29 = 16 ; pub const _SC_MEMLOCK : _bindgen_ty_29 = 17 ; pub const _SC_MEMLOCK_RANGE : _bindgen_ty_29 = 18 ; pub const _SC_MEMORY_PROTECTION : _bindgen_ty_29 = 19 ; pub const _SC_MESSAGE_PASSING : _bindgen_ty_29 = 20 ; pub const _SC_SEMAPHORES : _bindgen_ty_29 = 21 ; pub const _SC_SHARED_MEMORY_OBJECTS : _bindgen_ty_29 = 22 ; pub const _SC_AIO_LISTIO_MAX : _bindgen_ty_29 = 23 ; pub const _SC_AIO_MAX : _bindgen_ty_29 = 24 ; pub const _SC_AIO_PRIO_DELTA_MAX : _bindgen_ty_29 = 25 ; pub const _SC_DELAYTIMER_MAX : _bindgen_ty_29 = 26 ; pub const _SC_MQ_OPEN_MAX : _bindgen_ty_29 = 27 ; pub const _SC_MQ_PRIO_MAX : _bindgen_ty_29 = 28 ; pub const _SC_VERSION : _bindgen_ty_29 = 29 ; pub const _SC_PAGESIZE : _bindgen_ty_29 = 30 ; pub const _SC_RTSIG_MAX : _bindgen_ty_29 = 31 ; pub const _SC_SEM_NSEMS_MAX : _bindgen_ty_29 = 32 ; pub const _SC_SEM_VALUE_MAX : _bindgen_ty_29 = 33 ; pub const _SC_SIGQUEUE_MAX : _bindgen_ty_29 = 34 ; pub const _SC_TIMER_MAX : _bindgen_ty_29 = 35 ; pub const _SC_BC_BASE_MAX : _bindgen_ty_29 = 36 ; pub const _SC_BC_DIM_MAX : _bindgen_ty_29 = 37 ; pub const _SC_BC_SCALE_MAX : _bindgen_ty_29 = 38 ; pub const _SC_BC_STRING_MAX : _bindgen_ty_29 = 39 ; pub const _SC_COLL_WEIGHTS_MAX : _bindgen_ty_29 = 40 ; pub const _SC_EQUIV_CLASS_MAX : _bindgen_ty_29 = 41 ; pub const _SC_EXPR_NEST_MAX : _bindgen_ty_29 = 42 ; pub const _SC_LINE_MAX : _bindgen_ty_29 = 43 ; pub const _SC_RE_DUP_MAX : _bindgen_ty_29 = 44 ; pub const _SC_CHARCLASS_NAME_MAX : _bindgen_ty_29 = 45 ; pub const _SC_2_VERSION : _bindgen_ty_29 = 46 ; pub const _SC_2_C_BIND : _bindgen_ty_29 = 47 ; pub const _SC_2_C_DEV : _bindgen_ty_29 = 48 ; pub const _SC_2_FORT_DEV : _bindgen_ty_29 = 49 ; pub const _SC_2_FORT_RUN : _bindgen_ty_29 = 50 ; pub const _SC_2_SW_DEV : _bindgen_ty_29 = 51 ; pub const _SC_2_LOCALEDEF : _bindgen_ty_29 = 52 ; pub const _SC_PII : _bindgen_ty_29 = 53 ; pub const _SC_PII_XTI : _bindgen_ty_29 = 54 ; pub const _SC_PII_SOCKET : _bindgen_ty_29 = 55 ; pub const _SC_PII_INTERNET : _bindgen_ty_29 = 56 ; pub const _SC_PII_OSI : _bindgen_ty_29 = 57 ; pub const _SC_POLL : _bindgen_ty_29 = 58 ; pub const _SC_SELECT : _bindgen_ty_29 = 59 ; pub const _SC_UIO_MAXIOV : _bindgen_ty_29 = 60 ; pub const _SC_IOV_MAX : _bindgen_ty_29 = 60 ; pub const _SC_PII_INTERNET_STREAM : _bindgen_ty_29 = 61 ; pub const _SC_PII_INTERNET_DGRAM : _bindgen_ty_29 = 62 ; pub const _SC_PII_OSI_COTS : _bindgen_ty_29 = 63 ; pub const _SC_PII_OSI_CLTS : _bindgen_ty_29 = 64 ; pub const _SC_PII_OSI_M : _bindgen_ty_29 = 65 ; pub const _SC_T_IOV_MAX : _bindgen_ty_29 = 66 ; pub const _SC_THREADS : _bindgen_ty_29 = 67 ; pub const _SC_THREAD_SAFE_FUNCTIONS : _bindgen_ty_29 = 68 ; pub const _SC_GETGR_R_SIZE_MAX : _bindgen_ty_29 = 69 ; pub const _SC_GETPW_R_SIZE_MAX : _bindgen_ty_29 = 70 ; pub const _SC_LOGIN_NAME_MAX : _bindgen_ty_29 = 71 ; pub const _SC_TTY_NAME_MAX : _bindgen_ty_29 = 72 ; pub const _SC_THREAD_DESTRUCTOR_ITERATIONS : _bindgen_ty_29 = 73 ; pub const _SC_THREAD_KEYS_MAX : _bindgen_ty_29 = 74 ; pub const _SC_THREAD_STACK_MIN : _bindgen_ty_29 = 75 ; pub const _SC_THREAD_THREADS_MAX : _bindgen_ty_29 = 76 ; pub const _SC_THREAD_ATTR_STACKADDR : _bindgen_ty_29 = 77 ; pub const _SC_THREAD_ATTR_STACKSIZE : _bindgen_ty_29 = 78 ; pub const _SC_THREAD_PRIORITY_SCHEDULING : _bindgen_ty_29 = 79 ; pub const _SC_THREAD_PRIO_INHERIT : _bindgen_ty_29 = 80 ; pub const _SC_THREAD_PRIO_PROTECT : _bindgen_ty_29 = 81 ; pub const _SC_THREAD_PROCESS_SHARED : _bindgen_ty_29 = 82 ; pub const _SC_NPROCESSORS_CONF : _bindgen_ty_29 = 83 ; pub const _SC_NPROCESSORS_ONLN : _bindgen_ty_29 = 84 ; pub const _SC_PHYS_PAGES : _bindgen_ty_29 = 85 ; pub const _SC_AVPHYS_PAGES : _bindgen_ty_29 = 86 ; pub const _SC_ATEXIT_MAX : _bindgen_ty_29 = 87 ; pub const _SC_PASS_MAX : _bindgen_ty_29 = 88 ; pub const _SC_XOPEN_VERSION : _bindgen_ty_29 = 89 ; pub const _SC_XOPEN_XCU_VERSION : _bindgen_ty_29 = 90 ; pub const _SC_XOPEN_UNIX : _bindgen_ty_29 = 91 ; pub const _SC_XOPEN_CRYPT : _bindgen_ty_29 = 92 ; pub const _SC_XOPEN_ENH_I18N : _bindgen_ty_29 = 93 ; pub const _SC_XOPEN_SHM : _bindgen_ty_29 = 94 ; pub const _SC_2_CHAR_TERM : _bindgen_ty_29 = 95 ; pub const _SC_2_C_VERSION : _bindgen_ty_29 = 96 ; pub const _SC_2_UPE : _bindgen_ty_29 = 97 ; pub const _SC_XOPEN_XPG2 : _bindgen_ty_29 = 98 ; pub const _SC_XOPEN_XPG3 : _bindgen_ty_29 = 99 ; pub const _SC_XOPEN_XPG4 : _bindgen_ty_29 = 100 ; pub const _SC_CHAR_BIT : _bindgen_ty_29 = 101 ; pub const _SC_CHAR_MAX : _bindgen_ty_29 = 102 ; pub const _SC_CHAR_MIN : _bindgen_ty_29 = 103 ; pub const _SC_INT_MAX : _bindgen_ty_29 = 104 ; pub const _SC_INT_MIN : _bindgen_ty_29 = 105 ; pub const _SC_LONG_BIT : _bindgen_ty_29 = 106 ; pub const _SC_WORD_BIT : _bindgen_ty_29 = 107 ; pub const _SC_MB_LEN_MAX : _bindgen_ty_29 = 108 ; pub const _SC_NZERO : _bindgen_ty_29 = 109 ; pub const _SC_SSIZE_MAX : _bindgen_ty_29 = 110 ; pub const _SC_SCHAR_MAX : _bindgen_ty_29 = 111 ; pub const _SC_SCHAR_MIN : _bindgen_ty_29 = 112 ; pub const _SC_SHRT_MAX : _bindgen_ty_29 = 113 ; pub const _SC_SHRT_MIN : _bindgen_ty_29 = 114 ; pub const _SC_UCHAR_MAX : _bindgen_ty_29 = 115 ; pub const _SC_UINT_MAX : _bindgen_ty_29 = 116 ; pub const _SC_ULONG_MAX : _bindgen_ty_29 = 117 ; pub const _SC_USHRT_MAX : _bindgen_ty_29 = 118 ; pub const _SC_NL_ARGMAX : _bindgen_ty_29 = 119 ; pub const _SC_NL_LANGMAX : _bindgen_ty_29 = 120 ; pub const _SC_NL_MSGMAX : _bindgen_ty_29 = 121 ; pub const _SC_NL_NMAX : _bindgen_ty_29 = 122 ; pub const _SC_NL_SETMAX : _bindgen_ty_29 = 123 ; pub const _SC_NL_TEXTMAX : _bindgen_ty_29 = 124 ; pub const _SC_XBS5_ILP32_OFF32 : _bindgen_ty_29 = 125 ; pub const _SC_XBS5_ILP32_OFFBIG : _bindgen_ty_29 = 126 ; pub const _SC_XBS5_LP64_OFF64 : _bindgen_ty_29 = 127 ; pub const _SC_XBS5_LPBIG_OFFBIG : _bindgen_ty_29 = 128 ; pub const _SC_XOPEN_LEGACY : _bindgen_ty_29 = 129 ; pub const _SC_XOPEN_REALTIME : _bindgen_ty_29 = 130 ; pub const _SC_XOPEN_REALTIME_THREADS : _bindgen_ty_29 = 131 ; pub const _SC_ADVISORY_INFO : _bindgen_ty_29 = 132 ; pub const _SC_BARRIERS : _bindgen_ty_29 = 133 ; pub const _SC_BASE : _bindgen_ty_29 = 134 ; pub const _SC_C_LANG_SUPPORT : _bindgen_ty_29 = 135 ; pub const _SC_C_LANG_SUPPORT_R : _bindgen_ty_29 = 136 ; pub const _SC_CLOCK_SELECTION : _bindgen_ty_29 = 137 ; pub const _SC_CPUTIME : _bindgen_ty_29 = 138 ; pub const _SC_THREAD_CPUTIME : _bindgen_ty_29 = 139 ; pub const _SC_DEVICE_IO : _bindgen_ty_29 = 140 ; pub const _SC_DEVICE_SPECIFIC : _bindgen_ty_29 = 141 ; pub const _SC_DEVICE_SPECIFIC_R : _bindgen_ty_29 = 142 ; pub const _SC_FD_MGMT : _bindgen_ty_29 = 143 ; pub const _SC_FIFO : _bindgen_ty_29 = 144 ; pub const _SC_PIPE : _bindgen_ty_29 = 145 ; pub const _SC_FILE_ATTRIBUTES : _bindgen_ty_29 = 146 ; pub const _SC_FILE_LOCKING : _bindgen_ty_29 = 147 ; pub const _SC_FILE_SYSTEM : _bindgen_ty_29 = 148 ; pub const _SC_MONOTONIC_CLOCK : _bindgen_ty_29 = 149 ; pub const _SC_MULTI_PROCESS : _bindgen_ty_29 = 150 ; pub const _SC_SINGLE_PROCESS : _bindgen_ty_29 = 151 ; pub const _SC_NETWORKING : _bindgen_ty_29 = 152 ; pub const _SC_READER_WRITER_LOCKS : _bindgen_ty_29 = 153 ; pub const _SC_SPIN_LOCKS : _bindgen_ty_29 = 154 ; pub const _SC_REGEXP : _bindgen_ty_29 = 155 ; pub const _SC_REGEX_VERSION : _bindgen_ty_29 = 156 ; pub const _SC_SHELL : _bindgen_ty_29 = 157 ; pub const _SC_SIGNALS : _bindgen_ty_29 = 158 ; pub const _SC_SPAWN : _bindgen_ty_29 = 159 ; pub const _SC_SPORADIC_SERVER : _bindgen_ty_29 = 160 ; pub const _SC_THREAD_SPORADIC_SERVER : _bindgen_ty_29 = 161 ; pub const _SC_SYSTEM_DATABASE : _bindgen_ty_29 = 162 ; pub const _SC_SYSTEM_DATABASE_R : _bindgen_ty_29 = 163 ; pub const _SC_TIMEOUTS : _bindgen_ty_29 = 164 ; pub const _SC_TYPED_MEMORY_OBJECTS : _bindgen_ty_29 = 165 ; pub const _SC_USER_GROUPS : _bindgen_ty_29 = 166 ; pub const _SC_USER_GROUPS_R : _bindgen_ty_29 = 167 ; pub const _SC_2_PBS : _bindgen_ty_29 = 168 ; pub const _SC_2_PBS_ACCOUNTING : _bindgen_ty_29 = 169 ; pub const _SC_2_PBS_LOCATE : _bindgen_ty_29 = 170 ; pub const _SC_2_PBS_MESSAGE : _bindgen_ty_29 = 171 ; pub const _SC_2_PBS_TRACK : _bindgen_ty_29 = 172 ; pub const _SC_SYMLOOP_MAX : _bindgen_ty_29 = 173 ; pub const _SC_STREAMS : _bindgen_ty_29 = 174 ; pub const _SC_2_PBS_CHECKPOINT : _bindgen_ty_29 = 175 ; pub const _SC_V6_ILP32_OFF32 : _bindgen_ty_29 = 176 ; pub const _SC_V6_ILP32_OFFBIG : _bindgen_ty_29 = 177 ; pub const _SC_V6_LP64_OFF64 : _bindgen_ty_29 = 178 ; pub const _SC_V6_LPBIG_OFFBIG : _bindgen_ty_29 = 179 ; pub const _SC_HOST_NAME_MAX : _bindgen_ty_29 = 180 ; pub const _SC_TRACE : _bindgen_ty_29 = 181 ; pub const _SC_TRACE_EVENT_FILTER : _bindgen_ty_29 = 182 ; pub const _SC_TRACE_INHERIT : _bindgen_ty_29 = 183 ; pub const _SC_TRACE_LOG : _bindgen_ty_29 = 184 ; pub const _SC_LEVEL1_ICACHE_SIZE : _bindgen_ty_29 = 185 ; pub const _SC_LEVEL1_ICACHE_ASSOC : _bindgen_ty_29 = 186 ; pub const _SC_LEVEL1_ICACHE_LINESIZE : _bindgen_ty_29 = 187 ; pub const _SC_LEVEL1_DCACHE_SIZE : _bindgen_ty_29 = 188 ; pub const _SC_LEVEL1_DCACHE_ASSOC : _bindgen_ty_29 = 189 ; pub const _SC_LEVEL1_DCACHE_LINESIZE : _bindgen_ty_29 = 190 ; pub const _SC_LEVEL2_CACHE_SIZE : _bindgen_ty_29 = 191 ; pub const _SC_LEVEL2_CACHE_ASSOC : _bindgen_ty_29 = 192 ; pub const _SC_LEVEL2_CACHE_LINESIZE : _bindgen_ty_29 = 193 ; pub const _SC_LEVEL3_CACHE_SIZE : _bindgen_ty_29 = 194 ; pub const _SC_LEVEL3_CACHE_ASSOC : _bindgen_ty_29 = 195 ; pub const _SC_LEVEL3_CACHE_LINESIZE : _bindgen_ty_29 = 196 ; pub const _SC_LEVEL4_CACHE_SIZE : _bindgen_ty_29 = 197 ; pub const _SC_LEVEL4_CACHE_ASSOC : _bindgen_ty_29 = 198 ; pub const _SC_LEVEL4_CACHE_LINESIZE : _bindgen_ty_29 = 199 ; pub const _SC_IPV6 : _bindgen_ty_29 = 235 ; pub const _SC_RAW_SOCKETS : _bindgen_ty_29 = 236 ; pub const _SC_V7_ILP32_OFF32 : _bindgen_ty_29 = 237 ; pub const _SC_V7_ILP32_OFFBIG : _bindgen_ty_29 = 238 ; pub const _SC_V7_LP64_OFF64 : _bindgen_ty_29 = 239 ; pub const _SC_V7_LPBIG_OFFBIG : _bindgen_ty_29 = 240 ; pub const _SC_SS_REPL_MAX : _bindgen_ty_29 = 241 ; pub const _SC_TRACE_EVENT_NAME_MAX : _bindgen_ty_29 = 242 ; pub const _SC_TRACE_NAME_MAX : _bindgen_ty_29 = 243 ; pub const _SC_TRACE_SYS_MAX : _bindgen_ty_29 = 244 ; pub const _SC_TRACE_USER_EVENT_MAX : _bindgen_ty_29 = 245 ; pub const _SC_XOPEN_STREAMS : _bindgen_ty_29 = 246 ; pub const _SC_THREAD_ROBUST_PRIO_INHERIT : _bindgen_ty_29 = 247 ; pub const _SC_THREAD_ROBUST_PRIO_PROTECT : _bindgen_ty_29 = 248 ; pub type _bindgen_ty_29 = u32 ; pub const _CS_PATH : _bindgen_ty_30 = 0 ; pub const _CS_V6_WIDTH_RESTRICTED_ENVS : _bindgen_ty_30 = 1 ; pub const _CS_GNU_LIBC_VERSION : _bindgen_ty_30 = 2 ; pub const _CS_GNU_LIBPTHREAD_VERSION : _bindgen_ty_30 = 3 ; pub const _CS_V5_WIDTH_RESTRICTED_ENVS : _bindgen_ty_30 = 4 ; pub const _CS_V7_WIDTH_RESTRICTED_ENVS : _bindgen_ty_30 = 5 ; pub const _CS_LFS_CFLAGS : _bindgen_ty_30 = 1000 ; pub const _CS_LFS_LDFLAGS : _bindgen_ty_30 = 1001 ; pub const _CS_LFS_LIBS : _bindgen_ty_30 = 1002 ; pub const _CS_LFS_LINTFLAGS : _bindgen_ty_30 = 1003 ; pub const _CS_LFS64_CFLAGS : _bindgen_ty_30 = 1004 ; pub const _CS_LFS64_LDFLAGS : _bindgen_ty_30 = 1005 ; pub const _CS_LFS64_LIBS : _bindgen_ty_30 = 1006 ; pub const _CS_LFS64_LINTFLAGS : _bindgen_ty_30 = 1007 ; pub const _CS_XBS5_ILP32_OFF32_CFLAGS : _bindgen_ty_30 = 1100 ; pub const _CS_XBS5_ILP32_OFF32_LDFLAGS : _bindgen_ty_30 = 1101 ; pub const _CS_XBS5_ILP32_OFF32_LIBS : _bindgen_ty_30 = 1102 ; pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS : _bindgen_ty_30 = 1103 ; pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS : _bindgen_ty_30 = 1104 ; pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1105 ; pub const _CS_XBS5_ILP32_OFFBIG_LIBS : _bindgen_ty_30 = 1106 ; pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1107 ; pub const _CS_XBS5_LP64_OFF64_CFLAGS : _bindgen_ty_30 = 1108 ; pub const _CS_XBS5_LP64_OFF64_LDFLAGS : _bindgen_ty_30 = 1109 ; pub const _CS_XBS5_LP64_OFF64_LIBS : _bindgen_ty_30 = 1110 ; pub const _CS_XBS5_LP64_OFF64_LINTFLAGS : _bindgen_ty_30 = 1111 ; pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_30 = 1112 ; pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1113 ; pub const _CS_XBS5_LPBIG_OFFBIG_LIBS : _bindgen_ty_30 = 1114 ; pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1115 ; pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS : _bindgen_ty_30 = 1116 ; pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS : _bindgen_ty_30 = 1117 ; pub const _CS_POSIX_V6_ILP32_OFF32_LIBS : _bindgen_ty_30 = 1118 ; pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS : _bindgen_ty_30 = 1119 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS : _bindgen_ty_30 = 1120 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1121 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS : _bindgen_ty_30 = 1122 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1123 ; pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS : _bindgen_ty_30 = 1124 ; pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS : _bindgen_ty_30 = 1125 ; pub const _CS_POSIX_V6_LP64_OFF64_LIBS : _bindgen_ty_30 = 1126 ; pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS : _bindgen_ty_30 = 1127 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_30 = 1128 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1129 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS : _bindgen_ty_30 = 1130 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1131 ; pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS : _bindgen_ty_30 = 1132 ; pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS : _bindgen_ty_30 = 1133 ; pub const _CS_POSIX_V7_ILP32_OFF32_LIBS : _bindgen_ty_30 = 1134 ; pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS : _bindgen_ty_30 = 1135 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS : _bindgen_ty_30 = 1136 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1137 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS : _bindgen_ty_30 = 1138 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1139 ; pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS : _bindgen_ty_30 = 1140 ; pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS : _bindgen_ty_30 = 1141 ; pub const _CS_POSIX_V7_LP64_OFF64_LIBS : _bindgen_ty_30 = 1142 ; pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS : _bindgen_ty_30 = 1143 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_30 = 1144 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1145 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS : _bindgen_ty_30 = 1146 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1147 ; pub const _CS_V6_ENV : _bindgen_ty_30 = 1148 ; pub const _CS_V7_ENV : _bindgen_ty_30 = 1149 ; pub type _bindgen_ty_30 = u32 ; extern "C" { pub fn pathconf ( __path : * const libc :: c_char , __name : libc :: c_int ) -> libc :: c_long ; } extern "C" { pub fn fpathconf ( __fd : libc :: c_int , __name : libc :: c_int ) -> libc :: c_long ; } extern "C" { pub fn sysconf ( __name : libc :: c_int ) -> libc :: c_long ; } extern "C" { pub fn confstr ( __name : libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> usize ; } extern "C" { pub fn getpid ( ) -> __pid_t ; } extern "C" { pub fn getppid ( ) -> __pid_t ; } extern "C" { pub fn getpgrp ( ) -> __pid_t ; } extern "C" { pub fn __getpgid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { pub fn getpgid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { pub fn setpgid ( __pid : __pid_t , __pgid : __pid_t ) -> libc :: c_int ; } extern "C" { pub fn setpgrp ( ) -> libc :: c_int ; } extern "C" { pub fn setsid ( ) -> __pid_t ; } extern "C" { pub fn getsid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { pub fn getuid ( ) -> __uid_t ; } extern "C" { pub fn geteuid ( ) -> __uid_t ; } extern "C" { pub fn getgid ( ) -> __gid_t ; } extern "C" { pub fn getegid ( ) -> __gid_t ; } extern "C" { pub fn getgroups ( __size : libc :: c_int , __list : * mut __gid_t ) -> libc :: c_int ; } extern "C" { pub fn setuid ( __uid : __uid_t ) -> libc :: c_int ; } extern "C" { pub fn setreuid ( __ruid : __uid_t , __euid : __uid_t ) -> libc :: c_int ; } extern "C" { pub fn seteuid ( __uid : __uid_t ) -> libc :: c_int ; } extern "C" { pub fn setgid ( __gid : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn setregid ( __rgid : __gid_t , __egid : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn setegid ( __gid : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn fork ( ) -> __pid_t ; } extern "C" { pub fn vfork ( ) -> libc :: c_int ; } extern "C" { pub fn ttyname ( __fd : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn ttyname_r ( __fd : libc :: c_int , __buf : * mut libc :: c_char , __buflen : usize ) -> libc :: c_int ; } extern "C" { pub fn isatty ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ttyslot ( ) -> libc :: c_int ; } extern "C" { pub fn link ( __from : * const libc :: c_char , __to : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn linkat ( __fromfd : libc :: c_int , __from : * const libc :: c_char , __tofd : libc :: c_int , __to : * const libc :: c_char , __flags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn symlink ( __from : * const libc :: c_char , __to : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn readlink ( __path : * const libc :: c_char , __buf : * mut libc :: c_char , __len : usize ) -> isize ; } extern "C" { pub fn symlinkat ( __from : * const libc :: c_char , __tofd : libc :: c_int , __to : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn readlinkat ( __fd : libc :: c_int , __path : * const libc :: c_char , __buf : * mut libc :: c_char , __len : usize ) -> isize ; } extern "C" { pub fn unlink ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn unlinkat ( __fd : libc :: c_int , __name : * const libc :: c_char , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn rmdir ( __path : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn tcgetpgrp ( __fd : libc :: c_int ) -> __pid_t ; } extern "C" { pub fn tcsetpgrp ( __fd : libc :: c_int , __pgrp_id : __pid_t ) -> libc :: c_int ; } extern "C" { pub fn getlogin ( ) -> * mut libc :: c_char ; } extern "C" { pub fn getlogin_r ( __name : * mut libc :: c_char , __name_len : usize ) -> libc :: c_int ; } extern "C" { pub fn setlogin ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getopt ( ___argc : libc :: c_int , ___argv : * const * mut libc :: c_char , __shortopts : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn gethostname ( __name : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn sethostname ( __name : * const libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn sethostid ( __id : libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn getdomainname ( __name : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn setdomainname ( __name : * const libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn vhangup ( ) -> libc :: c_int ; } extern "C" { pub fn revoke ( __file : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn profil ( __sample_buffer : * mut libc :: c_ushort , __size : usize , __offset : usize , __scale : libc :: c_uint ) -> libc :: c_int ; } extern "C" { pub fn acct ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getusershell ( ) -> * mut libc :: c_char ; } extern "C" { pub fn endusershell ( ) ; } extern "C" { pub fn setusershell ( ) ; } extern "C" { pub fn daemon ( __nochdir : libc :: c_int , __noclose : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn chroot ( __path : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getpass ( __prompt : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn fsync ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn gethostid ( ) -> libc :: c_long ; } extern "C" { pub fn sync ( ) ; } extern "C" { pub fn getpagesize ( ) -> libc :: c_int ; } extern "C" { pub fn getdtablesize ( ) -> libc :: c_int ; } extern "C" { pub fn truncate ( __file : * const libc :: c_char , __length : __off_t ) -> libc :: c_int ; } extern "C" { pub fn ftruncate ( __fd : libc :: c_int , __length : __off_t ) -> libc :: c_int ; } extern "C" { pub fn brk ( __addr : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn sbrk ( __delta : isize ) -> * mut libc :: c_void ; } extern "C" { pub fn syscall ( __sysno : libc :: c_long , ... ) -> libc :: c_long ; } extern "C" { pub fn fdatasync ( __fildes : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getentropy ( __buffer : * mut libc :: c_void , __length : usize ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct if_nameindex { pub if_index : libc :: c_uint , pub if_name : * mut libc :: c_char , } impl Default for if_nameindex { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const IFF_UP : _bindgen_ty_31 = 1 ; pub const IFF_BROADCAST : _bindgen_ty_31 = 2 ; pub const IFF_DEBUG : _bindgen_ty_31 = 4 ; pub const IFF_LOOPBACK : _bindgen_ty_31 = 8 ; pub const IFF_POINTOPOINT : _bindgen_ty_31 = 16 ; pub const IFF_NOTRAILERS : _bindgen_ty_31 = 32 ; pub const IFF_RUNNING : _bindgen_ty_31 = 64 ; pub const IFF_NOARP : _bindgen_ty_31 = 128 ; pub const IFF_PROMISC : _bindgen_ty_31 = 256 ; pub const IFF_ALLMULTI : _bindgen_ty_31 = 512 ; pub const IFF_MASTER : _bindgen_ty_31 = 1024 ; pub const IFF_SLAVE : _bindgen_ty_31 = 2048 ; pub const IFF_MULTICAST : _bindgen_ty_31 = 4096 ; pub const IFF_PORTSEL : _bindgen_ty_31 = 8192 ; pub const IFF_AUTOMEDIA : _bindgen_ty_31 = 16384 ; pub const IFF_DYNAMIC : _bindgen_ty_31 = 32768 ; pub type _bindgen_ty_31 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifaddr { pub ifa_addr : sockaddr , pub ifa_ifu : ifaddr__bindgen_ty_1 , pub ifa_ifp : * mut iface , pub ifa_next : * mut ifaddr , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifaddr__bindgen_ty_1 { pub ifu_broadaddr : sockaddr , pub ifu_dstaddr : sockaddr , _bindgen_union_align : [ u16 ; 8usize ] , } impl Default for ifaddr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for ifaddr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ifmap { pub mem_start : libc :: c_ulong , pub mem_end : libc :: c_ulong , pub base_addr : libc :: c_ushort , pub irq : libc :: c_uchar , pub dma : libc :: c_uchar , pub port : libc :: c_uchar , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifreq { pub ifr_ifrn : ifreq__bindgen_ty_1 , pub ifr_ifru : ifreq__bindgen_ty_2 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifreq__bindgen_ty_1 { pub ifrn_name : [ libc :: c_char ; 16usize ] , _bindgen_union_align : [ u8 ; 16usize ] , } impl Default for ifreq__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifreq__bindgen_ty_2 { pub ifru_addr : sockaddr , pub ifru_dstaddr : sockaddr , pub ifru_broadaddr : sockaddr , pub ifru_netmask : sockaddr , pub ifru_hwaddr : sockaddr , pub ifru_flags : libc :: c_short , pub ifru_ivalue : libc :: c_int , pub ifru_mtu : libc :: c_int , pub ifru_map : ifmap , pub ifru_slave : [ libc :: c_char ; 16usize ] , pub ifru_newname : [ libc :: c_char ; 16usize ] , pub ifru_data : __caddr_t , _bindgen_union_align : [ u64 ; 3usize ] , } impl Default for ifreq__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for ifreq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifconf { pub ifc_len : libc :: c_int , pub ifc_ifcu : ifconf__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifconf__bindgen_ty_1 { pub ifcu_buf : __caddr_t , pub ifcu_req : * mut ifreq , _bindgen_union_align : u64 , } impl Default for ifconf__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for ifconf { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn if_nametoindex ( __ifname : * const libc :: c_char ) -> libc :: c_uint ; } extern "C" { pub fn if_indextoname ( __ifindex : libc :: c_uint , __ifname : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn if_nameindex ( ) -> * mut if_nameindex ; } extern "C" { pub fn if_freenameindex ( __ptr : * mut if_nameindex ) ; } pub type tcp_seq = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcphdr { pub __bindgen_anon_1 : tcphdr__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union tcphdr__bindgen_ty_1 { pub __bindgen_anon_1 : tcphdr__bindgen_ty_1__bindgen_ty_1 , pub __bindgen_anon_2 : tcphdr__bindgen_ty_1__bindgen_ty_2 , _bindgen_union_align : [ u32 ; 5usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 { pub th_sport : u16 , pub th_dport : u16 , pub th_seq : tcp_seq , pub th_ack : tcp_seq , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub th_flags : u8 , pub th_win : u16 , pub th_sum : u16 , pub th_urp : u16 , } impl tcphdr__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn th_x2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_th_x2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn th_off ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_th_off ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( th_x2 : u8 , th_off : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let th_x2 : u8 = unsafe { :: std :: mem :: transmute ( th_x2 ) } ; th_x2 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let th_off : u8 = unsafe { :: std :: mem :: transmute ( th_off ) } ; th_off as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 { pub source : u16 , pub dest : u16 , pub seq : u32 , pub ack_seq : u32 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub window : u16 , pub check : u16 , pub urg_ptr : u16 , } impl tcphdr__bindgen_ty_1__bindgen_ty_2 { # [ inline ] pub fn res1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_res1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn doff ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_doff ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn fin ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_fin ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn syn ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_syn ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rst ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_rst ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn psh ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_psh ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ack ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ack ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn urg ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_urg ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn res2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_res2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( res1 : u16 , doff : u16 , fin : u16 , syn : u16 , rst : u16 , psh : u16 , ack : u16 , urg : u16 , res2 : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let res1 : u16 = unsafe { :: std :: mem :: transmute ( res1 ) } ; res1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let doff : u16 = unsafe { :: std :: mem :: transmute ( doff ) } ; doff as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let fin : u16 = unsafe { :: std :: mem :: transmute ( fin ) } ; fin as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let syn : u16 = unsafe { :: std :: mem :: transmute ( syn ) } ; syn as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let rst : u16 = unsafe { :: std :: mem :: transmute ( rst ) } ; rst as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let psh : u16 = unsafe { :: std :: mem :: transmute ( psh ) } ; psh as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let ack : u16 = unsafe { :: std :: mem :: transmute ( ack ) } ; ack as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let urg : u16 = unsafe { :: std :: mem :: transmute ( urg ) } ; urg as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let res2 : u16 = unsafe { :: std :: mem :: transmute ( res2 ) } ; res2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for tcphdr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for tcphdr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const TCP_ESTABLISHED : _bindgen_ty_32 = 1 ; pub const TCP_SYN_SENT : _bindgen_ty_32 = 2 ; pub const TCP_SYN_RECV : _bindgen_ty_32 = 3 ; pub const TCP_FIN_WAIT1 : _bindgen_ty_32 = 4 ; pub const TCP_FIN_WAIT2 : _bindgen_ty_32 = 5 ; pub const TCP_TIME_WAIT : _bindgen_ty_32 = 6 ; pub const TCP_CLOSE : _bindgen_ty_32 = 7 ; pub const TCP_CLOSE_WAIT : _bindgen_ty_32 = 8 ; pub const TCP_LAST_ACK : _bindgen_ty_32 = 9 ; pub const TCP_LISTEN : _bindgen_ty_32 = 10 ; pub const TCP_CLOSING : _bindgen_ty_32 = 11 ; pub type _bindgen_ty_32 = u32 ; pub const tcp_ca_state_TCP_CA_Open : tcp_ca_state = 0 ; pub const tcp_ca_state_TCP_CA_Disorder : tcp_ca_state = 1 ; pub const tcp_ca_state_TCP_CA_CWR : tcp_ca_state = 2 ; pub const tcp_ca_state_TCP_CA_Recovery : tcp_ca_state = 3 ; pub const tcp_ca_state_TCP_CA_Loss : tcp_ca_state = 4 ; pub type tcp_ca_state = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_info { pub tcpi_state : u8 , pub tcpi_ca_state : u8 , pub tcpi_retransmits : u8 , pub tcpi_probes : u8 , pub tcpi_backoff : u8 , pub tcpi_options : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub tcpi_rto : u32 , pub tcpi_ato : u32 , pub tcpi_snd_mss : u32 , pub tcpi_rcv_mss : u32 , pub tcpi_unacked : u32 , pub tcpi_sacked : u32 , pub tcpi_lost : u32 , pub tcpi_retrans : u32 , pub tcpi_fackets : u32 , pub tcpi_last_data_sent : u32 , pub tcpi_last_ack_sent : u32 , pub tcpi_last_data_recv : u32 , pub tcpi_last_ack_recv : u32 , pub tcpi_pmtu : u32 , pub tcpi_rcv_ssthresh : u32 , pub tcpi_rtt : u32 , pub tcpi_rttvar : u32 , pub tcpi_snd_ssthresh : u32 , pub tcpi_snd_cwnd : u32 , pub tcpi_advmss : u32 , pub tcpi_reordering : u32 , pub tcpi_rcv_rtt : u32 , pub tcpi_rcv_space : u32 , pub tcpi_total_retrans : u32 , } impl tcp_info { # [ inline ] pub fn tcpi_snd_wscale ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_tcpi_snd_wscale ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn tcpi_rcv_wscale ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_tcpi_rcv_wscale ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tcpi_snd_wscale : u8 , tcpi_rcv_wscale : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let tcpi_snd_wscale : u8 = unsafe { :: std :: mem :: transmute ( tcpi_snd_wscale ) } ; tcpi_snd_wscale as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let tcpi_rcv_wscale : u8 = unsafe { :: std :: mem :: transmute ( tcpi_rcv_wscale ) } ; tcpi_rcv_wscale as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcp_md5sig { pub tcpm_addr : sockaddr_storage , pub tcpm_flags : u8 , pub tcpm_prefixlen : u8 , pub tcpm_keylen : u16 , pub __tcpm_pad : u32 , pub tcpm_key : [ u8 ; 80usize ] , } impl Default for tcp_md5sig { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_repair_opt { pub opt_code : u32 , pub opt_val : u32 , } pub const TCP_NO_QUEUE : _bindgen_ty_33 = 0 ; pub const TCP_RECV_QUEUE : _bindgen_ty_33 = 1 ; pub const TCP_SEND_QUEUE : _bindgen_ty_33 = 2 ; pub const TCP_QUEUES_NR : _bindgen_ty_33 = 3 ; pub type _bindgen_ty_33 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcp_cookie_transactions { pub tcpct_flags : u16 , pub __tcpct_pad1 : u8 , pub tcpct_cookie_desired : u8 , pub tcpct_s_data_desired : u16 , pub tcpct_used : u16 , pub tcpct_value : [ u8 ; 536usize ] , } impl Default for tcp_cookie_transactions { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_repair_window { pub snd_wl1 : u32 , pub snd_wnd : u32 , pub max_window : u32 , pub rcv_wnd : u32 , pub rcv_wup : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct winsize { pub ws_row : libc :: c_ushort , pub ws_col : libc :: c_ushort , pub ws_xpixel : libc :: c_ushort , pub ws_ypixel : libc :: c_ushort , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct termio { pub c_iflag : libc :: c_ushort , pub c_oflag : libc :: c_ushort , pub c_cflag : libc :: c_ushort , pub c_lflag : libc :: c_ushort , pub c_line : libc :: c_uchar , pub c_cc : [ libc :: c_uchar ; 8usize ] , } extern "C" { pub fn ioctl ( __fd : libc :: c_int , __request : libc :: c_ulong , ... ) -> libc :: c_int ; } extern "C" { pub fn mmap ( __addr : * mut libc :: c_void , __len : usize , __prot : libc :: c_int , __flags : libc :: c_int , __fd : libc :: c_int , __offset : __off_t ) -> * mut libc :: c_void ; } extern "C" { pub fn munmap ( __addr : * mut libc :: c_void , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn mprotect ( __addr : * mut libc :: c_void , __len : usize , __prot : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn msync ( __addr : * mut libc :: c_void , __len : usize , __flags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn madvise ( __addr : * mut libc :: c_void , __len : usize , __advice : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn posix_madvise ( __addr : * mut libc :: c_void , __len : usize , __advice : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn mlock ( __addr : * const libc :: c_void , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn munlock ( __addr : * const libc :: c_void , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn mlockall ( __flags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn munlockall ( ) -> libc :: c_int ; } extern "C" { pub fn mincore ( __start : * mut libc :: c_void , __len : usize , __vec : * mut libc :: c_uchar ) -> libc :: c_int ; } extern "C" { pub fn shm_open ( __name : * const libc :: c_char , __oflag : libc :: c_int , __mode : mode_t ) -> libc :: c_int ; } extern "C" { pub fn shm_unlink ( __name : * const libc :: c_char ) -> libc :: c_int ; } pub const __rlimit_resource_RLIMIT_CPU : __rlimit_resource = 0 ; pub const __rlimit_resource_RLIMIT_FSIZE : __rlimit_resource = 1 ; pub const __rlimit_resource_RLIMIT_DATA : __rlimit_resource = 2 ; pub const __rlimit_resource_RLIMIT_STACK : __rlimit_resource = 3 ; pub const __rlimit_resource_RLIMIT_CORE : __rlimit_resource = 4 ; pub const __rlimit_resource___RLIMIT_RSS : __rlimit_resource = 5 ; pub const __rlimit_resource_RLIMIT_NOFILE : __rlimit_resource = 7 ; pub const __rlimit_resource___RLIMIT_OFILE : __rlimit_resource = 7 ; pub const __rlimit_resource_RLIMIT_AS : __rlimit_resource = 9 ; pub const __rlimit_resource___RLIMIT_NPROC : __rlimit_resource = 6 ; pub const __rlimit_resource___RLIMIT_MEMLOCK : __rlimit_resource = 8 ; pub const __rlimit_resource___RLIMIT_LOCKS : __rlimit_resource = 10 ; pub const __rlimit_resource___RLIMIT_SIGPENDING : __rlimit_resource = 11 ; pub const __rlimit_resource___RLIMIT_MSGQUEUE : __rlimit_resource = 12 ; pub const __rlimit_resource___RLIMIT_NICE : __rlimit_resource = 13 ; pub const __rlimit_resource___RLIMIT_RTPRIO : __rlimit_resource = 14 ; pub const __rlimit_resource___RLIMIT_RTTIME : __rlimit_resource = 15 ; pub const __rlimit_resource___RLIMIT_NLIMITS : __rlimit_resource = 16 ; pub const __rlimit_resource___RLIM_NLIMITS : __rlimit_resource = 16 ; pub type __rlimit_resource = u32 ; pub type rlim_t = __rlim_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct rlimit { pub rlim_cur : rlim_t , pub rlim_max : rlim_t , } pub const __rusage_who_RUSAGE_SELF : __rusage_who = 0 ; pub const __rusage_who_RUSAGE_CHILDREN : __rusage_who = -1 ; pub type __rusage_who = i32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct rusage { pub ru_utime : timeval , pub ru_stime : timeval , pub __bindgen_anon_1 : rusage__bindgen_ty_1 , pub __bindgen_anon_2 : rusage__bindgen_ty_2 , pub __bindgen_anon_3 : rusage__bindgen_ty_3 , pub __bindgen_anon_4 : rusage__bindgen_ty_4 , pub __bindgen_anon_5 : rusage__bindgen_ty_5 , pub __bindgen_anon_6 : rusage__bindgen_ty_6 , pub __bindgen_anon_7 : rusage__bindgen_ty_7 , pub __bindgen_anon_8 : rusage__bindgen_ty_8 , pub __bindgen_anon_9 : rusage__bindgen_ty_9 , pub __bindgen_anon_10 : rusage__bindgen_ty_10 , pub __bindgen_anon_11 : rusage__bindgen_ty_11 , pub __bindgen_anon_12 : rusage__bindgen_ty_12 , pub __bindgen_anon_13 : rusage__bindgen_ty_13 , pub __bindgen_anon_14 : rusage__bindgen_ty_14 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_1 { pub ru_maxrss : libc :: c_long , pub __ru_maxrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_2 { pub ru_ixrss : libc :: c_long , pub __ru_ixrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_3 { pub ru_idrss : libc :: c_long , pub __ru_idrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_4 { pub ru_isrss : libc :: c_long , pub __ru_isrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_4 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_5 { pub ru_minflt : libc :: c_long , pub __ru_minflt_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_5 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_6 { pub ru_majflt : libc :: c_long , pub __ru_majflt_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_6 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_7 { pub ru_nswap : libc :: c_long , pub __ru_nswap_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_8 { pub ru_inblock : libc :: c_long , pub __ru_inblock_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_8 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_9 { pub ru_oublock : libc :: c_long , pub __ru_oublock_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_9 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_10 { pub ru_msgsnd : libc :: c_long , pub __ru_msgsnd_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_10 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_11 { pub ru_msgrcv : libc :: c_long , pub __ru_msgrcv_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_11 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_12 { pub ru_nsignals : libc :: c_long , pub __ru_nsignals_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_12 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_13 { pub ru_nvcsw : libc :: c_long , pub __ru_nvcsw_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_13 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_14 { pub ru_nivcsw : libc :: c_long , pub __ru_nivcsw_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_14 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for rusage { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const __priority_which_PRIO_PROCESS : __priority_which = 0 ; pub const __priority_which_PRIO_PGRP : __priority_which = 1 ; pub const __priority_which_PRIO_USER : __priority_which = 2 ; pub type __priority_which = u32 ; pub type __rlimit_resource_t = libc :: c_int ; pub type __rusage_who_t = libc :: c_int ; pub type __priority_which_t = libc :: c_int ; extern "C" { pub fn getrlimit ( __resource : __rlimit_resource_t , __rlimits : * mut rlimit ) -> libc :: c_int ; } extern "C" { pub fn setrlimit ( __resource : __rlimit_resource_t , __rlimits : * const rlimit ) -> libc :: c_int ; } extern "C" { pub fn getrusage ( __who : __rusage_who_t , __usage : * mut rusage ) -> libc :: c_int ; } extern "C" { pub fn getpriority ( __which : __priority_which_t , __who : id_t ) -> libc :: c_int ; } extern "C" { pub fn setpriority ( __which : __priority_which_t , __who : id_t , __prio : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn stat ( __file : * const libc :: c_char , __buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn fstat ( __fd : libc :: c_int , __buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn fstatat ( __fd : libc :: c_int , __file : * const libc :: c_char , __buf : * mut stat , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn lstat ( __file : * const libc :: c_char , __buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn chmod ( __file : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn lchmod ( __file : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn fchmod ( __fd : libc :: c_int , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn fchmodat ( __fd : libc :: c_int , __file : * const libc :: c_char , __mode : __mode_t , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn umask ( __mask : __mode_t ) -> __mode_t ; } extern "C" { pub fn mkdir ( __path : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn mkdirat ( __fd : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn mknod ( __path : * const libc :: c_char , __mode : __mode_t , __dev : __dev_t ) -> libc :: c_int ; } extern "C" { pub fn mknodat ( __fd : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t , __dev : __dev_t ) -> libc :: c_int ; } extern "C" { pub fn mkfifo ( __path : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn mkfifoat ( __fd : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn utimensat ( __fd : libc :: c_int , __path : * const libc :: c_char , __times : * const timespec , __flags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn futimens ( __fd : libc :: c_int , __times : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn __fxstat ( __ver : libc :: c_int , __fildes : libc :: c_int , __stat_buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn __xstat ( __ver : libc :: c_int , __filename : * const libc :: c_char , __stat_buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn __lxstat ( __ver : libc :: c_int , __filename : * const libc :: c_char , __stat_buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn __fxstatat ( __ver : libc :: c_int , __fildes : libc :: c_int , __filename : * const libc :: c_char , __stat_buf : * mut stat , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn __xmknod ( __ver : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t , __dev : * mut __dev_t ) -> libc :: c_int ; } extern "C" { pub fn __xmknodat ( __ver : libc :: c_int , __fd : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t , __dev : * mut __dev_t ) -> libc :: c_int ; } extern "C" { pub fn readv ( __fd : libc :: c_int , __iovec : * const iovec , __count : libc :: c_int ) -> isize ; } extern "C" { pub fn writev ( __fd : libc :: c_int , __iovec : * const iovec , __count : libc :: c_int ) -> isize ; } extern "C" { pub fn preadv ( __fd : libc :: c_int , __iovec : * const iovec , __count : libc :: c_int , __offset : __off_t ) -> isize ; } extern "C" { pub fn pwritev ( __fd : libc :: c_int , __iovec : * const iovec , __count : libc :: c_int , __offset : __off_t ) -> isize ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_un { pub sun_family : sa_family_t , pub sun_path : [ libc :: c_char ; 108usize ] , } impl Default for sockaddr_un { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct user_fpregs_struct { pub cwd : libc :: c_ushort , pub swd : libc :: c_ushort , pub ftw : libc :: c_ushort , pub fop : libc :: c_ushort , pub rip : libc :: c_ulonglong , pub rdp : libc :: c_ulonglong , pub mxcsr : libc :: c_uint , pub mxcr_mask : libc :: c_uint , pub st_space : [ libc :: c_uint ; 32usize ] , pub xmm_space : [ libc :: c_uint ; 64usize ] , pub padding : [ libc :: c_uint ; 24usize ] , } impl Default for user_fpregs_struct { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct user_regs_struct { pub r15 : libc :: c_ulonglong , pub r14 : libc :: c_ulonglong , pub r13 : libc :: c_ulonglong , pub r12 : libc :: c_ulonglong , pub rbp : libc :: c_ulonglong , pub rbx : libc :: c_ulonglong , pub r11 : libc :: c_ulonglong , pub r10 : libc :: c_ulonglong , pub r9 : libc :: c_ulonglong , pub r8 : libc :: c_ulonglong , pub rax : libc :: c_ulonglong , pub rcx : libc :: c_ulonglong , pub rdx : libc :: c_ulonglong , pub rsi : libc :: c_ulonglong , pub rdi : libc :: c_ulonglong , pub orig_rax : libc :: c_ulonglong , pub rip : libc :: c_ulonglong , pub cs : libc :: c_ulonglong , pub eflags : libc :: c_ulonglong , pub rsp : libc :: c_ulonglong , pub ss : libc :: c_ulonglong , pub fs_base : libc :: c_ulonglong , pub gs_base : libc :: c_ulonglong , pub ds : libc :: c_ulonglong , pub es : libc :: c_ulonglong , pub fs : libc :: c_ulonglong , pub gs : libc :: c_ulonglong , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct user { pub regs : user_regs_struct , pub u_fpvalid : libc :: c_int , pub i387 : user_fpregs_struct , pub u_tsize : libc :: c_ulonglong , pub u_dsize : libc :: c_ulonglong , pub u_ssize : libc :: c_ulonglong , pub start_code : libc :: c_ulonglong , pub start_stack : libc :: c_ulonglong , pub signal : libc :: c_longlong , pub reserved : libc :: c_int , pub __bindgen_anon_1 : user__bindgen_ty_1 , pub __bindgen_anon_2 : user__bindgen_ty_2 , pub magic : libc :: c_ulonglong , pub u_comm : [ libc :: c_char ; 32usize ] , pub u_debugreg : [ libc :: c_ulonglong ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union user__bindgen_ty_1 { pub u_ar0 : * mut user_regs_struct , pub __u_ar0_word : libc :: c_ulonglong , _bindgen_union_align : u64 , } impl Default for user__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union user__bindgen_ty_2 { pub u_fpstate : * mut user_fpregs_struct , pub __u_fpstate_word : libc :: c_ulonglong , _bindgen_union_align : u64 , } impl Default for user__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for user { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn wait ( __stat_loc : * mut libc :: c_int ) -> __pid_t ; } extern "C" { pub fn waitpid ( __pid : __pid_t , __stat_loc : * mut libc :: c_int , __options : libc :: c_int ) -> __pid_t ; } extern "C" { pub fn waitid ( __idtype : idtype_t , __id : __id_t , __infop : * mut siginfo_t , __options : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn wait3 ( __stat_loc : * mut libc :: c_int , __options : libc :: c_int , __usage : * mut rusage ) -> __pid_t ; } extern "C" { pub fn wait4 ( __pid : __pid_t , __stat_loc : * mut libc :: c_int , __options : libc :: c_int , __usage : * mut rusage ) -> __pid_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct option { pub name : * const libc :: c_char , pub has_arg : libc :: c_int , pub flag : * mut libc :: c_int , pub val : libc :: c_int , } impl Default for option { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn getopt_long ( ___argc : libc :: c_int , ___argv : * const * mut libc :: c_char , __shortopts : * const libc :: c_char , __longopts : * const option , __longind : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getopt_long_only ( ___argc : libc :: c_int , ___argv : * const * mut libc :: c_char , __shortopts : * const libc :: c_char , __longopts : * const option , __longind : * mut libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_pci_device { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_env_opts { pub name : * const libc :: c_char , pub core_mask : * const libc :: c_char , pub shm_id : libc :: c_int , pub mem_channel : libc :: c_int , pub master_core : libc :: c_int , pub mem_size : libc :: c_int , pub no_pci : bool , pub hugepage_single_segments : bool , pub unlink_hugepage : bool , pub num_pci_addr : usize , pub pci_blacklist : * mut spdk_pci_addr , pub pci_whitelist : * mut spdk_pci_addr , pub env_context : * mut libc :: c_void , } impl Default for spdk_env_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_malloc ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : libc :: c_int , flags : u32 ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_zmalloc ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : libc :: c_int , flags : u32 ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_free ( buf : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_env_opts_init ( opts : * mut spdk_env_opts ) ; } extern "C" { pub fn spdk_env_init ( opts : * const spdk_env_opts ) -> libc :: c_int ; } extern "C" { pub fn spdk_dma_malloc ( size : usize , align : usize , phys_addr : * mut u64 ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_dma_malloc_socket ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : libc :: c_int ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_dma_zmalloc ( size : usize , align : usize , phys_addr : * mut u64 ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_dma_zmalloc_socket ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : libc :: c_int ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_dma_realloc ( buf : * mut libc :: c_void , size : usize , align : usize , phys_addr : * mut u64 ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_dma_free ( buf : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_memzone_reserve ( name : * const libc :: c_char , len : usize , socket_id : libc :: c_int , flags : libc :: c_uint ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_memzone_reserve_aligned ( name : * const libc :: c_char , len : usize , socket_id : libc :: c_int , flags : libc :: c_uint , align : libc :: c_uint ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_memzone_lookup ( name : * const libc :: c_char ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_memzone_free ( name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_memzone_dump ( f : * mut FILE ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_mempool { _unused : [ u8 ; 0 ] , } extern "C" { pub fn spdk_mempool_create ( name : * const libc :: c_char , count : usize , ele_size : usize , cache_size : usize , socket_id : libc :: c_int ) -> * mut spdk_mempool ; } pub type spdk_mempool_obj_cb_t = :: std :: option :: Option < unsafe extern "C" fn ( mp : * mut spdk_mempool , opaque : * mut libc :: c_void , obj : * mut libc :: c_void , obj_idx : libc :: c_uint ) > ; extern "C" { pub fn spdk_mempool_create_ctor ( name : * const libc :: c_char , count : usize , ele_size : usize , cache_size : usize , socket_id : libc :: c_int , obj_init : spdk_mempool_obj_cb_t , obj_init_arg : * mut libc :: c_void ) -> * mut spdk_mempool ; } extern "C" { pub fn spdk_mempool_get_name ( mp : * mut spdk_mempool ) -> * mut libc :: c_char ; } extern "C" { pub fn spdk_mempool_free ( mp : * mut spdk_mempool ) ; } extern "C" { pub fn spdk_mempool_get ( mp : * mut spdk_mempool ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_mempool_get_bulk ( mp : * mut spdk_mempool , ele_arr : * mut * mut libc :: c_void , count : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_mempool_put ( mp : * mut spdk_mempool , ele : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_mempool_put_bulk ( mp : * mut spdk_mempool , ele_arr : * mut * mut libc :: c_void , count : usize ) ; } extern "C" { pub fn spdk_mempool_count ( pool : * const spdk_mempool ) -> usize ; } extern "C" { pub fn spdk_env_get_core_count ( ) -> u32 ; } extern "C" { pub fn spdk_env_get_current_core ( ) -> u32 ; } extern "C" { pub fn spdk_env_get_first_core ( ) -> u32 ; } extern "C" { pub fn spdk_env_get_last_core ( ) -> u32 ; } extern "C" { pub fn spdk_env_get_next_core ( prev_core : u32 ) -> u32 ; } extern "C" { pub fn spdk_env_get_socket_id ( core : u32 ) -> u32 ; } pub type thread_start_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) -> libc :: c_int > ; extern "C" { pub fn spdk_env_thread_launch_pinned ( core : u32 , fn_ : thread_start_fn , arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_env_thread_wait_all ( ) ; } extern "C" { pub fn spdk_process_is_primary ( ) -> bool ; } extern "C" { pub fn spdk_get_ticks ( ) -> u64 ; } extern "C" { pub fn spdk_get_ticks_hz ( ) -> u64 ; } extern "C" { pub fn spdk_delay_us ( us : libc :: c_uint ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_ring { _unused : [ u8 ; 0 ] , } pub const spdk_ring_type_SPDK_RING_TYPE_SP_SC : spdk_ring_type = 0 ; pub const spdk_ring_type_SPDK_RING_TYPE_MP_SC : spdk_ring_type = 1 ; pub const spdk_ring_type_SPDK_RING_TYPE_MP_MC : spdk_ring_type = 2 ; pub type spdk_ring_type = u32 ; extern "C" { pub fn spdk_ring_create ( type_ : spdk_ring_type , count : usize , socket_id : libc :: c_int ) -> * mut spdk_ring ; } extern "C" { pub fn spdk_ring_free ( ring : * mut spdk_ring ) ; } extern "C" { pub fn spdk_ring_count ( ring : * mut spdk_ring ) -> usize ; } extern "C" { pub fn spdk_ring_enqueue ( ring : * mut spdk_ring , objs : * mut * mut libc :: c_void , count : usize ) -> usize ; } extern "C" { pub fn spdk_ring_dequeue ( ring : * mut spdk_ring , objs : * mut * mut libc :: c_void , count : usize ) -> usize ; } extern "C" { pub fn spdk_vtophys ( buf : * mut libc :: c_void ) -> u64 ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_pci_addr { pub domain : u32 , pub bus : u8 , pub dev : u8 , pub func : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_pci_id { pub vendor_id : u16 , pub device_id : u16 , pub subvendor_id : u16 , pub subdevice_id : u16 , } pub type spdk_pci_enum_cb = :: std :: option :: Option < unsafe extern "C" fn ( enum_ctx : * mut libc :: c_void , pci_dev : * mut spdk_pci_device ) -> libc :: c_int > ; extern "C" { pub fn spdk_pci_nvme_enumerate ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_ioat_enumerate ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_virtio_enumerate ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_map_bar ( dev : * mut spdk_pci_device , bar : u32 , mapped_addr : * mut * mut libc :: c_void , phys_addr : * mut u64 , size : * mut u64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_unmap_bar ( dev : * mut spdk_pci_device , bar : u32 , addr : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_get_domain ( dev : * mut spdk_pci_device ) -> u32 ; } extern "C" { pub fn spdk_pci_device_get_bus ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { pub fn spdk_pci_device_get_dev ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { pub fn spdk_pci_device_get_func ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { pub fn spdk_pci_device_get_addr ( dev : * mut spdk_pci_device ) -> spdk_pci_addr ; } extern "C" { pub fn spdk_pci_device_get_vendor_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { pub fn spdk_pci_device_get_device_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { pub fn spdk_pci_device_get_subvendor_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { pub fn spdk_pci_device_get_subdevice_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { pub fn spdk_pci_device_get_id ( dev : * mut spdk_pci_device ) -> spdk_pci_id ; } extern "C" { pub fn spdk_pci_device_get_socket_id ( dev : * mut spdk_pci_device ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_get_serial_number ( dev : * mut spdk_pci_device , sn : * mut libc :: c_char , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_claim ( pci_addr : * const spdk_pci_addr ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_detach ( device : * mut spdk_pci_device ) ; } extern "C" { pub fn spdk_pci_nvme_device_attach ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut libc :: c_void , pci_address : * mut spdk_pci_addr ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_ioat_device_attach ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut libc :: c_void , pci_address : * mut spdk_pci_addr ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_virtio_device_attach ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut libc :: c_void , pci_address : * mut spdk_pci_addr ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_cfg_read ( dev : * mut spdk_pci_device , value : * mut libc :: c_void , len : u32 , offset : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_cfg_write ( dev : * mut spdk_pci_device , value : * mut libc :: c_void , len : u32 , offset : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_cfg_read8 ( dev : * mut spdk_pci_device , value : * mut u8 , offset : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_cfg_write8 ( dev : * mut spdk_pci_device , value : u8 , offset : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_cfg_read16 ( dev : * mut spdk_pci_device , value : * mut u16 , offset : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_cfg_write16 ( dev : * mut spdk_pci_device , value : u16 , offset : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_cfg_read32 ( dev : * mut spdk_pci_device , value : * mut u32 , offset : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_device_cfg_write32 ( dev : * mut spdk_pci_device , value : u32 , offset : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_addr_compare ( a1 : * const spdk_pci_addr , a2 : * const spdk_pci_addr ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_addr_parse ( addr : * mut spdk_pci_addr , bdf : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_pci_addr_fmt ( bdf : * mut libc :: c_char , sz : usize , addr : * const spdk_pci_addr ) -> libc :: c_int ; } extern "C" { pub fn spdk_unaffinitize_thread ( ) ; } extern "C" { pub fn spdk_call_unaffinitized ( cb : :: std :: option :: Option < unsafe extern "C" fn ( arg : * mut libc :: c_void ) -> * mut libc :: c_void > , arg : * mut libc :: c_void ) -> * mut libc :: c_void ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_mem_map { _unused : [ u8 ; 0 ] , } pub const spdk_mem_map_notify_action_SPDK_MEM_MAP_NOTIFY_REGISTER : spdk_mem_map_notify_action = 0 ; pub const spdk_mem_map_notify_action_SPDK_MEM_MAP_NOTIFY_UNREGISTER : spdk_mem_map_notify_action = 1 ; pub type spdk_mem_map_notify_action = u32 ; pub type spdk_mem_map_notify_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , map : * mut spdk_mem_map , action : spdk_mem_map_notify_action , vaddr : * mut libc :: c_void , size : usize ) -> libc :: c_int > ; pub type spdk_mem_map_contiguous_translations = :: std :: option :: Option < unsafe extern "C" fn ( addr_1 : u64 , addr_2 : u64 ) -> libc :: c_int > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_mem_map_ops { pub notify_cb : spdk_mem_map_notify_cb , pub are_contiguous : spdk_mem_map_contiguous_translations , } impl Default for spdk_mem_map_ops { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_mem_map_alloc ( default_translation : u64 , ops : * const spdk_mem_map_ops , cb_ctx : * mut libc :: c_void ) -> * mut spdk_mem_map ; } extern "C" { pub fn spdk_mem_map_free ( pmap : * mut * mut spdk_mem_map ) ; } extern "C" { pub fn spdk_mem_map_set_translation ( map : * mut spdk_mem_map , vaddr : u64 , size : u64 , translation : u64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_mem_map_clear_translation ( map : * mut spdk_mem_map , vaddr : u64 , size : u64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_mem_map_translate ( map : * const spdk_mem_map , vaddr : u64 , size : * mut u64 ) -> u64 ; } extern "C" { pub fn spdk_mem_register ( vaddr : * mut libc :: c_void , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_mem_unregister ( vaddr : * mut libc :: c_void , len : usize ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cap_register { pub raw : u64 , pub bits : spdk_nvme_cap_register__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cap_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_cap_register__bindgen_ty_1 { # [ inline ] pub fn mqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_mqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn cqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ams ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_ams ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 5u8 , val as u64 ) } } # [ inline ] pub fn to ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_to ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn dstrd ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_dstrd ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 4u8 , val as u64 ) } } # [ inline ] pub fn nssrs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 36usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_nssrs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 36usize , 1u8 , val as u64 ) } } # [ inline ] pub fn css ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 37usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_css ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 37usize , 8u8 , val as u64 ) } } # [ inline ] pub fn bps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 45usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 45usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 46usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 46usize , 2u8 , val as u64 ) } } # [ inline ] pub fn mpsmin ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 48usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mpsmin ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 48usize , 4u8 , val as u64 ) } } # [ inline ] pub fn mpsmax ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 52usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mpsmax ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 52usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( mqes : u32 , cqr : u32 , ams : u32 , reserved1 : u32 , to : u32 , dstrd : u32 , nssrs : u32 , css : u32 , bps : u32 , reserved2 : u32 , mpsmin : u32 , mpsmax : u32 , reserved3 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let mqes : u32 = unsafe { :: std :: mem :: transmute ( mqes ) } ; mqes as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let cqr : u32 = unsafe { :: std :: mem :: transmute ( cqr ) } ; cqr as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 2u8 , { let ams : u32 = unsafe { :: std :: mem :: transmute ( ams ) } ; ams as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 5u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let to : u32 = unsafe { :: std :: mem :: transmute ( to ) } ; to as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 4u8 , { let dstrd : u32 = unsafe { :: std :: mem :: transmute ( dstrd ) } ; dstrd as u64 } ) ; __bindgen_bitfield_unit . set ( 36usize , 1u8 , { let nssrs : u32 = unsafe { :: std :: mem :: transmute ( nssrs ) } ; nssrs as u64 } ) ; __bindgen_bitfield_unit . set ( 37usize , 8u8 , { let css : u32 = unsafe { :: std :: mem :: transmute ( css ) } ; css as u64 } ) ; __bindgen_bitfield_unit . set ( 45usize , 1u8 , { let bps : u32 = unsafe { :: std :: mem :: transmute ( bps ) } ; bps as u64 } ) ; __bindgen_bitfield_unit . set ( 46usize , 2u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 48usize , 4u8 , { let mpsmin : u32 = unsafe { :: std :: mem :: transmute ( mpsmin ) } ; mpsmin as u64 } ) ; __bindgen_bitfield_unit . set ( 52usize , 4u8 , { let mpsmax : u32 = unsafe { :: std :: mem :: transmute ( mpsmax ) } ; mpsmax as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 8u8 , { let reserved3 : u32 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_cap_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_cc_css_SPDK_NVME_CC_CSS_NVM : spdk_nvme_cc_css = 0 ; pub type spdk_nvme_cc_css = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cc_register { pub raw : u32 , pub bits : spdk_nvme_cc_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cc_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_cc_register__bindgen_ty_1 { # [ inline ] pub fn en ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_en ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn css ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_css ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn mps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ams ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ams ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 3u8 , val as u64 ) } } # [ inline ] pub fn shn ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_shn ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn iosqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_iosqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn iocqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_iocqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( en : u32 , reserved1 : u32 , css : u32 , mps : u32 , ams : u32 , shn : u32 , iosqes : u32 , iocqes : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let en : u32 = unsafe { :: std :: mem :: transmute ( en ) } ; en as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let css : u32 = unsafe { :: std :: mem :: transmute ( css ) } ; css as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 4u8 , { let mps : u32 = unsafe { :: std :: mem :: transmute ( mps ) } ; mps as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 3u8 , { let ams : u32 = unsafe { :: std :: mem :: transmute ( ams ) } ; ams as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let shn : u32 = unsafe { :: std :: mem :: transmute ( shn ) } ; shn as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let iosqes : u32 = unsafe { :: std :: mem :: transmute ( iosqes ) } ; iosqes as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 4u8 , { let iocqes : u32 = unsafe { :: std :: mem :: transmute ( iocqes ) } ; iocqes as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_cc_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_shn_value_SPDK_NVME_SHN_NORMAL : spdk_nvme_shn_value = 1 ; pub const spdk_nvme_shn_value_SPDK_NVME_SHN_ABRUPT : spdk_nvme_shn_value = 2 ; pub type spdk_nvme_shn_value = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_csts_register { pub raw : u32 , pub bits : spdk_nvme_csts_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_csts_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_csts_register__bindgen_ty_1 { # [ inline ] pub fn rdy ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_rdy ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn cfs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cfs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn shst ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_shst ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn nssro ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_nssro ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_pp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( rdy : u32 , cfs : u32 , shst : u32 , nssro : u32 , pp : u32 , reserved1 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let rdy : u32 = unsafe { :: std :: mem :: transmute ( rdy ) } ; rdy as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let cfs : u32 = unsafe { :: std :: mem :: transmute ( cfs ) } ; cfs as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let shst : u32 = unsafe { :: std :: mem :: transmute ( shst ) } ; shst as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let nssro : u32 = unsafe { :: std :: mem :: transmute ( nssro ) } ; nssro as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let pp : u32 = unsafe { :: std :: mem :: transmute ( pp ) } ; pp as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_csts_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_shst_value_SPDK_NVME_SHST_NORMAL : spdk_nvme_shst_value = 0 ; pub const spdk_nvme_shst_value_SPDK_NVME_SHST_OCCURRING : spdk_nvme_shst_value = 1 ; pub const spdk_nvme_shst_value_SPDK_NVME_SHST_COMPLETE : spdk_nvme_shst_value = 2 ; pub type spdk_nvme_shst_value = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_aqa_register { pub raw : u32 , pub bits : spdk_nvme_aqa_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_aqa_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_aqa_register__bindgen_ty_1 { # [ inline ] pub fn asqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_asqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 12u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn acqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_acqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 12u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( asqs : u32 , reserved1 : u32 , acqs : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 12u8 , { let asqs : u32 = unsafe { :: std :: mem :: transmute ( asqs ) } ; asqs as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 12u8 , { let acqs : u32 = unsafe { :: std :: mem :: transmute ( acqs ) } ; acqs as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 4u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_aqa_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_vs_register { pub raw : u32 , pub bits : spdk_nvme_vs_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_vs_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_vs_register__bindgen_ty_1 { # [ inline ] pub fn ter ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_ter ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mnr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_mnr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mjr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_mjr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ter : u32 , mnr : u32 , mjr : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let ter : u32 = unsafe { :: std :: mem :: transmute ( ter ) } ; ter as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let mnr : u32 = unsafe { :: std :: mem :: transmute ( mnr ) } ; mnr as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let mjr : u32 = unsafe { :: std :: mem :: transmute ( mjr ) } ; mjr as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_vs_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmbloc_register { pub raw : u32 , pub bits : spdk_nvme_cmbloc_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmbloc_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_cmbloc_register__bindgen_ty_1 { # [ inline ] pub fn bir ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_bir ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 9u8 , val as u64 ) } } # [ inline ] pub fn ofst ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_ofst ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bir : u32 , reserved1 : u32 , ofst : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let bir : u32 = unsafe { :: std :: mem :: transmute ( bir ) } ; bir as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 9u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let ofst : u32 = unsafe { :: std :: mem :: transmute ( ofst ) } ; ofst as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_cmbloc_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmbsz_register { pub raw : u32 , pub bits : spdk_nvme_cmbsz_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmbsz_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_cmbsz_register__bindgen_ty_1 { # [ inline ] pub fn sqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn cqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lists ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_lists ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rds ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_rds ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wds ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wds ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn szu ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_szu ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn sz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_sz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( sqs : u32 , cqs : u32 , lists : u32 , rds : u32 , wds : u32 , reserved1 : u32 , szu : u32 , sz : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let sqs : u32 = unsafe { :: std :: mem :: transmute ( sqs ) } ; sqs as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let cqs : u32 = unsafe { :: std :: mem :: transmute ( cqs ) } ; cqs as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let lists : u32 = unsafe { :: std :: mem :: transmute ( lists ) } ; lists as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let rds : u32 = unsafe { :: std :: mem :: transmute ( rds ) } ; rds as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let wds : u32 = unsafe { :: std :: mem :: transmute ( wds ) } ; wds as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let szu : u32 = unsafe { :: std :: mem :: transmute ( szu ) } ; szu as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let sz : u32 = unsafe { :: std :: mem :: transmute ( sz ) } ; sz as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_cmbsz_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_bpinfo_register { pub raw : u32 , pub bits : spdk_nvme_bpinfo_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_bpinfo_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_bpinfo_register__bindgen_ty_1 { # [ inline ] pub fn bpsz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_bpsz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 15u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 9u8 , val as u64 ) } } # [ inline ] pub fn brs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_brs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 5u8 , val as u64 ) } } # [ inline ] pub fn abpid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_abpid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bpsz : u32 , reserved1 : u32 , brs : u32 , reserved2 : u32 , abpid : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 15u8 , { let bpsz : u32 = unsafe { :: std :: mem :: transmute ( bpsz ) } ; bpsz as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 9u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 2u8 , { let brs : u32 = unsafe { :: std :: mem :: transmute ( brs ) } ; brs as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 5u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let abpid : u32 = unsafe { :: std :: mem :: transmute ( abpid ) } ; abpid as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_bpinfo_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_bprsel_register { pub raw : u32 , pub bits : spdk_nvme_bprsel_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_bprsel_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_bprsel_register__bindgen_ty_1 { # [ inline ] pub fn bprsz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_bprsz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 10u8 , val as u64 ) } } # [ inline ] pub fn bprof ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_bprof ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 20u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn bpid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bpid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bprsz : u32 , bprof : u32 , reserved : u32 , bpid : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 10u8 , { let bprsz : u32 = unsafe { :: std :: mem :: transmute ( bprsz ) } ; bprsz as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 20u8 , { let bprof : u32 = unsafe { :: std :: mem :: transmute ( bprof ) } ; bprof as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let bpid : u32 = unsafe { :: std :: mem :: transmute ( bpid ) } ; bpid as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_bprsel_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_registers { pub cap : spdk_nvme_cap_register , pub vs : spdk_nvme_vs_register , pub intms : u32 , pub intmc : u32 , pub cc : spdk_nvme_cc_register , pub reserved1 : u32 , pub csts : spdk_nvme_csts_register , pub nssr : u32 , pub aqa : spdk_nvme_aqa_register , pub asq : u64 , pub acq : u64 , pub cmbloc : spdk_nvme_cmbloc_register , pub cmbsz : spdk_nvme_cmbsz_register , pub bpinfo : spdk_nvme_bpinfo_register , pub bprsel : spdk_nvme_bprsel_register , pub bpmbl : u64 , pub reserved3 : [ u32 ; 1004usize ] , pub doorbell : [ spdk_nvme_registers__bindgen_ty_1 ; 1usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_registers__bindgen_ty_1 { pub sq_tdbl : u32 , pub cq_hdbl : u32 , } impl Default for spdk_nvme_registers { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 0 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_BIT_BUCKET : spdk_nvme_sgl_descriptor_type = 1 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_SEGMENT : spdk_nvme_sgl_descriptor_type = 2 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_LAST_SEGMENT : spdk_nvme_sgl_descriptor_type = 3 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 4 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_TRANSPORT_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 5 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC : spdk_nvme_sgl_descriptor_type = 15 ; pub type spdk_nvme_sgl_descriptor_type = u32 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_ADDRESS : spdk_nvme_sgl_descriptor_subtype = 0 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_OFFSET : spdk_nvme_sgl_descriptor_subtype = 1 ; pub type spdk_nvme_sgl_descriptor_subtype = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor { pub address : u64 , pub __bindgen_anon_1 : spdk_nvme_sgl_descriptor__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_sgl_descriptor__bindgen_ty_1 { pub generic : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 , pub unkeyed : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 , pub keyed : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 { pub reserved : [ u8 ; 7usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn subtype ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( subtype : u8 , type_ : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let subtype : u8 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 { pub length : u32 , pub reserved : [ u8 ; 3usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 { # [ inline ] pub fn subtype ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( subtype : u8 , type_ : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let subtype : u8 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , pub __bindgen_align : [ u64 ; 0usize ] , } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 { # [ inline ] pub fn length ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 24u8 ) as u64 ) } } # [ inline ] pub fn set_length ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 24u8 , val as u64 ) } } # [ inline ] pub fn key ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 32u8 ) as u64 ) } } # [ inline ] pub fn set_key ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 32u8 , val as u64 ) } } # [ inline ] pub fn subtype ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 60usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_type ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 60usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( length : u64 , key : u64 , subtype : u64 , type_ : u64 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 24u8 , { let length : u64 = unsafe { :: std :: mem :: transmute ( length ) } ; length as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 32u8 , { let key : u64 = unsafe { :: std :: mem :: transmute ( key ) } ; key as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 4u8 , { let subtype : u64 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 60usize , 4u8 , { let type_ : u64 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_sgl_descriptor__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_sgl_descriptor { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_PRP : spdk_nvme_psdt_value = 0 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_CONTIG : spdk_nvme_psdt_value = 1 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_SGL : spdk_nvme_psdt_value = 2 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_RESERVED : spdk_nvme_psdt_value = 3 ; pub type spdk_nvme_psdt_value = u32 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_URGENT : spdk_nvme_qprio = 0 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_HIGH : spdk_nvme_qprio = 1 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_MEDIUM : spdk_nvme_qprio = 2 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_LOW : spdk_nvme_qprio = 3 ; pub type spdk_nvme_qprio = u32 ; pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_WRR : spdk_nvme_cap_ams = 1 ; pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_VS : spdk_nvme_cap_ams = 2 ; pub type spdk_nvme_cap_ams = u32 ; pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_RR : spdk_nvme_cc_ams = 0 ; pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_WRR : spdk_nvme_cc_ams = 1 ; pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_VS : spdk_nvme_cc_ams = 7 ; pub type spdk_nvme_cc_ams = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_cmd { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub cid : u16 , pub nsid : u32 , pub rsvd2 : u32 , pub rsvd3 : u32 , pub mptr : u64 , pub dptr : spdk_nvme_cmd__bindgen_ty_1 , pub cdw10 : u32 , pub cdw11 : u32 , pub cdw12 : u32 , pub cdw13 : u32 , pub cdw14 : u32 , pub cdw15 : u32 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmd__bindgen_ty_1 { pub prp : spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 , pub sgl1 : spdk_nvme_sgl_descriptor , _bindgen_union_align : [ u64 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 { pub prp1 : u64 , pub prp2 : u64 , } impl Default for spdk_nvme_cmd__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvme_cmd { # [ inline ] pub fn opc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_opc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn fuse ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_fuse ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn rsvd1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_rsvd1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 4u8 , val as u64 ) } } # [ inline ] pub fn psdt ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_psdt ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opc : u16 , fuse : u16 , rsvd1 : u16 , psdt : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let opc : u16 = unsafe { :: std :: mem :: transmute ( opc ) } ; opc as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let fuse : u16 = unsafe { :: std :: mem :: transmute ( fuse ) } ; fuse as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 4u8 , { let rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( rsvd1 ) } ; rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let psdt : u16 = unsafe { :: std :: mem :: transmute ( psdt ) } ; psdt as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_status { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_status { # [ inline ] pub fn p ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_p ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_sc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 8u8 , val as u64 ) } } # [ inline ] pub fn sct ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_sct ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rsvd2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_rsvd2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn m ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_m ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dnr ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_dnr ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( p : u16 , sc : u16 , sct : u16 , rsvd2 : u16 , m : u16 , dnr : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let p : u16 = unsafe { :: std :: mem :: transmute ( p ) } ; p as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 8u8 , { let sc : u16 = unsafe { :: std :: mem :: transmute ( sc ) } ; sc as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let sct : u16 = unsafe { :: std :: mem :: transmute ( sct ) } ; sct as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let rsvd2 : u16 = unsafe { :: std :: mem :: transmute ( rsvd2 ) } ; rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let m : u16 = unsafe { :: std :: mem :: transmute ( m ) } ; m as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let dnr : u16 = unsafe { :: std :: mem :: transmute ( dnr ) } ; dnr as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cpl { pub cdw0 : u32 , pub rsvd1 : u32 , pub sqhd : u16 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_dsm_range { pub attributes : spdk_nvme_dsm_range__bindgen_ty_1 , pub length : u32 , pub starting_lba : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_dsm_range__bindgen_ty_1 { pub bits : spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 , pub raw : u32 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn af ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_af ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn al ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_al ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved0 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved0 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn sr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 13u8 , val as u64 ) } } # [ inline ] pub fn access_size ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_access_size ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( af : u32 , al : u32 , reserved0 : u32 , sr : u32 , sw : u32 , wp : u32 , reserved1 : u32 , access_size : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let af : u32 = unsafe { :: std :: mem :: transmute ( af ) } ; af as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 2u8 , { let al : u32 = unsafe { :: std :: mem :: transmute ( al ) } ; al as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved0 : u32 = unsafe { :: std :: mem :: transmute ( reserved0 ) } ; reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let sr : u32 = unsafe { :: std :: mem :: transmute ( sr ) } ; sr as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let sw : u32 = unsafe { :: std :: mem :: transmute ( sw ) } ; sw as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let wp : u32 = unsafe { :: std :: mem :: transmute ( wp ) } ; wp as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 13u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let access_size : u32 = unsafe { :: std :: mem :: transmute ( access_size ) } ; access_size as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_dsm_range__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_dsm_range { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_GENERIC : spdk_nvme_status_code_type = 0 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_COMMAND_SPECIFIC : spdk_nvme_status_code_type = 1 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_MEDIA_ERROR : spdk_nvme_status_code_type = 2 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_PATH : spdk_nvme_status_code_type = 3 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_VENDOR_SPECIFIC : spdk_nvme_status_code_type = 7 ; pub type spdk_nvme_status_code_type = u32 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SUCCESS : spdk_nvme_generic_command_status_code = 0 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_OPCODE : spdk_nvme_generic_command_status_code = 1 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_FIELD : spdk_nvme_generic_command_status_code = 2 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_ID_CONFLICT : spdk_nvme_generic_command_status_code = 3 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_TRANSFER_ERROR : spdk_nvme_generic_command_status_code = 4 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_POWER_LOSS : spdk_nvme_generic_command_status_code = 5 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INTERNAL_DEVICE_ERROR : spdk_nvme_generic_command_status_code = 6 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_BY_REQUEST : spdk_nvme_generic_command_status_code = 7 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_SQ_DELETION : spdk_nvme_generic_command_status_code = 8 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_FAILED_FUSED : spdk_nvme_generic_command_status_code = 9 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_MISSING_FUSED : spdk_nvme_generic_command_status_code = 10 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT : spdk_nvme_generic_command_status_code = 11 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR : spdk_nvme_generic_command_status_code = 12 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR : spdk_nvme_generic_command_status_code = 13 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS : spdk_nvme_generic_command_status_code = 14 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID : spdk_nvme_generic_command_status_code = 15 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID : spdk_nvme_generic_command_status_code = 16 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID : spdk_nvme_generic_command_status_code = 17 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF : spdk_nvme_generic_command_status_code = 18 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_PRP_OFFSET : spdk_nvme_generic_command_status_code = 19 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED : spdk_nvme_generic_command_status_code = 20 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_OPERATION_DENIED : spdk_nvme_generic_command_status_code = 21 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_OFFSET : spdk_nvme_generic_command_status_code = 22 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT : spdk_nvme_generic_command_status_code = 24 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_EXPIRED : spdk_nvme_generic_command_status_code = 25 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_INVALID : spdk_nvme_generic_command_status_code = 26 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_PREEMPT : spdk_nvme_generic_command_status_code = 27 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_FAILED : spdk_nvme_generic_command_status_code = 28 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_IN_PROGRESS : spdk_nvme_generic_command_status_code = 29 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID : spdk_nvme_generic_command_status_code = 30 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_INVALID_IN_CMB : spdk_nvme_generic_command_status_code = 31 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_LBA_OUT_OF_RANGE : spdk_nvme_generic_command_status_code = 128 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_CAPACITY_EXCEEDED : spdk_nvme_generic_command_status_code = 129 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_NAMESPACE_NOT_READY : spdk_nvme_generic_command_status_code = 130 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_RESERVATION_CONFLICT : spdk_nvme_generic_command_status_code = 131 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_FORMAT_IN_PROGRESS : spdk_nvme_generic_command_status_code = 132 ; pub type spdk_nvme_generic_command_status_code = u32 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_COMPLETION_QUEUE_INVALID : spdk_nvme_command_specific_status_code = 0 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER : spdk_nvme_command_specific_status_code = 1 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED : spdk_nvme_command_specific_status_code = 2 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED : spdk_nvme_command_specific_status_code = 3 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED : spdk_nvme_command_specific_status_code = 5 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_SLOT : spdk_nvme_command_specific_status_code = 6 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE : spdk_nvme_command_specific_status_code = 7 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR : spdk_nvme_command_specific_status_code = 8 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_LOG_PAGE : spdk_nvme_command_specific_status_code = 9 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FORMAT : spdk_nvme_command_specific_status_code = 10 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET : spdk_nvme_command_specific_status_code = 11 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_DELETION : spdk_nvme_command_specific_status_code = 12 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE : spdk_nvme_command_specific_status_code = 13 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE : spdk_nvme_command_specific_status_code = 14 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC : spdk_nvme_command_specific_status_code = 15 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET : spdk_nvme_command_specific_status_code = 16 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_RESET : spdk_nvme_command_specific_status_code = 17 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION : spdk_nvme_command_specific_status_code = 18 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED : spdk_nvme_command_specific_status_code = 19 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_OVERLAPPING_RANGE : spdk_nvme_command_specific_status_code = 20 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY : spdk_nvme_command_specific_status_code = 21 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE : spdk_nvme_command_specific_status_code = 22 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED : spdk_nvme_command_specific_status_code = 24 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_IS_PRIVATE : spdk_nvme_command_specific_status_code = 25 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED : spdk_nvme_command_specific_status_code = 26 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED : spdk_nvme_command_specific_status_code = 27 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONTROLLER_LIST_INVALID : spdk_nvme_command_specific_status_code = 28 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_DEVICE_SELF_TEST_IN_PROGRESS : spdk_nvme_command_specific_status_code = 29 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_BOOT_PARTITION_WRITE_PROHIBITED : spdk_nvme_command_specific_status_code = 30 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_CTRLR_ID : spdk_nvme_command_specific_status_code = 31 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_SECONDARY_CTRLR_STATE : spdk_nvme_command_specific_status_code = 32 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_NUM_CTRLR_RESOURCES : spdk_nvme_command_specific_status_code = 33 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_RESOURCE_ID : spdk_nvme_command_specific_status_code = 34 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONFLICTING_ATTRIBUTES : spdk_nvme_command_specific_status_code = 128 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_PROTECTION_INFO : spdk_nvme_command_specific_status_code = 129 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE : spdk_nvme_command_specific_status_code = 130 ; pub type spdk_nvme_command_specific_status_code = u32 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_WRITE_FAULTS : spdk_nvme_media_error_status_code = 128 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_UNRECOVERED_READ_ERROR : spdk_nvme_media_error_status_code = 129 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_GUARD_CHECK_ERROR : spdk_nvme_media_error_status_code = 130 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR : spdk_nvme_media_error_status_code = 131 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR : spdk_nvme_media_error_status_code = 132 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_COMPARE_FAILURE : spdk_nvme_media_error_status_code = 133 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_ACCESS_DENIED : spdk_nvme_media_error_status_code = 134 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK : spdk_nvme_media_error_status_code = 135 ; pub type spdk_nvme_media_error_status_code = u32 ; pub const spdk_nvme_path_status_code_SPDK_NVME_SC_INTERNAL_PATH_ERROR : spdk_nvme_path_status_code = 0 ; pub const spdk_nvme_path_status_code_SPDK_NVME_SC_CONTROLLER_PATH_ERROR : spdk_nvme_path_status_code = 96 ; pub const spdk_nvme_path_status_code_SPDK_NVME_SC_HOST_PATH_ERROR : spdk_nvme_path_status_code = 112 ; pub const spdk_nvme_path_status_code_SPDK_NVME_SC_ABORTED_BY_HOST : spdk_nvme_path_status_code = 113 ; pub type spdk_nvme_path_status_code = u32 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_SQ : spdk_nvme_admin_opcode = 0 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_SQ : spdk_nvme_admin_opcode = 1 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_LOG_PAGE : spdk_nvme_admin_opcode = 2 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_CQ : spdk_nvme_admin_opcode = 4 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_CQ : spdk_nvme_admin_opcode = 5 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_IDENTIFY : spdk_nvme_admin_opcode = 6 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ABORT : spdk_nvme_admin_opcode = 8 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SET_FEATURES : spdk_nvme_admin_opcode = 9 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_FEATURES : spdk_nvme_admin_opcode = 10 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ASYNC_EVENT_REQUEST : spdk_nvme_admin_opcode = 12 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_MANAGEMENT : spdk_nvme_admin_opcode = 13 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_COMMIT : spdk_nvme_admin_opcode = 16 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD : spdk_nvme_admin_opcode = 17 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DEVICE_SELF_TEST : spdk_nvme_admin_opcode = 20 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_ATTACHMENT : spdk_nvme_admin_opcode = 21 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_KEEP_ALIVE : spdk_nvme_admin_opcode = 24 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_SEND : spdk_nvme_admin_opcode = 25 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_RECEIVE : spdk_nvme_admin_opcode = 26 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT : spdk_nvme_admin_opcode = 28 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_SEND : spdk_nvme_admin_opcode = 29 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_RECEIVE : spdk_nvme_admin_opcode = 30 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG : spdk_nvme_admin_opcode = 124 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FORMAT_NVM : spdk_nvme_admin_opcode = 128 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_SEND : spdk_nvme_admin_opcode = 129 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_RECEIVE : spdk_nvme_admin_opcode = 130 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SANITIZE : spdk_nvme_admin_opcode = 132 ; pub type spdk_nvme_admin_opcode = u32 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_FLUSH : spdk_nvme_nvm_opcode = 0 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE : spdk_nvme_nvm_opcode = 1 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_READ : spdk_nvme_nvm_opcode = 2 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_UNCORRECTABLE : spdk_nvme_nvm_opcode = 4 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_COMPARE : spdk_nvme_nvm_opcode = 5 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_ZEROES : spdk_nvme_nvm_opcode = 8 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_DATASET_MANAGEMENT : spdk_nvme_nvm_opcode = 9 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REGISTER : spdk_nvme_nvm_opcode = 13 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REPORT : spdk_nvme_nvm_opcode = 14 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_ACQUIRE : spdk_nvme_nvm_opcode = 17 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_RELEASE : spdk_nvme_nvm_opcode = 21 ; pub type spdk_nvme_nvm_opcode = u32 ; pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_NONE : spdk_nvme_data_transfer = 0 ; pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_HOST_TO_CONTROLLER : spdk_nvme_data_transfer = 1 ; pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_CONTROLLER_TO_HOST : spdk_nvme_data_transfer = 2 ; pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_BIDIRECTIONAL : spdk_nvme_data_transfer = 3 ; pub type spdk_nvme_data_transfer = u32 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ARBITRATION : spdk_nvme_feat = 1 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_POWER_MANAGEMENT : spdk_nvme_feat = 2 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_LBA_RANGE_TYPE : spdk_nvme_feat = 3 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD : spdk_nvme_feat = 4 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ERROR_RECOVERY : spdk_nvme_feat = 5 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE : spdk_nvme_feat = 6 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_NUMBER_OF_QUEUES : spdk_nvme_feat = 7 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_COALESCING : spdk_nvme_feat = 8 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION : spdk_nvme_feat = 9 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_WRITE_ATOMICITY : spdk_nvme_feat = 10 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION : spdk_nvme_feat = 11 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION : spdk_nvme_feat = 12 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_MEM_BUFFER : spdk_nvme_feat = 13 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_TIMESTAMP : spdk_nvme_feat = 14 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_KEEP_ALIVE_TIMER : spdk_nvme_feat = 15 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT : spdk_nvme_feat = 16 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG : spdk_nvme_feat = 17 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER : spdk_nvme_feat = 128 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_IDENTIFIER : spdk_nvme_feat = 129 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_MASK : spdk_nvme_feat = 130 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_PERSIST : spdk_nvme_feat = 131 ; pub type spdk_nvme_feat = u32 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_READ : spdk_nvme_dsm_attribute = 1 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE : spdk_nvme_dsm_attribute = 2 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_DEALLOCATE : spdk_nvme_dsm_attribute = 4 ; pub type spdk_nvme_dsm_attribute = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_power_state { pub mp : u16 , pub reserved1 : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub enlat : u32 , pub exlat : u32 , pub _bitfield_2 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub reserved7 : [ u8 ; 16usize ] , } impl spdk_nvme_power_state { # [ inline ] pub fn mps ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_mps ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nops ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_nops ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( mps : u8 , nops : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let mps : u8 = unsafe { :: std :: mem :: transmute ( mps ) } ; mps as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let nops : u8 = unsafe { :: std :: mem :: transmute ( nops ) } ; nops as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } # [ inline ] pub fn rrt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rrt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rrl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 8usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rrl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 8usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 13usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rwt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 16usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rwt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 16usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved5 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 21usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved5 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 21usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rwl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 24usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rwl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 24usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 29usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 29usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_2 ( rrt : u8 , reserved3 : u8 , rrl : u8 , reserved4 : u8 , rwt : u8 , reserved5 : u8 , rwl : u8 , reserved6 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let rrt : u8 = unsafe { :: std :: mem :: transmute ( rrt ) } ; rrt as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 5u8 , { let rrl : u8 = unsafe { :: std :: mem :: transmute ( rrl ) } ; rrl as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 5u8 , { let rwt : u8 = unsafe { :: std :: mem :: transmute ( rwt ) } ; rwt as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 3u8 , { let reserved5 : u8 = unsafe { :: std :: mem :: transmute ( reserved5 ) } ; reserved5 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 5u8 , { let rwl : u8 = unsafe { :: std :: mem :: transmute ( rwl ) } ; rwl as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 3u8 , { let reserved6 : u8 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit } } pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS : spdk_nvme_identify_cns = 0 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR : spdk_nvme_identify_cns = 1 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST : spdk_nvme_identify_cns = 2 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST : spdk_nvme_identify_cns = 3 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST : spdk_nvme_identify_cns = 16 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ALLOCATED : spdk_nvme_identify_cns = 17 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST : spdk_nvme_identify_cns = 18 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR_LIST : spdk_nvme_identify_cns = 19 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP : spdk_nvme_identify_cns = 20 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST : spdk_nvme_identify_cns = 21 ; pub type spdk_nvme_identify_cns = u32 ; pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_DYNAMIC : spdk_nvmf_ctrlr_model = 0 ; pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_STATIC : spdk_nvmf_ctrlr_model = 1 ; pub type spdk_nvmf_ctrlr_model = u32 ; pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_NOT_SUPPORTED : spdk_nvme_sgls_supported = 0 ; pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED : spdk_nvme_sgls_supported = 1 ; pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED_DWORD_ALIGNED : spdk_nvme_sgls_supported = 2 ; pub type spdk_nvme_sgls_supported = u32 ; pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_NOT_INDICATED : spdk_nvme_flush_broadcast = 0 ; pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_NOT_SUPPORTED : spdk_nvme_flush_broadcast = 2 ; pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_SUPPORTED : spdk_nvme_flush_broadcast = 3 ; pub type spdk_nvme_flush_broadcast = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data { pub vid : u16 , pub ssvid : u16 , pub sn : [ i8 ; 20usize ] , pub mn : [ i8 ; 40usize ] , pub fr : [ u8 ; 8usize ] , pub rab : u8 , pub ieee : [ u8 ; 3usize ] , pub cmic : spdk_nvme_ctrlr_data__bindgen_ty_1 , pub mdts : u8 , pub cntlid : u16 , pub ver : spdk_nvme_vs_register , pub rtd3r : u32 , pub rtd3e : u32 , pub oaes : spdk_nvme_ctrlr_data__bindgen_ty_2 , pub ctratt : spdk_nvme_ctrlr_data__bindgen_ty_3 , pub reserved_100 : [ u8 ; 12usize ] , pub fguid : [ u8 ; 16usize ] , pub reserved_128 : [ u8 ; 128usize ] , pub oacs : spdk_nvme_ctrlr_data__bindgen_ty_4 , pub acl : u8 , pub aerl : u8 , pub frmw : spdk_nvme_ctrlr_data__bindgen_ty_5 , pub lpa : spdk_nvme_ctrlr_data__bindgen_ty_6 , pub elpe : u8 , pub npss : u8 , pub avscc : spdk_nvme_ctrlr_data__bindgen_ty_7 , pub apsta : spdk_nvme_ctrlr_data__bindgen_ty_8 , pub wctemp : u16 , pub cctemp : u16 , pub mtfa : u16 , pub hmpre : u32 , pub hmmin : u32 , pub tnvmcap : [ u64 ; 2usize ] , pub unvmcap : [ u64 ; 2usize ] , pub rpmbs : spdk_nvme_ctrlr_data__bindgen_ty_9 , pub edstt : u16 , pub dsto : spdk_nvme_ctrlr_data__bindgen_ty_10 , pub fwug : u8 , pub kas : u16 , pub hctma : spdk_nvme_ctrlr_data__bindgen_ty_11 , pub mntmt : u16 , pub mxtmt : u16 , pub sanicap : spdk_nvme_ctrlr_data__bindgen_ty_12 , pub reserved3 : [ u8 ; 180usize ] , pub sqes : spdk_nvme_ctrlr_data__bindgen_ty_13 , pub cqes : spdk_nvme_ctrlr_data__bindgen_ty_14 , pub maxcmd : u16 , pub nn : u32 , pub oncs : spdk_nvme_ctrlr_data__bindgen_ty_15 , pub fuses : u16 , pub fna : spdk_nvme_ctrlr_data__bindgen_ty_16 , pub vwc : spdk_nvme_ctrlr_data__bindgen_ty_17 , pub awun : u16 , pub awupf : u16 , pub nvscc : u8 , pub reserved531 : u8 , pub acwu : u16 , pub reserved534 : u16 , pub sgls : spdk_nvme_ctrlr_data__bindgen_ty_18 , pub reserved4 : [ u8 ; 228usize ] , pub subnqn : [ u8 ; 256usize ] , pub reserved5 : [ u8 ; 768usize ] , pub nvmf_specific : spdk_nvme_ctrlr_data__bindgen_ty_19 , pub psd : [ spdk_nvme_power_state ; 32usize ] , pub vs : [ u8 ; 1024usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_1 { # [ inline ] pub fn multi_port ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_multi_port ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn multi_host ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_multi_host ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sr_iov ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_sr_iov ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( multi_port : u8 , multi_host : u8 , sr_iov : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let multi_port : u8 = unsafe { :: std :: mem :: transmute ( multi_port ) } ; multi_port as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let multi_host : u8 = unsafe { :: std :: mem :: transmute ( multi_host ) } ; multi_host as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let sr_iov : u8 = unsafe { :: std :: mem :: transmute ( sr_iov ) } ; sr_iov as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_2 { # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn ns_attribute_notices ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ns_attribute_notices ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fw_activation_notices ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fw_activation_notices ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 22u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 22u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( reserved1 : u32 , ns_attribute_notices : u32 , fw_activation_notices : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ns_attribute_notices : u32 = unsafe { :: std :: mem :: transmute ( ns_attribute_notices ) } ; ns_attribute_notices as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let fw_activation_notices : u32 = unsafe { :: std :: mem :: transmute ( fw_activation_notices ) } ; fw_activation_notices as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 22u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_3 { # [ inline ] pub fn host_id_exhid_supported ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_host_id_exhid_supported ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn non_operational_power_state_permissive_mode ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_non_operational_power_state_permissive_mode ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( host_id_exhid_supported : u32 , non_operational_power_state_permissive_mode : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let host_id_exhid_supported : u32 = unsafe { :: std :: mem :: transmute ( host_id_exhid_supported ) } ; host_id_exhid_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let non_operational_power_state_permissive_mode : u32 = unsafe { :: std :: mem :: transmute ( non_operational_power_state_permissive_mode ) } ; non_operational_power_state_permissive_mode as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_4 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_4 { # [ inline ] pub fn security ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_security ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn format ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_format ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn firmware ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_firmware ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ns_manage ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ns_manage ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn device_self_test ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_device_self_test ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn directives ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_directives ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nvme_mi ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_nvme_mi ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn virtualization_management ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_virtualization_management ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn doorbell_buffer_config ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_doorbell_buffer_config ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn oacs_rsvd ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 7u8 ) as u16 ) } } # [ inline ] pub fn set_oacs_rsvd ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( security : u16 , format : u16 , firmware : u16 , ns_manage : u16 , device_self_test : u16 , directives : u16 , nvme_mi : u16 , virtualization_management : u16 , doorbell_buffer_config : u16 , oacs_rsvd : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let security : u16 = unsafe { :: std :: mem :: transmute ( security ) } ; security as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let format : u16 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let firmware : u16 = unsafe { :: std :: mem :: transmute ( firmware ) } ; firmware as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ns_manage : u16 = unsafe { :: std :: mem :: transmute ( ns_manage ) } ; ns_manage as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let device_self_test : u16 = unsafe { :: std :: mem :: transmute ( device_self_test ) } ; device_self_test as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let directives : u16 = unsafe { :: std :: mem :: transmute ( directives ) } ; directives as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let nvme_mi : u16 = unsafe { :: std :: mem :: transmute ( nvme_mi ) } ; nvme_mi as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let virtualization_management : u16 = unsafe { :: std :: mem :: transmute ( virtualization_management ) } ; virtualization_management as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let doorbell_buffer_config : u16 = unsafe { :: std :: mem :: transmute ( doorbell_buffer_config ) } ; doorbell_buffer_config as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 7u8 , { let oacs_rsvd : u16 = unsafe { :: std :: mem :: transmute ( oacs_rsvd ) } ; oacs_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_5 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_5 { # [ inline ] pub fn slot1_ro ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_slot1_ro ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn num_slots ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_num_slots ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn activation_without_reset ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_activation_without_reset ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn frmw_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_frmw_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( slot1_ro : u8 , num_slots : u8 , activation_without_reset : u8 , frmw_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let slot1_ro : u8 = unsafe { :: std :: mem :: transmute ( slot1_ro ) } ; slot1_ro as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let num_slots : u8 = unsafe { :: std :: mem :: transmute ( num_slots ) } ; num_slots as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let activation_without_reset : u8 = unsafe { :: std :: mem :: transmute ( activation_without_reset ) } ; activation_without_reset as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let frmw_rsvd : u8 = unsafe { :: std :: mem :: transmute ( frmw_rsvd ) } ; frmw_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_6 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_6 { # [ inline ] pub fn ns_smart ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ns_smart ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn celp ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_celp ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn edlp ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_edlp ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn telemetry ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_telemetry ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lpa_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_lpa_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ns_smart : u8 , celp : u8 , edlp : u8 , telemetry : u8 , lpa_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ns_smart : u8 = unsafe { :: std :: mem :: transmute ( ns_smart ) } ; ns_smart as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let celp : u8 = unsafe { :: std :: mem :: transmute ( celp ) } ; celp as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let edlp : u8 = unsafe { :: std :: mem :: transmute ( edlp ) } ; edlp as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let telemetry : u8 = unsafe { :: std :: mem :: transmute ( telemetry ) } ; telemetry as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let lpa_rsvd : u8 = unsafe { :: std :: mem :: transmute ( lpa_rsvd ) } ; lpa_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_7 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_7 { # [ inline ] pub fn spec_format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_spec_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn avscc_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_avscc_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( spec_format : u8 , avscc_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let spec_format : u8 = unsafe { :: std :: mem :: transmute ( spec_format ) } ; spec_format as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let avscc_rsvd : u8 = unsafe { :: std :: mem :: transmute ( avscc_rsvd ) } ; avscc_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_8 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_8 { # [ inline ] pub fn supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn apsta_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_apsta_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u8 , apsta_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let supported : u8 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let apsta_rsvd : u8 = unsafe { :: std :: mem :: transmute ( apsta_rsvd ) } ; apsta_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_9 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub reserved2 : u8 , pub total_size : u8 , pub access_size : u8 , } impl spdk_nvme_ctrlr_data__bindgen_ty_9 { # [ inline ] pub fn num_rpmb_units ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_num_rpmb_units ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn auth_method ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_auth_method ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( num_rpmb_units : u8 , auth_method : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let num_rpmb_units : u8 = unsafe { :: std :: mem :: transmute ( num_rpmb_units ) } ; num_rpmb_units as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let auth_method : u8 = unsafe { :: std :: mem :: transmute ( auth_method ) } ; auth_method as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_10 { pub raw : u8 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 { # [ inline ] pub fn one_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_one_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( one_only : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let one_only : u8 = unsafe { :: std :: mem :: transmute ( one_only ) } ; one_only as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_10 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_11 { pub raw : u16 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 , _bindgen_union_align : u16 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 { # [ inline ] pub fn supported ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 15u8 ) as u16 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u16 , reserved : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let supported : u16 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 15u8 , { let reserved : u16 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_11 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_12 { pub raw : u32 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 { # [ inline ] pub fn crypto_erase ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_crypto_erase ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn block_erase ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_block_erase ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn overwrite ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_overwrite ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( crypto_erase : u32 , block_erase : u32 , overwrite : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let crypto_erase : u32 = unsafe { :: std :: mem :: transmute ( crypto_erase ) } ; crypto_erase as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let block_erase : u32 = unsafe { :: std :: mem :: transmute ( block_erase ) } ; block_erase as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let overwrite : u32 = unsafe { :: std :: mem :: transmute ( overwrite ) } ; overwrite as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_12 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_13 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_13 { # [ inline ] pub fn min ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_min ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn max ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_max ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( min : u8 , max : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let min : u8 = unsafe { :: std :: mem :: transmute ( min ) } ; min as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let max : u8 = unsafe { :: std :: mem :: transmute ( max ) } ; max as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_14 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_14 { # [ inline ] pub fn min ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_min ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn max ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_max ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( min : u8 , max : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let min : u8 = unsafe { :: std :: mem :: transmute ( min ) } ; min as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let max : u8 = unsafe { :: std :: mem :: transmute ( max ) } ; max as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_15 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_15 { # [ inline ] pub fn compare ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_compare ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_unc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_write_unc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dsm ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_dsm ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_zeroes ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_write_zeroes ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn set_features_save ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_set_features_save ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reservations ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_reservations ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn timestamp ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_timestamp ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( compare : u16 , write_unc : u16 , dsm : u16 , write_zeroes : u16 , set_features_save : u16 , reservations : u16 , timestamp : u16 , reserved : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let compare : u16 = unsafe { :: std :: mem :: transmute ( compare ) } ; compare as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let write_unc : u16 = unsafe { :: std :: mem :: transmute ( write_unc ) } ; write_unc as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dsm : u16 = unsafe { :: std :: mem :: transmute ( dsm ) } ; dsm as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_zeroes : u16 = unsafe { :: std :: mem :: transmute ( write_zeroes ) } ; write_zeroes as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let set_features_save : u16 = unsafe { :: std :: mem :: transmute ( set_features_save ) } ; set_features_save as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let reservations : u16 = unsafe { :: std :: mem :: transmute ( reservations ) } ; reservations as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let timestamp : u16 = unsafe { :: std :: mem :: transmute ( timestamp ) } ; timestamp as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let reserved : u16 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_16 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_16 { # [ inline ] pub fn format_all_ns ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_format_all_ns ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn erase_all_ns ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_erase_all_ns ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn crypto_erase_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_crypto_erase_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( format_all_ns : u8 , erase_all_ns : u8 , crypto_erase_supported : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let format_all_ns : u8 = unsafe { :: std :: mem :: transmute ( format_all_ns ) } ; format_all_ns as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let erase_all_ns : u8 = unsafe { :: std :: mem :: transmute ( erase_all_ns ) } ; erase_all_ns as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let crypto_erase_supported : u8 = unsafe { :: std :: mem :: transmute ( crypto_erase_supported ) } ; crypto_erase_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_17 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_17 { # [ inline ] pub fn present ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_present ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn flush_broadcast ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_flush_broadcast ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( present : u8 , flush_broadcast : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let present : u8 = unsafe { :: std :: mem :: transmute ( present ) } ; present as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 2u8 , { let flush_broadcast : u8 = unsafe { :: std :: mem :: transmute ( flush_broadcast ) } ; flush_broadcast as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_18 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_18 { # [ inline ] pub fn supported ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn keyed_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_keyed_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 13u8 , val as u64 ) } } # [ inline ] pub fn bit_bucket_descriptor ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bit_bucket_descriptor ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn metadata_pointer ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_metadata_pointer ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn oversized_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_oversized_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn metadata_address ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_metadata_address ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sgl_offset ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sgl_offset ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn transport_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_transport_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u32 , keyed_sgl : u32 , reserved1 : u32 , bit_bucket_descriptor : u32 , metadata_pointer : u32 , oversized_sgl : u32 , metadata_address : u32 , sgl_offset : u32 , transport_sgl : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let supported : u32 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let keyed_sgl : u32 = unsafe { :: std :: mem :: transmute ( keyed_sgl ) } ; keyed_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 13u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let bit_bucket_descriptor : u32 = unsafe { :: std :: mem :: transmute ( bit_bucket_descriptor ) } ; bit_bucket_descriptor as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let metadata_pointer : u32 = unsafe { :: std :: mem :: transmute ( metadata_pointer ) } ; metadata_pointer as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let oversized_sgl : u32 = unsafe { :: std :: mem :: transmute ( oversized_sgl ) } ; oversized_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let metadata_address : u32 = unsafe { :: std :: mem :: transmute ( metadata_address ) } ; metadata_address as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let sgl_offset : u32 = unsafe { :: std :: mem :: transmute ( sgl_offset ) } ; sgl_offset as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let transport_sgl : u32 = unsafe { :: std :: mem :: transmute ( transport_sgl ) } ; transport_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 10u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_19 { pub ioccsz : u32 , pub iorcsz : u32 , pub icdoff : u16 , pub ctrattr : spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 , pub msdbd : u8 , pub reserved : [ u8 ; 244usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 { # [ inline ] pub fn ctrlr_model ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ctrlr_model ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ctrlr_model : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ctrlr_model : u8 = unsafe { :: std :: mem :: transmute ( ctrlr_model ) } ; ctrlr_model as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_19 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_ctrlr_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_primary_ctrl_capabilities { pub cntlid : u16 , pub portid : u16 , pub crt : spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 , pub reserved : [ u8 ; 27usize ] , pub vqfrt : u32 , pub vqrfa : u32 , pub vqrfap : u16 , pub vqprt : u16 , pub vqfrsm : u16 , pub vqgran : u16 , pub reserved1 : [ u8 ; 16usize ] , pub vifrt : u32 , pub virfa : u32 , pub virfap : u16 , pub viprt : u16 , pub vifrsm : u16 , pub vigran : u16 , pub reserved2 : [ u8 ; 4016usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 { # [ inline ] pub fn vq_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_vq_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn vi_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_vi_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( vq_supported : u8 , vi_supported : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let vq_supported : u8 = unsafe { :: std :: mem :: transmute ( vq_supported ) } ; vq_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let vi_supported : u8 = unsafe { :: std :: mem :: transmute ( vi_supported ) } ; vi_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_primary_ctrl_capabilities { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_entry { pub scid : u16 , pub pcid : u16 , pub scs : spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 , pub reserved : [ u8 ; 3usize ] , pub vfn : u16 , pub nvq : u16 , pub nvi : u16 , pub reserved1 : [ u8 ; 18usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 { # [ inline ] pub fn is_online ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_is_online ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( is_online : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let is_online : u8 = unsafe { :: std :: mem :: transmute ( is_online ) } ; is_online as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_list { pub number : u8 , pub reserved : [ u8 ; 31usize ] , pub entries : [ spdk_nvme_secondary_ctrl_entry ; 127usize ] , } impl Default for spdk_nvme_secondary_ctrl_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ns_data { pub nsze : u64 , pub ncap : u64 , pub nuse : u64 , pub nsfeat : spdk_nvme_ns_data__bindgen_ty_1 , pub nlbaf : u8 , pub flbas : spdk_nvme_ns_data__bindgen_ty_2 , pub mc : spdk_nvme_ns_data__bindgen_ty_3 , pub dpc : spdk_nvme_ns_data__bindgen_ty_4 , pub dps : spdk_nvme_ns_data__bindgen_ty_5 , pub nmic : spdk_nvme_ns_data__bindgen_ty_6 , pub nsrescap : spdk_nvme_ns_data__bindgen_ty_7 , pub fpi : spdk_nvme_ns_data__bindgen_ty_8 , pub dlfeat : spdk_nvme_ns_data__bindgen_ty_9 , pub nawun : u16 , pub nawupf : u16 , pub nacwu : u16 , pub nabsn : u16 , pub nabo : u16 , pub nabspf : u16 , pub noiob : u16 , pub nvmcap : [ u64 ; 2usize ] , pub reserved64 : [ u8 ; 40usize ] , pub nguid : [ u8 ; 16usize ] , pub eui64 : u64 , pub lbaf : [ spdk_nvme_ns_data__bindgen_ty_10 ; 16usize ] , pub reserved6 : [ u8 ; 192usize ] , pub vendor_specific : [ u8 ; 3712usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_1 { # [ inline ] pub fn thin_prov ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_thin_prov ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ns_atomic_write_unit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ns_atomic_write_unit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dealloc_or_unwritten_error ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_dealloc_or_unwritten_error ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn guid_never_reused ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_guid_never_reused ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( thin_prov : u8 , ns_atomic_write_unit : u8 , dealloc_or_unwritten_error : u8 , guid_never_reused : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let thin_prov : u8 = unsafe { :: std :: mem :: transmute ( thin_prov ) } ; thin_prov as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ns_atomic_write_unit : u8 = unsafe { :: std :: mem :: transmute ( ns_atomic_write_unit ) } ; ns_atomic_write_unit as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dealloc_or_unwritten_error : u8 = unsafe { :: std :: mem :: transmute ( dealloc_or_unwritten_error ) } ; dealloc_or_unwritten_error as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let guid_never_reused : u8 = unsafe { :: std :: mem :: transmute ( guid_never_reused ) } ; guid_never_reused as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_2 { # [ inline ] pub fn format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn extended ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_extended ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( format : u8 , extended : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let format : u8 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let extended : u8 = unsafe { :: std :: mem :: transmute ( extended ) } ; extended as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_3 { # [ inline ] pub fn extended ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_extended ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pointer ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pointer ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( extended : u8 , pointer : u8 , reserved3 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let extended : u8 = unsafe { :: std :: mem :: transmute ( extended ) } ; extended as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let pointer : u8 = unsafe { :: std :: mem :: transmute ( pointer ) } ; pointer as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_4 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_4 { # [ inline ] pub fn pit1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pit2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pit3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn md_start ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_start ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn md_end ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_end ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pit1 : u8 , pit2 : u8 , pit3 : u8 , md_start : u8 , md_end : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let pit1 : u8 = unsafe { :: std :: mem :: transmute ( pit1 ) } ; pit1 as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let pit2 : u8 = unsafe { :: std :: mem :: transmute ( pit2 ) } ; pit2 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let pit3 : u8 = unsafe { :: std :: mem :: transmute ( pit3 ) } ; pit3 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let md_start : u8 = unsafe { :: std :: mem :: transmute ( md_start ) } ; md_start as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let md_end : u8 = unsafe { :: std :: mem :: transmute ( md_end ) } ; md_end as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_5 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_5 { # [ inline ] pub fn pit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_pit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn md_start ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_start ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pit : u8 , md_start : u8 , reserved4 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let pit : u8 = unsafe { :: std :: mem :: transmute ( pit ) } ; pit as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let md_start : u8 = unsafe { :: std :: mem :: transmute ( md_start ) } ; md_start as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_6 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_6 { # [ inline ] pub fn can_share ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_can_share ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( can_share : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let can_share : u8 = unsafe { :: std :: mem :: transmute ( can_share ) } ; can_share as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ns_data__bindgen_ty_7 { pub rescap : spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 , pub raw : u8 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 { # [ inline ] pub fn persist ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_persist ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive_reg_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive_reg_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access_reg_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access_reg_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive_all_reg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive_all_reg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access_all_reg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access_all_reg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ignore_existing_key ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ignore_existing_key ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( persist : u8 , write_exclusive : u8 , exclusive_access : u8 , write_exclusive_reg_only : u8 , exclusive_access_reg_only : u8 , write_exclusive_all_reg : u8 , exclusive_access_all_reg : u8 , ignore_existing_key : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let persist : u8 = unsafe { :: std :: mem :: transmute ( persist ) } ; persist as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let write_exclusive : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive ) } ; write_exclusive as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let exclusive_access : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access ) } ; exclusive_access as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_exclusive_reg_only : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive_reg_only ) } ; write_exclusive_reg_only as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let exclusive_access_reg_only : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access_reg_only ) } ; exclusive_access_reg_only as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let write_exclusive_all_reg : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive_all_reg ) } ; write_exclusive_all_reg as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let exclusive_access_all_reg : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access_all_reg ) } ; exclusive_access_all_reg as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ignore_existing_key : u8 = unsafe { :: std :: mem :: transmute ( ignore_existing_key ) } ; ignore_existing_key as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ns_data__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_8 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_8 { # [ inline ] pub fn percentage_remaining ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_percentage_remaining ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn fpi_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_fpi_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( percentage_remaining : u8 , fpi_supported : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let percentage_remaining : u8 = unsafe { :: std :: mem :: transmute ( percentage_remaining ) } ; percentage_remaining as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let fpi_supported : u8 = unsafe { :: std :: mem :: transmute ( fpi_supported ) } ; fpi_supported as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ns_data__bindgen_ty_9 { pub raw : u8 , pub bits : spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 { # [ inline ] pub fn read_value ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_read_value ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn write_zero_deallocate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_zero_deallocate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn guard_value ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_guard_value ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( read_value : u8 , write_zero_deallocate : u8 , guard_value : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let read_value : u8 = unsafe { :: std :: mem :: transmute ( read_value ) } ; read_value as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_zero_deallocate : u8 = unsafe { :: std :: mem :: transmute ( write_zero_deallocate ) } ; write_zero_deallocate as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let guard_value : u8 = unsafe { :: std :: mem :: transmute ( guard_value ) } ; guard_value as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ns_data__bindgen_ty_9 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_10 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ns_data__bindgen_ty_10 { # [ inline ] pub fn ms ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ms ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn lbads ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_lbads ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn rp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_rp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ms : u32 , lbads : u32 , rp : u32 , reserved6 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let ms : u32 = unsafe { :: std :: mem :: transmute ( ms ) } ; ms as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let lbads : u32 = unsafe { :: std :: mem :: transmute ( lbads ) } ; lbads as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 2u8 , { let rp : u32 = unsafe { :: std :: mem :: transmute ( rp ) } ; rp as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 6u8 , { let reserved6 : u32 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ns_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_NOT_REPORTED : spdk_nvme_dealloc_logical_block_read_value = 0 ; pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_00 : spdk_nvme_dealloc_logical_block_read_value = 1 ; pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_FF : spdk_nvme_dealloc_logical_block_read_value = 2 ; pub type spdk_nvme_dealloc_logical_block_read_value = u32 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE : spdk_nvme_reservation_type = 1 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS : spdk_nvme_reservation_type = 2 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY : spdk_nvme_reservation_type = 3 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY : spdk_nvme_reservation_type = 4 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS : spdk_nvme_reservation_type = 5 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS : spdk_nvme_reservation_type = 6 ; pub type spdk_nvme_reservation_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_acquire_data { pub crkey : u64 , pub prkey : u64 , } pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_ACQUIRE : spdk_nvme_reservation_acquire_action = 0 ; pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT : spdk_nvme_reservation_acquire_action = 1 ; pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT_ABORT : spdk_nvme_reservation_acquire_action = 2 ; pub type spdk_nvme_reservation_acquire_action = u32 ; # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_status_data { pub generation : u32 , pub type_ : u8 , pub nr_regctl : u16 , pub reserved1 : u16 , pub ptpl_state : u8 , pub reserved : [ u8 ; 14usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_ctrlr_data { pub ctrlr_id : u16 , pub rcsts : spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 , pub reserved2 : [ u8 ; 5usize ] , pub host_id : u64 , pub key : u64 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 { # [ inline ] pub fn status ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_status ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( status : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let status : u8 = unsafe { :: std :: mem :: transmute ( status ) } ; status as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_NO_CHANGES : spdk_nvme_reservation_register_cptpl = 0 ; pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON : spdk_nvme_reservation_register_cptpl = 2 ; pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS : spdk_nvme_reservation_register_cptpl = 3 ; pub type spdk_nvme_reservation_register_cptpl = u32 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REGISTER_KEY : spdk_nvme_reservation_register_action = 0 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_UNREGISTER_KEY : spdk_nvme_reservation_register_action = 1 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REPLACE_KEY : spdk_nvme_reservation_register_action = 2 ; pub type spdk_nvme_reservation_register_action = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_register_data { pub crkey : u64 , pub nrkey : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_key_data { pub crkey : u64 , } pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_RELEASE : spdk_nvme_reservation_release_action = 0 ; pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_CLEAR : spdk_nvme_reservation_release_action = 1 ; pub type spdk_nvme_reservation_release_action = u32 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_ERROR : spdk_nvme_log_page = 1 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_HEALTH_INFORMATION : spdk_nvme_log_page = 2 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_FIRMWARE_SLOT : spdk_nvme_log_page = 3 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_CHANGED_NS_LIST : spdk_nvme_log_page = 4 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_COMMAND_EFFECTS_LOG : spdk_nvme_log_page = 5 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_DISCOVERY : spdk_nvme_log_page = 112 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_RESERVATION_NOTIFICATION : spdk_nvme_log_page = 128 ; pub type spdk_nvme_log_page = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_error_information_entry { pub error_count : u64 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , pub error_location : u16 , pub lba : u64 , pub nsid : u32 , pub vendor_specific : u8 , pub trtype : u8 , pub reserved30 : [ u8 ; 2usize ] , pub command_specific : u64 , pub trtype_specific : u16 , pub reserved42 : [ u8 ; 22usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_critical_warning_state { pub raw : u8 , pub bits : spdk_nvme_critical_warning_state__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_critical_warning_state__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_critical_warning_state__bindgen_ty_1 { # [ inline ] pub fn available_spare ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_available_spare ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn temperature ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_temperature ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn device_reliability ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_device_reliability ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn read_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_read_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn volatile_memory_backup ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_volatile_memory_backup ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( available_spare : u8 , temperature : u8 , device_reliability : u8 , read_only : u8 , volatile_memory_backup : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let available_spare : u8 = unsafe { :: std :: mem :: transmute ( available_spare ) } ; available_spare as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let temperature : u8 = unsafe { :: std :: mem :: transmute ( temperature ) } ; temperature as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let device_reliability : u8 = unsafe { :: std :: mem :: transmute ( device_reliability ) } ; device_reliability as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let read_only : u8 = unsafe { :: std :: mem :: transmute ( read_only ) } ; read_only as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let volatile_memory_backup : u8 = unsafe { :: std :: mem :: transmute ( volatile_memory_backup ) } ; volatile_memory_backup as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_critical_warning_state { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_health_information_page { pub critical_warning : spdk_nvme_critical_warning_state , pub temperature : u16 , pub available_spare : u8 , pub available_spare_threshold : u8 , pub percentage_used : u8 , pub reserved : [ u8 ; 26usize ] , pub data_units_read : [ u64 ; 2usize ] , pub data_units_written : [ u64 ; 2usize ] , pub host_read_commands : [ u64 ; 2usize ] , pub host_write_commands : [ u64 ; 2usize ] , pub controller_busy_time : [ u64 ; 2usize ] , pub power_cycles : [ u64 ; 2usize ] , pub power_on_hours : [ u64 ; 2usize ] , pub unsafe_shutdowns : [ u64 ; 2usize ] , pub media_errors : [ u64 ; 2usize ] , pub num_error_info_log_entries : [ u64 ; 2usize ] , pub warning_temp_time : u32 , pub critical_temp_time : u32 , pub temp_sensor : [ u16 ; 8usize ] , pub reserved2 : [ u8 ; 296usize ] , } impl Default for spdk_nvme_health_information_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmds_and_effect_entry { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_cmds_and_effect_entry { # [ inline ] pub fn csupp ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_csupp ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lbcc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_lbcc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ncc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ncc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nic ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_nic ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ccc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ccc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn cse ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_cse ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 13u8 ) as u16 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 13u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( csupp : u16 , lbcc : u16 , ncc : u16 , nic : u16 , ccc : u16 , reserved1 : u16 , cse : u16 , reserved2 : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let csupp : u16 = unsafe { :: std :: mem :: transmute ( csupp ) } ; csupp as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let lbcc : u16 = unsafe { :: std :: mem :: transmute ( lbcc ) } ; lbcc as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ncc : u16 = unsafe { :: std :: mem :: transmute ( ncc ) } ; ncc as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let nic : u16 = unsafe { :: std :: mem :: transmute ( nic ) } ; nic as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ccc : u16 = unsafe { :: std :: mem :: transmute ( ccc ) } ; ccc as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let reserved1 : u16 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 3u8 , { let cse : u16 = unsafe { :: std :: mem :: transmute ( cse ) } ; cse as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 13u8 , { let reserved2 : u16 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_cmds_and_effect_log_page { pub admin_cmds_supported : [ spdk_nvme_cmds_and_effect_entry ; 256usize ] , pub io_cmds_supported : [ spdk_nvme_cmds_and_effect_entry ; 256usize ] , pub reserved0 : [ u8 ; 2048usize ] , } impl Default for spdk_nvme_cmds_and_effect_log_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_ERROR : spdk_nvme_async_event_type = 0 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_SMART : spdk_nvme_async_event_type = 1 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE : spdk_nvme_async_event_type = 2 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_IO : spdk_nvme_async_event_type = 6 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_VENDOR : spdk_nvme_async_event_type = 7 ; pub type spdk_nvme_async_event_type = u32 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_WRITE_INVALID_DB : spdk_nvme_async_event_info_error = 0 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_INVALID_DB_WRITE : spdk_nvme_async_event_info_error = 1 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_DIAGNOSTIC_FAILURE : spdk_nvme_async_event_info_error = 2 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_PERSISTENT_INTERNAL : spdk_nvme_async_event_info_error = 3 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_TRANSIENT_INTERNAL : spdk_nvme_async_event_info_error = 4 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_FW_IMAGE_LOAD : spdk_nvme_async_event_info_error = 5 ; pub type spdk_nvme_async_event_info_error = u32 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SUBSYSTEM_RELIABILITY : spdk_nvme_async_event_info_smart = 0 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_TEMPERATURE_THRESHOLD : spdk_nvme_async_event_info_smart = 1 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SPARE_BELOW_THRESHOLD : spdk_nvme_async_event_info_smart = 2 ; pub type spdk_nvme_async_event_info_smart = u32 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED : spdk_nvme_async_event_info_notice = 0 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_FW_ACTIVATION_START : spdk_nvme_async_event_info_notice = 1 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_TELEMETRY_LOG_CHANGED : spdk_nvme_async_event_info_notice = 2 ; pub type spdk_nvme_async_event_info_notice = u32 ; pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_RESERVATION_LOG_AVAIL : spdk_nvme_async_event_info_nvm_command_set = 0 ; pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_SANITIZE_COMPLETED : spdk_nvme_async_event_info_nvm_command_set = 1 ; pub type spdk_nvme_async_event_info_nvm_command_set = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_async_event_completion { pub raw : u32 , pub bits : spdk_nvme_async_event_completion__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_async_event_completion__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_async_event_completion__bindgen_ty_1 { # [ inline ] pub fn async_event_type ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_async_event_type ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn async_event_info ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_async_event_info ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn log_page_identifier ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_log_page_identifier ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( async_event_type : u32 , reserved1 : u32 , async_event_info : u32 , log_page_identifier : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let async_event_type : u32 = unsafe { :: std :: mem :: transmute ( async_event_type ) } ; async_event_type as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let async_event_info : u32 = unsafe { :: std :: mem :: transmute ( async_event_info ) } ; async_event_info as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let log_page_identifier : u32 = unsafe { :: std :: mem :: transmute ( log_page_identifier ) } ; log_page_identifier as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_async_event_completion { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_arbitration { pub raw : u32 , pub bits : spdk_nvme_feat_arbitration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_arbitration__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_arbitration__bindgen_ty_1 { # [ inline ] pub fn ab ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ab ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn lpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_lpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_mpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn hpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_hpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ab : u32 , reserved : u32 , lpw : u32 , mpw : u32 , hpw : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let ab : u32 = unsafe { :: std :: mem :: transmute ( ab ) } ; ab as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let lpw : u32 = unsafe { :: std :: mem :: transmute ( lpw ) } ; lpw as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let mpw : u32 = unsafe { :: std :: mem :: transmute ( mpw ) } ; mpw as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let hpw : u32 = unsafe { :: std :: mem :: transmute ( hpw ) } ; hpw as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_arbitration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_power_management { pub raw : u32 , pub bits : spdk_nvme_feat_power_management__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_power_management__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_power_management__bindgen_ty_1 { # [ inline ] pub fn ps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_ps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn wh ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_wh ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ps : u32 , wh : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let ps : u32 = unsafe { :: std :: mem :: transmute ( ps ) } ; ps as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let wh : u32 = unsafe { :: std :: mem :: transmute ( wh ) } ; wh as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_power_management { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_lba_range_type { pub raw : u32 , pub bits : spdk_nvme_feat_lba_range_type__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_lba_range_type__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_lba_range_type__bindgen_ty_1 { # [ inline ] pub fn num ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_num ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( num : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let num : u32 = unsafe { :: std :: mem :: transmute ( num ) } ; num as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_lba_range_type { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_temperature_threshold { pub raw : u32 , pub bits : spdk_nvme_feat_temperature_threshold__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_temperature_threshold__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_temperature_threshold__bindgen_ty_1 { # [ inline ] pub fn tmpth ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmpth ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn tmpsel ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_tmpsel ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn thsel ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_thsel ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tmpth : u32 , tmpsel : u32 , thsel : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tmpth : u32 = unsafe { :: std :: mem :: transmute ( tmpth ) } ; tmpth as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let tmpsel : u32 = unsafe { :: std :: mem :: transmute ( tmpsel ) } ; tmpsel as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 2u8 , { let thsel : u32 = unsafe { :: std :: mem :: transmute ( thsel ) } ; thsel as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 10u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_temperature_threshold { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_error_recovery { pub raw : u32 , pub bits : spdk_nvme_feat_error_recovery__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_error_recovery__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_error_recovery__bindgen_ty_1 { # [ inline ] pub fn tler ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tler ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn dulbe ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dulbe ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tler : u32 , dulbe : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tler : u32 = unsafe { :: std :: mem :: transmute ( tler ) } ; tler as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let dulbe : u32 = unsafe { :: std :: mem :: transmute ( dulbe ) } ; dulbe as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_error_recovery { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_volatile_write_cache { pub raw : u32 , pub bits : spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 { # [ inline ] pub fn wce ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wce ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( wce : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let wce : u32 = unsafe { :: std :: mem :: transmute ( wce ) } ; wce as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_volatile_write_cache { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_number_of_queues { pub raw : u32 , pub bits : spdk_nvme_feat_number_of_queues__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_number_of_queues__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_number_of_queues__bindgen_ty_1 { # [ inline ] pub fn nsqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_nsqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn ncqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ncqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( nsqr : u32 , ncqr : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let nsqr : u32 = unsafe { :: std :: mem :: transmute ( nsqr ) } ; nsqr as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let ncqr : u32 = unsafe { :: std :: mem :: transmute ( ncqr ) } ; ncqr as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_number_of_queues { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_interrupt_vector_configuration { pub raw : u32 , pub bits : spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 { # [ inline ] pub fn iv ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_iv ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn cd ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cd ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( iv : u32 , cd : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let iv : u32 = unsafe { :: std :: mem :: transmute ( iv ) } ; iv as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let cd : u32 = unsafe { :: std :: mem :: transmute ( cd ) } ; cd as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_interrupt_vector_configuration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_write_atomicity { pub raw : u32 , pub bits : spdk_nvme_feat_write_atomicity__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_write_atomicity__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_write_atomicity__bindgen_ty_1 { # [ inline ] pub fn dn ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dn ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( dn : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let dn : u32 = unsafe { :: std :: mem :: transmute ( dn ) } ; dn as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_write_atomicity { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_async_event_configuration { pub raw : u32 , pub bits : spdk_nvme_feat_async_event_configuration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { pub crit_warn : spdk_nvme_critical_warning_state , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl Default for spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { # [ inline ] pub fn ns_attr_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ns_attr_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fw_activation_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fw_activation_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn telemetry_log_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_telemetry_log_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ns_attr_notice : u32 , fw_activation_notice : u32 , telemetry_log_notice : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ns_attr_notice : u32 = unsafe { :: std :: mem :: transmute ( ns_attr_notice ) } ; ns_attr_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let fw_activation_notice : u32 = unsafe { :: std :: mem :: transmute ( fw_activation_notice ) } ; fw_activation_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let telemetry_log_notice : u32 = unsafe { :: std :: mem :: transmute ( telemetry_log_notice ) } ; telemetry_log_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 21u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_async_event_configuration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_autonomous_power_state_transition { pub raw : u32 , pub bits : spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 { # [ inline ] pub fn apste ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_apste ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( apste : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let apste : u32 = unsafe { :: std :: mem :: transmute ( apste ) } ; apste as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_autonomous_power_state_transition { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_mem_buffer { pub raw : u32 , pub bits : spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 { # [ inline ] pub fn ehm ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ehm ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn mr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_mr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ehm : u32 , mr : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ehm : u32 = unsafe { :: std :: mem :: transmute ( ehm ) } ; ehm as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let mr : u32 = unsafe { :: std :: mem :: transmute ( mr ) } ; mr as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_host_mem_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_keep_alive_timer { pub raw : u32 , pub bits : spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 { # [ inline ] pub fn kato ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 32u8 ) as u32 ) } } # [ inline ] pub fn set_kato ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 32u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( kato : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 32u8 , { let kato : u32 = unsafe { :: std :: mem :: transmute ( kato ) } ; kato as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_keep_alive_timer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_controlled_thermal_management { pub raw : u32 , pub bits : spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 { # [ inline ] pub fn tmt2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmt2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn tmt1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmt1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tmt2 : u32 , tmt1 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tmt2 : u32 = unsafe { :: std :: mem :: transmute ( tmt2 ) } ; tmt2 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let tmt1 : u32 = unsafe { :: std :: mem :: transmute ( tmt1 ) } ; tmt1 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_host_controlled_thermal_management { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_non_operational_power_state_config { pub raw : u32 , pub bits : spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 { # [ inline ] pub fn noppme ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_noppme ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( noppme : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let noppme : u32 = unsafe { :: std :: mem :: transmute ( noppme ) } ; noppme as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_non_operational_power_state_config { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_software_progress_marker { pub raw : u32 , pub bits : spdk_nvme_feat_software_progress_marker__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_software_progress_marker__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_software_progress_marker__bindgen_ty_1 { # [ inline ] pub fn pbslc ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_pbslc ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pbslc : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let pbslc : u32 = unsafe { :: std :: mem :: transmute ( pbslc ) } ; pbslc as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_software_progress_marker { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_identifier { pub raw : u32 , pub bits : spdk_nvme_feat_host_identifier__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_identifier__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_host_identifier__bindgen_ty_1 { # [ inline ] pub fn exhid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_exhid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( exhid : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let exhid : u32 = unsafe { :: std :: mem :: transmute ( exhid ) } ; exhid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_host_identifier { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_firmware_page { pub afi : spdk_nvme_firmware_page__bindgen_ty_1 , pub reserved : [ u8 ; 7usize ] , pub revision : [ [ u8 ; 8usize ] ; 7usize ] , pub reserved2 : [ u8 ; 448usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_firmware_page__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_firmware_page__bindgen_ty_1 { # [ inline ] pub fn active_slot ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_active_slot ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn next_reset_slot ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_next_reset_slot ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved7 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved7 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( active_slot : u8 , reserved3 : u8 , next_reset_slot : u8 , reserved7 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let active_slot : u8 = unsafe { :: std :: mem :: transmute ( active_slot ) } ; active_slot as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let next_reset_slot : u8 = unsafe { :: std :: mem :: transmute ( next_reset_slot ) } ; next_reset_slot as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved7 : u8 = unsafe { :: std :: mem :: transmute ( reserved7 ) } ; reserved7 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_firmware_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_ATTACH : spdk_nvme_ns_attach_type = 0 ; pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_DETACH : spdk_nvme_ns_attach_type = 1 ; pub type spdk_nvme_ns_attach_type = u32 ; pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_CREATE : spdk_nvme_ns_management_type = 0 ; pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_DELETE : spdk_nvme_ns_management_type = 1 ; pub type spdk_nvme_ns_management_type = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ns_list { pub ns_list : [ u32 ; 1024usize ] , } impl Default for spdk_nvme_ns_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_nidt_SPDK_NVME_NIDT_EUI64 : spdk_nvme_nidt = 1 ; pub const spdk_nvme_nidt_SPDK_NVME_NIDT_NGUID : spdk_nvme_nidt = 2 ; pub const spdk_nvme_nidt_SPDK_NVME_NIDT_UUID : spdk_nvme_nidt = 3 ; pub type spdk_nvme_nidt = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_nvme_ns_id_desc { pub nidt : u8 , pub nidl : u8 , pub reserved2 : u8 , pub reserved3 : u8 , pub nid : __IncompleteArrayField < u8 > , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_list { pub ctrlr_count : u16 , pub ctrlr_list : [ u16 ; 2047usize ] , } impl Default for spdk_nvme_ctrlr_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE : spdk_nvme_secure_erase_setting = 0 ; pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE : spdk_nvme_secure_erase_setting = 1 ; pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE : spdk_nvme_secure_erase_setting = 2 ; pub type spdk_nvme_secure_erase_setting = u32 ; pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL : spdk_nvme_pi_location = 0 ; pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD : spdk_nvme_pi_location = 1 ; pub type spdk_nvme_pi_location = u32 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_DISABLE : spdk_nvme_pi_type = 0 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE1 : spdk_nvme_pi_type = 1 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE2 : spdk_nvme_pi_type = 2 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE3 : spdk_nvme_pi_type = 3 ; pub type spdk_nvme_pi_type = u32 ; pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER : spdk_nvme_metadata_setting = 0 ; pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA : spdk_nvme_metadata_setting = 1 ; pub type spdk_nvme_metadata_setting = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_format { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_format { # [ inline ] pub fn lbaf ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_lbaf ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ms ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ms ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pi ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_pi ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn pil ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_pil ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ses ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ses ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( lbaf : u32 , ms : u32 , pi : u32 , pil : u32 , ses : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let lbaf : u32 = unsafe { :: std :: mem :: transmute ( lbaf ) } ; lbaf as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ms : u32 = unsafe { :: std :: mem :: transmute ( ms ) } ; ms as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let pi : u32 = unsafe { :: std :: mem :: transmute ( pi ) } ; pi as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let pil : u32 = unsafe { :: std :: mem :: transmute ( pil ) } ; pil as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let ses : u32 = unsafe { :: std :: mem :: transmute ( ses ) } ; ses as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_protection_info { pub guard : u16 , pub app_tag : u16 , pub ref_tag : u32 , } pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_IMG : spdk_nvme_fw_commit_action = 0 ; pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG : spdk_nvme_fw_commit_action = 1 ; pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_ENABLE_IMG : spdk_nvme_fw_commit_action = 2 ; pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_RUN_IMG : spdk_nvme_fw_commit_action = 3 ; pub type spdk_nvme_fw_commit_action = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_fw_commit { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_fw_commit { # [ inline ] pub fn fs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_fs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( fs : u32 , ca : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let fs : u32 = unsafe { :: std :: mem :: transmute ( fs ) } ; fs as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let ca : u32 = unsafe { :: std :: mem :: transmute ( ca ) } ; ca as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_capsule_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 35usize ] , pub fabric_specific : [ u8 ; 24usize ] , } impl Default for spdk_nvmf_capsule_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_PROPERTY_SET : spdk_nvmf_fabric_cmd_types = 0 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_CONNECT : spdk_nvmf_fabric_cmd_types = 1 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_PROPERTY_GET : spdk_nvmf_fabric_cmd_types = 4 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_AUTHENTICATION_SEND : spdk_nvmf_fabric_cmd_types = 5 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_AUTHENTICATION_RECV : spdk_nvmf_fabric_cmd_types = 6 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_START_VENDOR_SPECIFIC : spdk_nvmf_fabric_cmd_types = 192 ; pub type spdk_nvmf_fabric_cmd_types = u32 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INCOMPATIBLE_FORMAT : spdk_nvmf_fabric_cmd_status_code = 128 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_CONTROLLER_BUSY : spdk_nvmf_fabric_cmd_status_code = 129 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INVALID_PARAM : spdk_nvmf_fabric_cmd_status_code = 130 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_RESTART_DISCOVERY : spdk_nvmf_fabric_cmd_status_code = 131 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INVALID_HOST : spdk_nvmf_fabric_cmd_status_code = 132 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_LOG_RESTART_DISCOVERY : spdk_nvmf_fabric_cmd_status_code = 144 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_AUTH_REQUIRED : spdk_nvmf_fabric_cmd_status_code = 145 ; pub type spdk_nvmf_fabric_cmd_status_code = u32 ; pub const spdk_nvmf_rdma_qptype_SPDK_NVMF_RDMA_QPTYPE_RELIABLE_CONNECTED : spdk_nvmf_rdma_qptype = 1 ; pub const spdk_nvmf_rdma_qptype_SPDK_NVMF_RDMA_QPTYPE_RELIABLE_DATAGRAM : spdk_nvmf_rdma_qptype = 2 ; pub type spdk_nvmf_rdma_qptype = u32 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_NONE : spdk_nvmf_rdma_prtype = 1 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_IB : spdk_nvmf_rdma_prtype = 2 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_ROCE : spdk_nvmf_rdma_prtype = 3 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_ROCE2 : spdk_nvmf_rdma_prtype = 4 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_IWARP : spdk_nvmf_rdma_prtype = 5 ; pub type spdk_nvmf_rdma_prtype = u32 ; pub const spdk_nvmf_rdma_cms_SPDK_NVMF_RDMA_CMS_RDMA_CM : spdk_nvmf_rdma_cms = 1 ; pub type spdk_nvmf_rdma_cms = u32 ; pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_RDMA : spdk_nvmf_trtype = 1 ; pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_FC : spdk_nvmf_trtype = 2 ; pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_INTRA_HOST : spdk_nvmf_trtype = 254 ; pub type spdk_nvmf_trtype = u32 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV4 : spdk_nvmf_adrfam = 1 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV6 : spdk_nvmf_adrfam = 2 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IB : spdk_nvmf_adrfam = 3 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_FC : spdk_nvmf_adrfam = 4 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_INTRA_HOST : spdk_nvmf_adrfam = 254 ; pub type spdk_nvmf_adrfam = u32 ; pub const spdk_nvmf_subtype_SPDK_NVMF_SUBTYPE_DISCOVERY : spdk_nvmf_subtype = 1 ; pub const spdk_nvmf_subtype_SPDK_NVMF_SUBTYPE_NVME : spdk_nvmf_subtype = 2 ; pub type spdk_nvmf_subtype = u32 ; pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_NOT_SPECIFIED : spdk_nvmf_treq_secure_channel = 0 ; pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_REQUIRED : spdk_nvmf_treq_secure_channel = 1 ; pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_NOT_REQUIRED : spdk_nvmf_treq_secure_channel = 2 ; pub type spdk_nvmf_treq_secure_channel = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_auth_recv_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub reserved3 : u8 , pub spsp0 : u8 , pub spsp1 : u8 , pub secp : u8 , pub al : u32 , pub reserved4 : [ u8 ; 16usize ] , } impl Default for spdk_nvmf_fabric_auth_recv_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_auth_send_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub reserved3 : u8 , pub spsp0 : u8 , pub spsp1 : u8 , pub secp : u8 , pub tl : u32 , pub reserved4 : [ u8 ; 16usize ] , } impl Default for spdk_nvmf_fabric_auth_send_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_data { pub hostid : [ u8 ; 16usize ] , pub cntlid : u16 , pub reserved5 : [ u8 ; 238usize ] , pub subnqn : [ u8 ; 256usize ] , pub hostnqn : [ u8 ; 256usize ] , pub reserved6 : [ u8 ; 256usize ] , } impl Default for spdk_nvmf_fabric_connect_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub recfmt : u16 , pub qid : u16 , pub sqsize : u16 , pub cattr : u8 , pub reserved3 : u8 , pub kato : u32 , pub reserved4 : [ u8 ; 12usize ] , } impl Default for spdk_nvmf_fabric_connect_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp { pub status_code_specific : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 , pub reserved0 : u32 , pub sqhd : u16 , pub reserved1 : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 { pub success : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 , pub invalid : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 , pub raw : u32 , _bindgen_union_align : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 { pub cntlid : u16 , pub authreq : u16 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 { pub ipo : u16 , pub iattr : u8 , pub reserved : u8 , } impl Default for spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvmf_fabric_connect_rsp { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 35usize ] , pub attrib : spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 , pub reserved3 : [ u8 ; 3usize ] , pub ofst : u32 , pub reserved4 : [ u8 ; 16usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 { # [ inline ] pub fn size ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_size ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( size : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let size : u8 = unsafe { :: std :: mem :: transmute ( size ) } ; size as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvmf_fabric_prop_get_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_rsp { pub value : spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 , pub sqhd : u16 , pub reserved0 : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 { pub u64 : u64 , pub u32 : spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 { pub low : u32 , pub high : u32 , } impl Default for spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvmf_fabric_prop_get_rsp { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd { pub opcode : u8 , pub reserved0 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved1 : [ u8 ; 35usize ] , pub attrib : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 , pub reserved2 : [ u8 ; 3usize ] , pub ofst : u32 , pub value : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 , pub reserved4 : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 { # [ inline ] pub fn size ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_size ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( size : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let size : u8 = unsafe { :: std :: mem :: transmute ( size ) } ; size as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 { pub u64 : u64 , pub u32 : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 { pub low : u32 , pub high : u32 , } impl Default for spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvmf_fabric_prop_set_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_rdma_transport_specific_address_subtype { pub rdma_qptype : u8 , pub rdma_prtype : u8 , pub rdma_cms : u8 , pub reserved0 : [ u8 ; 5usize ] , pub rdma_pkey : u16 , pub reserved2 : [ u8 ; 246usize ] , } impl Default for spdk_nvmf_rdma_transport_specific_address_subtype { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_transport_specific_address_subtype { pub raw : [ u8 ; 256usize ] , pub rdma : spdk_nvmf_rdma_transport_specific_address_subtype , _bindgen_union_align : [ u8 ; 256usize ] , } impl Default for spdk_nvmf_transport_specific_address_subtype { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_discovery_log_page_entry { pub trtype : u8 , pub adrfam : u8 , pub subtype : u8 , pub treq : spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 , pub portid : u16 , pub cntlid : u16 , pub asqsz : u16 , pub reserved0 : [ u8 ; 22usize ] , pub trsvcid : [ u8 ; 32usize ] , pub reserved1 : [ u8 ; 192usize ] , pub subnqn : [ u8 ; 256usize ] , pub traddr : [ u8 ; 256usize ] , pub tsas : spdk_nvmf_transport_specific_address_subtype , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 { # [ inline ] pub fn secure_channel ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_secure_channel ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( secure_channel : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let secure_channel : u8 = unsafe { :: std :: mem :: transmute ( secure_channel ) } ; secure_channel as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvmf_discovery_log_page_entry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] pub struct spdk_nvmf_discovery_log_page { pub genctr : u64 , pub numrec : u64 , pub recfmt : u16 , pub reserved0 : [ u8 ; 1006usize ] , pub entries : __IncompleteArrayField < spdk_nvmf_discovery_log_page_entry > , } impl Default for spdk_nvmf_discovery_log_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_request_private_data { pub recfmt : u16 , pub qid : u16 , pub hrqsize : u16 , pub hsqsize : u16 , pub cntlid : u16 , pub reserved : [ u8 ; 22usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_accept_private_data { pub recfmt : u16 , pub crqsize : u16 , pub reserved : [ u8 ; 28usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_reject_private_data { pub recfmt : u16 , pub sts : u16 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_rdma_private_data { pub pd_request : spdk_nvmf_rdma_request_private_data , pub pd_accept : spdk_nvmf_rdma_accept_private_data , pub pd_reject : spdk_nvmf_rdma_reject_private_data , _bindgen_union_align : [ u8 ; 32usize ] , } impl Default for spdk_nvmf_rdma_private_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_PRIVATE_DATA_LENGTH : spdk_nvmf_rdma_transport_error = 1 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_RECFMT : spdk_nvmf_rdma_transport_error = 2 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_QID : spdk_nvmf_rdma_transport_error = 3 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_HSQSIZE : spdk_nvmf_rdma_transport_error = 4 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_HRQSIZE : spdk_nvmf_rdma_transport_error = 5 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_NO_RESOURCES : spdk_nvmf_rdma_transport_error = 6 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_IRD : spdk_nvmf_rdma_transport_error = 7 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_ORD : spdk_nvmf_rdma_transport_error = 8 ; pub type spdk_nvmf_rdma_transport_error = u32 ; # [ doc = " Opaque handle to a controller. Returned by spdk_nvme_probe()\'s attach_cb." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_ctrlr { _unused : [ u8 ; 0 ] , } # [ doc = " NVMe controller initialization options." ] # [ doc = "" ] # [ doc = " A pointer to this structure will be provided for each probe callback from spdk_nvme_probe() to" ] # [ doc = " allow the user to request non-default options, and the actual options enabled on the controller" ] # [ doc = " will be provided during the attach callback." ] # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_opts { # [ doc = " Number of I/O queues to request (used to set Number of Queues feature)" ] pub num_io_queues : u32 , # [ doc = " Enable submission queue in controller memory buffer" ] pub use_cmb_sqs : bool , # [ doc = " Type of arbitration mechanism" ] pub arb_mechanism : spdk_nvme_cc_ams , # [ doc = " Keep alive timeout in milliseconds (0 = disabled)." ] # [ doc = "" ] # [ doc = " The NVMe library will set the Keep Alive Timer feature to this value and automatically" ] # [ doc = " send Keep Alive commands as needed.  The library user must call" ] # [ doc = " spdk_nvme_ctrlr_process_admin_completions() periodically to ensure Keep Alive commands" ] # [ doc = " are sent." ] pub keep_alive_timeout_ms : u32 , # [ doc = " Specify the retry number when there is issue with the transport" ] pub transport_retry_count : libc :: c_int , # [ doc = " The queue depth of each NVMe I/O queue." ] pub io_queue_size : u32 , # [ doc = " The host NQN to use when connecting to NVMe over Fabrics controllers." ] # [ doc = "" ] # [ doc = " Unused for local PCIe-attached NVMe devices." ] pub hostnqn : [ libc :: c_char ; 224usize ] , # [ doc = " The number of requests to allocate for each NVMe I/O queue." ] # [ doc = "" ] # [ doc = " This should be at least as large as io_queue_size." ] # [ doc = "" ] # [ doc = " A single I/O may allocate more than one request, since splitting may be necessary to" ] # [ doc = " conform to the device\'s maximum transfer size, PRP list compatibility requirements," ] # [ doc = " or driver-assisted striping." ] pub io_queue_requests : u32 , # [ doc = " Source address for NVMe-oF connections." ] # [ doc = " Set src_addr and src_svcid to empty strings if no source address should be" ] # [ doc = " specified." ] pub src_addr : [ libc :: c_char ; 257usize ] , # [ doc = " Source service ID (port) for NVMe-oF connections." ] # [ doc = " Set src_addr and src_svcid to empty strings if no source address should be" ] # [ doc = " specified." ] pub src_svcid : [ libc :: c_char ; 33usize ] , # [ doc = " The host identifier to use when connecting to controllers with 64-bit host ID support." ] # [ doc = "" ] # [ doc = " Set to all zeroes to specify that no host ID should be provided to the controller." ] pub host_id : [ u8 ; 8usize ] , # [ doc = " The host identifier to use when connecting to controllers with extended (128-bit) host ID support." ] # [ doc = "" ] # [ doc = " Set to all zeroes to specify that no host ID should be provided to the controller." ] pub extended_host_id : [ u8 ; 16usize ] , # [ doc = " The I/O command set to select." ] # [ doc = "" ] # [ doc = " If the requested command set is not supported, the controller" ] # [ doc = " initialization process will not proceed. By default, the NVM" ] # [ doc = " command set is used." ] pub command_set : spdk_nvme_cc_css , } impl Default for spdk_nvme_ctrlr_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ doc = " Get the default options for the creation of a specific NVMe controller." ] # [ doc = "" ] # [ doc = " \\param[out] opts Will be filled with the default option." ] # [ doc = " \\param opts_size Must be set to sizeof(struct spdk_nvme_ctrlr_opts)." ] pub fn spdk_nvme_ctrlr_get_default_ctrlr_opts ( opts : * mut spdk_nvme_ctrlr_opts , opts_size : usize ) ; } # [ doc = " PCIe Transport (locally attached devices)" ] pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_PCIE : spdk_nvme_transport_type = 256 ; # [ doc = " RDMA Transport (RoCE, iWARP, etc.)" ] pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_RDMA : spdk_nvme_transport_type = 1 ; # [ doc = " Fibre Channel (FC) Transport" ] pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_FC : spdk_nvme_transport_type = 2 ; # [ doc = " NVMe library transports" ] # [ doc = "" ] # [ doc = " NOTE: These are mapped directly to the NVMe over Fabrics TRTYPE values, except for PCIe," ] # [ doc = " which is a special case since NVMe over Fabrics does not define a TRTYPE for local PCIe." ] # [ doc = "" ] # [ doc = " Currently, this uses 256 for PCIe which is intentionally outside of the 8-bit range of TRTYPE." ] # [ doc = " If the NVMe-oF specification ever defines a PCIe TRTYPE, this should be updated." ] pub type spdk_nvme_transport_type = u32 ; # [ doc = " NVMe transport identifier." ] # [ doc = "" ] # [ doc = " This identifies a unique endpoint on an NVMe fabric." ] # [ doc = "" ] # [ doc = " A string representation of a transport ID may be converted to this type using" ] # [ doc = " spdk_nvme_transport_id_parse()." ] # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_transport_id { # [ doc = " NVMe transport type." ] pub trtype : spdk_nvme_transport_type , # [ doc = " Address family of the transport address." ] # [ doc = "" ] # [ doc = " For PCIe, this value is ignored." ] pub adrfam : spdk_nvmf_adrfam , # [ doc = " Transport address of the NVMe-oF endpoint. For transports which use IP" ] # [ doc = " addressing (e.g. RDMA), this should be an IP address. For PCIe, this" ] # [ doc = " can either be a zero length string (the whole bus) or a PCI address" ] # [ doc = " in the format DDDD:BB:DD.FF or DDDD.BB.DD.FF. For FC the string is" ] # [ doc = " formatted as: nn-0xWWNN:pn-0xWWPN\u{201d} where WWNN is the Node_Name of the" ] # [ doc = " target NVMe_Port and WWPN is the N_Port_Name of the target NVMe_Port." ] pub traddr : [ libc :: c_char ; 257usize ] , # [ doc = " Transport service id of the NVMe-oF endpoint.  For transports which use" ] # [ doc = " IP addressing (e.g. RDMA), this field shoud be the port number. For PCIe," ] # [ doc = " and FC this is always a zero length string." ] pub trsvcid : [ libc :: c_char ; 33usize ] , # [ doc = " Subsystem NQN of the NVMe over Fabrics endpoint. May be a zero length string." ] pub subnqn : [ libc :: c_char ; 224usize ] , } impl Default for spdk_nvme_transport_id { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ doc = " Parse the string representation of a transport ID." ] # [ doc = "" ] # [ doc = " \\param trid Output transport ID structure (must be allocated and initialized by caller)." ] # [ doc = " \\param str Input string representation of a transport ID to parse." ] # [ doc = "" ] # [ doc = " str must be a zero-terminated C string containing one or more key:value pairs" ] # [ doc = " separated by whitespace." ] # [ doc = "" ] # [ doc = " Key          | Value" ] # [ doc = " ------------ | -----" ] # [ doc = " trtype       | Transport type (e.g. PCIe, RDMA)" ] # [ doc = " adrfam       | Address family (e.g. IPv4, IPv6)" ] # [ doc = " traddr       | Transport address (e.g. 0000:04:00.0 for PCIe, 192.168.100.8 for RDMA, or WWN for FC)" ] # [ doc = " trsvcid      | Transport service identifier (e.g. 4420)" ] # [ doc = " subnqn       | Subsystem NQN" ] # [ doc = "" ] # [ doc = " Unspecified fields of trid are left unmodified, so the caller must initialize" ] # [ doc = " trid (for example, memset() to 0) before calling this function." ] # [ doc = "" ] # [ doc = " \\return 0 if parsing was successful and trid is filled out, or negated errno" ] # [ doc = " values on failure." ] pub fn spdk_nvme_transport_id_parse ( trid : * mut spdk_nvme_transport_id , str : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { # [ doc = " Parse the string representation of a transport ID tranport type." ] # [ doc = "" ] # [ doc = " \\param trtype Output transport type (allocated by caller)." ] # [ doc = " \\param str Input string representation of transport type (e.g. \"PCIe\", \"RDMA\")." ] # [ doc = "" ] # [ doc = " \\return 0 if parsing was successful and trtype is filled out, or negated errno" ] # [ doc = " values on failure." ] pub fn spdk_nvme_transport_id_parse_trtype ( trtype : * mut spdk_nvme_transport_type , str : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { # [ doc = " Look up the string representation of a transport ID transport type." ] # [ doc = "" ] # [ doc = " \\param trtype Transport type to convert." ] # [ doc = "" ] # [ doc = " \\return static string constant describing trtype, or NULL if trtype not found." ] pub fn spdk_nvme_transport_id_trtype_str ( trtype : spdk_nvme_transport_type ) -> * const libc :: c_char ; } extern "C" { # [ doc = " Look up the string representation of a transport ID address family." ] # [ doc = "" ] # [ doc = " \\param adrfam Address family to convert." ] # [ doc = "" ] # [ doc = " \\return static string constant describing adrfam, or NULL if adrmfam not found." ] pub fn spdk_nvme_transport_id_adrfam_str ( adrfam : spdk_nvmf_adrfam ) -> * const libc :: c_char ; } extern "C" { # [ doc = " Parse the string representation of a tranport ID address family." ] # [ doc = "" ] # [ doc = " \\param adrfam Output address family (allocated by caller)." ] # [ doc = " \\param str Input string representation of address family (e.g. \"IPv4\", \"IPv6\")." ] # [ doc = "" ] # [ doc = " \\return 0 if parsing was successful and adrfam is filled out, or negated errno" ] # [ doc = " values on failure." ] pub fn spdk_nvme_transport_id_parse_adrfam ( adrfam : * mut spdk_nvmf_adrfam , str : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { # [ doc = " Compare two transport IDs." ] # [ doc = "" ] # [ doc = " The result of this function may be used to sort transport IDs in a consistent" ] # [ doc = " order; however, the comparison result is not guaranteed to be consistent across" ] # [ doc = " library versions." ] # [ doc = "" ] # [ doc = " This function uses a case-insensitive comparison for string fields, but it does" ] # [ doc = " not otherwise normalize the transport ID. It is the caller\'s responsibility to" ] # [ doc = " provide the transport IDs in a consistent format." ] # [ doc = "" ] # [ doc = " \\param trid1 First transport ID to compare." ] # [ doc = " \\param trid2 Second transport ID to compare." ] # [ doc = "" ] # [ doc = " \\return 0 if trid1 == trid2, less than 0 if trid1 < trid2, greater than 0 if" ] # [ doc = " trid1 > trid2." ] pub fn spdk_nvme_transport_id_compare ( trid1 : * const spdk_nvme_transport_id , trid2 : * const spdk_nvme_transport_id ) -> libc :: c_int ; } extern "C" { # [ doc = " Determine whether the NVMe library can handle a specific NVMe over Fabrics" ] # [ doc = " transport type." ] # [ doc = "" ] # [ doc = " \\param trtype NVMe over Fabrics transport type to check." ] # [ doc = "" ] # [ doc = " \\return true if trtype is supported or false if it is not supported." ] pub fn spdk_nvme_transport_available ( trtype : spdk_nvme_transport_type ) -> bool ; } # [ doc = " Callback for spdk_nvme_probe() enumeration." ] # [ doc = "" ] # [ doc = " \\param cb_ctx Opaque value passed to spdk_nvme_probe()." ] # [ doc = " \\param trid NVMe transport identifier." ] # [ doc = " \\param opts NVMe controller initialization options. This structure will be" ] # [ doc = " populated with the default values on entry, and the user callback may update" ] # [ doc = " any options to request a different value. The controller may not support all" ] # [ doc = " requested parameters, so the final values will be provided during the attach" ] # [ doc = " callback." ] # [ doc = "" ] # [ doc = " \\return true to attach to this device." ] pub type spdk_nvme_probe_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , trid : * const spdk_nvme_transport_id , opts : * mut spdk_nvme_ctrlr_opts ) -> bool > ; # [ doc = " Callback for spdk_nvme_attach() to report a device that has been attached to" ] # [ doc = " the userspace NVMe driver." ] # [ doc = "" ] # [ doc = " \\param cb_ctx Opaque value passed to spdk_nvme_attach_cb()." ] # [ doc = " \\param trid NVMe transport identifier." ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param opts NVMe controller initialization options that were actually used." ] # [ doc = " Options may differ from the requested options from the attach call depending" ] # [ doc = " on what the controller supports." ] pub type spdk_nvme_attach_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , trid : * const spdk_nvme_transport_id , ctrlr : * mut spdk_nvme_ctrlr , opts : * const spdk_nvme_ctrlr_opts ) > ; # [ doc = " Callback for spdk_nvme_remove() to report that a device attached to the userspace" ] # [ doc = " NVMe driver has been removed from the system." ] # [ doc = "" ] # [ doc = " The controller will remain in a failed state (any new I/O submitted will fail)." ] # [ doc = "" ] # [ doc = " The controller must be detached from the userspace driver by calling spdk_nvme_detach()" ] # [ doc = " once the controller is no longer in use. It is up to the library user to ensure" ] # [ doc = " that no other threads are using the controller before calling spdk_nvme_detach()." ] # [ doc = "" ] # [ doc = " \\param cb_ctx Opaque value passed to spdk_nvme_remove_cb()." ] # [ doc = " \\param ctrlr NVMe controller instance that was removed." ] pub type spdk_nvme_remove_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , ctrlr : * mut spdk_nvme_ctrlr ) > ; extern "C" { # [ doc = " Enumerate the bus indicated by the transport ID and attach the userspace NVMe" ] # [ doc = " driver to each device found if desired." ] # [ doc = "" ] # [ doc = " This function is not thread safe and should only be called from one thread at" ] # [ doc = " a time while no other threads are actively using any NVMe devices." ] # [ doc = "" ] # [ doc = " If called from a secondary process, only devices that have been attached to" ] # [ doc = " the userspace driver in the primary process will be probed." ] # [ doc = "" ] # [ doc = " If called more than once, only devices that are not already attached to the" ] # [ doc = " SPDK NVMe driver will be reported." ] # [ doc = "" ] # [ doc = " To stop using the the controller and release its associated resources," ] # [ doc = " call spdk_nvme_detach() with the spdk_nvme_ctrlr instance from the attach_cb()" ] # [ doc = " function." ] # [ doc = "" ] # [ doc = " \\param trid The transport ID indicating which bus to enumerate. If the trtype" ] # [ doc = " is PCIe or trid is NULL, this will scan the local PCIe bus. If the trtype is" ] # [ doc = " RDMA, the traddr and trsvcid must point at the location of an NVMe-oF discovery" ] # [ doc = " service." ] # [ doc = " \\param cb_ctx Opaque value which will be passed back in cb_ctx parameter of" ] # [ doc = " the callbacks." ] # [ doc = " \\param probe_cb will be called once per NVMe device found in the system." ] # [ doc = " \\param attach_cb will be called for devices for which probe_cb returned true" ] # [ doc = " once that NVMe controller has been attached to the userspace driver." ] # [ doc = " \\param remove_cb will be called for devices that were attached in a previous" ] # [ doc = " spdk_nvme_probe() call but are no longer attached to the system. Optional;" ] # [ doc = " specify NULL if removal notices are not desired." ] # [ doc = "" ] # [ doc = " \\return 0 on success, -1 on failure." ] pub fn spdk_nvme_probe ( trid : * const spdk_nvme_transport_id , cb_ctx : * mut libc :: c_void , probe_cb : spdk_nvme_probe_cb , attach_cb : spdk_nvme_attach_cb , remove_cb : spdk_nvme_remove_cb ) -> libc :: c_int ; } extern "C" { # [ doc = " Connect the NVMe driver to the device located at the given transport ID." ] # [ doc = "" ] # [ doc = " This function is not thread safe and should only be called from one thread at" ] # [ doc = " a time while no other threads are actively using this NVMe device." ] # [ doc = "" ] # [ doc = " If called from a secondary process, only the device that has been attached to" ] # [ doc = " the userspace driver in the primary process will be connected." ] # [ doc = "" ] # [ doc = " If connecting to multiple controllers, it is suggested to use spdk_nvme_probe()" ] # [ doc = " and filter the requested controllers with the probe callback. For PCIe controllers," ] # [ doc = " spdk_nvme_probe() will be more efficient since the controller resets will happen" ] # [ doc = " in parallel." ] # [ doc = "" ] # [ doc = " To stop using the the controller and release its associated resources, call" ] # [ doc = " spdk_nvme_detach() with the spdk_nvme_ctrlr instance returned by this function." ] # [ doc = "" ] # [ doc = " \\param trid The transport ID indicating which device to connect. If the trtype" ] # [ doc = " is PCIe, this will connect the local PCIe bus. If the trtype is RDMA, the traddr" ] # [ doc = " and trsvcid must point at the location of an NVMe-oF service." ] # [ doc = " \\param opts NVMe controller initialization options. Default values will be used" ] # [ doc = " if the user does not specify the options. The controller may not support all" ] # [ doc = " requested parameters." ] # [ doc = " \\param opts_size Must be set to sizeof(struct spdk_nvme_ctrlr_opts), or 0 if" ] # [ doc = " opts is NULL." ] # [ doc = "" ] # [ doc = " \\return pointer to the connected NVMe controller or NULL if there is any failure." ] # [ doc = "" ] pub fn spdk_nvme_connect ( trid : * const spdk_nvme_transport_id , opts : * const spdk_nvme_ctrlr_opts , opts_size : usize ) -> * mut spdk_nvme_ctrlr ; } extern "C" { # [ doc = " Detach specified device returned by spdk_nvme_probe()\'s attach_cb from the" ] # [ doc = " NVMe driver." ] # [ doc = "" ] # [ doc = " On success, the spdk_nvme_ctrlr handle is no longer valid." ] # [ doc = "" ] # [ doc = " This function should be called from a single thread while no other threads" ] # [ doc = " are actively using the NVMe device." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return 0 on success, -1 on failure." ] pub fn spdk_nvme_detach ( ctrlr : * mut spdk_nvme_ctrlr ) -> libc :: c_int ; } extern "C" { # [ doc = " Perform a full hardware reset of the NVMe controller." ] # [ doc = "" ] # [ doc = " This function should be called from a single thread while no other threads" ] # [ doc = " are actively using the NVMe device." ] # [ doc = "" ] # [ doc = " Any pointers returned from spdk_nvme_ctrlr_get_ns() and spdk_nvme_ns_get_data()" ] # [ doc = " may be invalidated by calling this function. The number of namespaces as returned" ] # [ doc = " by spdk_nvme_ctrlr_get_num_ns() may also change." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return 0 on success, -1 on failure." ] pub fn spdk_nvme_ctrlr_reset ( ctrlr : * mut spdk_nvme_ctrlr ) -> libc :: c_int ; } extern "C" { # [ doc = " Get the identify controller data as defined by the NVMe specification." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return pointer to the identify controller data." ] pub fn spdk_nvme_ctrlr_get_data ( ctrlr : * mut spdk_nvme_ctrlr ) -> * const spdk_nvme_ctrlr_data ; } extern "C" { # [ doc = " Get the NVMe controller CSTS (Status) register." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return the NVMe controller CSTS (Status) register." ] pub fn spdk_nvme_ctrlr_get_regs_csts ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_csts_register ; } extern "C" { # [ doc = " Get the NVMe controller CAP (Capabilities) register." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return the NVMe controller CAP (Capabilities) register." ] pub fn spdk_nvme_ctrlr_get_regs_cap ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_cap_register ; } extern "C" { # [ doc = " Get the NVMe controller VS (Version) register." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return the NVMe controller VS (Version) register." ] pub fn spdk_nvme_ctrlr_get_regs_vs ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_vs_register ; } extern "C" { # [ doc = " Get the number of namespaces for the given NVMe controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the" ] # [ doc = " controller is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " This is equivalent to calling spdk_nvme_ctrlr_get_data() to get the" ] # [ doc = " spdk_nvme_ctrlr_data and then reading the nn field." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return the number of namespaces." ] pub fn spdk_nvme_ctrlr_get_num_ns ( ctrlr : * mut spdk_nvme_ctrlr ) -> u32 ; } extern "C" { # [ doc = " Get the PCI device of a given NVMe controller." ] # [ doc = "" ] # [ doc = " This only works for local (PCIe-attached) NVMe controllers; other transports" ] # [ doc = " will return NULL." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return PCI device of the NVMe controller, or NULL if not available." ] pub fn spdk_nvme_ctrlr_get_pci_device ( ctrlr : * mut spdk_nvme_ctrlr ) -> * mut spdk_pci_device ; } extern "C" { # [ doc = " Get the maximum data transfer size of a given NVMe controller." ] # [ doc = "" ] # [ doc = " \\return Maximum data transfer size of the NVMe controller in bytes." ] # [ doc = "" ] # [ doc = " The I/O command helper functions, such as spdk_nvme_ns_cmd_read(), will split" ] # [ doc = " large I/Os automatically; however, it is up to the user to obey this limit for" ] # [ doc = " commands submitted with the raw command functions, such as spdk_nvme_ctrlr_cmd_io_raw()." ] pub fn spdk_nvme_ctrlr_get_max_xfer_size ( ctrlr : * const spdk_nvme_ctrlr ) -> u32 ; } extern "C" { # [ doc = " Check whether the nsid is an active nv for the given NVMe controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param nsid Namespace id." ] # [ doc = "" ] # [ doc = " \\return true if nsid is an active ns, or false otherwise." ] pub fn spdk_nvme_ctrlr_is_active_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 ) -> bool ; } extern "C" { # [ doc = " Get the nsid of the first active namespace." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return the nsid of the first active namespace, 0 if there are no active namespaces." ] pub fn spdk_nvme_ctrlr_get_first_active_ns ( ctrlr : * mut spdk_nvme_ctrlr ) -> u32 ; } extern "C" { # [ doc = " Get next active namespace given the previous nsid." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param prev_nsid Namespace id." ] # [ doc = "" ] # [ doc = " \\return a next active namespace given the previous nsid, 0 when there are no" ] # [ doc = " more active namespaces." ] pub fn spdk_nvme_ctrlr_get_next_active_ns ( ctrlr : * mut spdk_nvme_ctrlr , prev_nsid : u32 ) -> u32 ; } extern "C" { # [ doc = " Determine if a particular log page is supported by the given NVMe controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_ctrlr_cmd_get_log_page()." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param log_page Log page to query." ] # [ doc = "" ] # [ doc = " \\return true if supported, or false otherwise." ] pub fn spdk_nvme_ctrlr_is_log_page_supported ( ctrlr : * mut spdk_nvme_ctrlr , log_page : u8 ) -> bool ; } extern "C" { # [ doc = " Determine if a particular feature is supported by the given NVMe controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_ctrlr_cmd_get_feature()." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param feature_code Feature to query." ] # [ doc = "" ] # [ doc = " \\return true if supported, or false otherwise." ] pub fn spdk_nvme_ctrlr_is_feature_supported ( ctrlr : * mut spdk_nvme_ctrlr , feature_code : u8 ) -> bool ; } # [ doc = " Signature for callback function invoked when a command is completed." ] # [ doc = "" ] # [ doc = " \\param spdk_nvme_cpl Completion queue entry that coontains the completion status." ] pub type spdk_nvme_cmd_cb = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void , arg2 : * const spdk_nvme_cpl ) > ; # [ doc = " Signature for callback function invoked when an asynchronous error request" ] # [ doc = " command is completed." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param aer_cb_arg Context specified by spdk_nvme_register_aer_callback()." ] # [ doc = " \\param spdk_nvme_cpl Completion queue entry that contains the completion status" ] # [ doc = " of the asynchronous event request that was completed." ] pub type spdk_nvme_aer_cb = :: std :: option :: Option < unsafe extern "C" fn ( aer_cb_arg : * mut libc :: c_void , arg1 : * const spdk_nvme_cpl ) > ; extern "C" { # [ doc = " Register callback function invoked when an AER command is completed for the" ] # [ doc = " given NVMe controller." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param aer_cb_fn Callback function invoked when an asynchronous error request" ] # [ doc = " command is completed." ] # [ doc = " \\param aer_cb_arg Argument passed to callback function." ] pub fn spdk_nvme_ctrlr_register_aer_callback ( ctrlr : * mut spdk_nvme_ctrlr , aer_cb_fn : spdk_nvme_aer_cb , aer_cb_arg : * mut libc :: c_void ) ; } # [ doc = " Opaque handle to a queue pair." ] # [ doc = "" ] # [ doc = " I/O queue pairs may be allocated using spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_qpair { _unused : [ u8 ; 0 ] , } # [ doc = " Signature for the callback function invoked when a timeout is detected on a" ] # [ doc = " request." ] # [ doc = "" ] # [ doc = " For timeouts detected on the admin queue pair, the qpair returned here will" ] # [ doc = " be NULL.  If the controller has a serious error condition and is unable to" ] # [ doc = " communicate with driver via completion queue, the controller can set Controller" ] # [ doc = " Fatal Status field to 1, then reset is required to recover from such error." ] # [ doc = " Users may detect Controller Fatal Status when timeout happens." ] # [ doc = "" ] # [ doc = " \\param cb_arg Argument passed to callback funciton." ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param qpair Opaque handle to a queue pair." ] # [ doc = " \\param cid Command ID." ] pub type spdk_nvme_timeout_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cid : u16 ) > ; extern "C" { # [ doc = " Register for timeout callback on a controller." ] # [ doc = "" ] # [ doc = " The application can choose to register for timeout callback or not register" ] # [ doc = " for timeout callback." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller on which to monitor for timeout." ] # [ doc = " \\param timeout_us Timeout value in microseconds." ] # [ doc = " \\param cb_fn A function pointer that points to the callback function." ] # [ doc = " \\param cb_arg Argument to the callback function." ] pub fn spdk_nvme_ctrlr_register_timeout_callback ( ctrlr : * mut spdk_nvme_ctrlr , timeout_us : u64 , cb_fn : spdk_nvme_timeout_cb , cb_arg : * mut libc :: c_void ) ; } # [ doc = " NVMe I/O queue pair initialization options." ] # [ doc = "" ] # [ doc = " These options may be passed to spdk_nvme_ctrlr_alloc_io_qpair() to configure queue pair" ] # [ doc = " options at queue creation time." ] # [ doc = "" ] # [ doc = " The user may retrieve the default I/O queue pair creation options for a controller using" ] # [ doc = " spdk_nvme_ctrlr_get_default_io_qpair_opts()." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_io_qpair_opts { # [ doc = " Queue priority for weighted round robin arbitration.  If a different arbitration" ] # [ doc = " method is in use, pass 0." ] pub qprio : spdk_nvme_qprio , # [ doc = " The queue depth of this NVMe I/O queue. Overrides spdk_nvme_ctrlr_opts::io_queue_size." ] pub io_queue_size : u32 , # [ doc = " The number of requests to allocate for this NVMe I/O queue." ] # [ doc = "" ] # [ doc = " Overrides spdk_nvme_ctrlr_opts::io_queue_requests." ] # [ doc = "" ] # [ doc = " This should be at least as large as io_queue_size." ] # [ doc = "" ] # [ doc = " A single I/O may allocate more than one request, since splitting may be" ] # [ doc = " necessary to conform to the device\'s maximum transfer size, PRP list" ] # [ doc = " compatibility requirements, or driver-assisted striping." ] pub io_queue_requests : u32 , } impl Default for spdk_nvme_io_qpair_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ doc = " Get the default options for I/O qpair creation for a specific NVMe controller." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to retrieve the defaults from." ] # [ doc = " \\param[out] opts Will be filled with the default options for" ] # [ doc = " spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " \\param opts_size Must be set to sizeof(struct spdk_nvme_io_qpair_opts)." ] pub fn spdk_nvme_ctrlr_get_default_io_qpair_opts ( ctrlr : * mut spdk_nvme_ctrlr , opts : * mut spdk_nvme_io_qpair_opts , opts_size : usize ) ; } extern "C" { # [ doc = " Allocate an I/O queue pair (submission and completion queue)." ] # [ doc = "" ] # [ doc = " Each queue pair should only be used from a single thread at a time (mutual" ] # [ doc = " exclusion must be enforced by the user)." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller for which to allocate the I/O queue pair." ] # [ doc = " \\param opts I/O qpair creation options, or NULL to use the defaults as returned" ] # [ doc = " by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " \\param opts_size Must be set to sizeof(struct spdk_nvme_io_qpair_opts), or 0" ] # [ doc = " if opts is NULL." ] # [ doc = "" ] # [ doc = " \\return a pointer to the allocated I/O queue pair." ] pub fn spdk_nvme_ctrlr_alloc_io_qpair ( ctrlr : * mut spdk_nvme_ctrlr , opts : * const spdk_nvme_io_qpair_opts , opts_size : usize ) -> * mut spdk_nvme_qpair ; } extern "C" { # [ doc = " Free an I/O queue pair that was allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = "" ] # [ doc = " \\param qpair I/O queue pair to free." ] # [ doc = "" ] # [ doc = " \\return 0 on success, -1 on failure." ] pub fn spdk_nvme_ctrlr_free_io_qpair ( qpair : * mut spdk_nvme_qpair ) -> libc :: c_int ; } extern "C" { # [ doc = " Send the given NVM I/O command to the NVMe controller." ] # [ doc = "" ] # [ doc = " This is a low level interface for submitting I/O commands directly. Prefer" ] # [ doc = " the spdk_nvme_ns_cmd_* functions instead. The validity of the command will" ] # [ doc = " not be checked!" ] # [ doc = "" ] # [ doc = " When constructing the nvme_command it is not necessary to fill out the PRP" ] # [ doc = " list/SGL or the CID. The driver will handle both of those for you." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param qpair I/O qpair to submit command." ] # [ doc = " \\param cmd NVM I/O command to submit." ] # [ doc = " \\param buf Virtual memory address of a single physically contiguous buffer." ] # [ doc = " \\param len Size of buffer." ] # [ doc = " \\param cb_fn Callback function invoked when the I/O command completes." ] # [ doc = " \\param cb_arg Argument passed to callback function." ] # [ doc = "" ] # [ doc = " \\return 0 on success, negated errno on failure." ] pub fn spdk_nvme_ctrlr_cmd_io_raw ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cmd : * mut spdk_nvme_cmd , buf : * mut libc :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Send the given NVM I/O command with metadata to the NVMe controller." ] # [ doc = "" ] # [ doc = " This is a low level interface for submitting I/O commands directly. Prefer" ] # [ doc = " the spdk_nvme_ns_cmd_* functions instead. The validity of the command will" ] # [ doc = " not be checked!" ] # [ doc = "" ] # [ doc = " When constructing the nvme_command it is not necessary to fill out the PRP" ] # [ doc = " list/SGL or the CID. The driver will handle both of those for you." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param qpair I/O qpair to submit command." ] # [ doc = " \\param cmd NVM I/O command to submit." ] # [ doc = " \\param buf Virtual memory address of a single physically contiguous buffer." ] # [ doc = " \\param len Size of buffer." ] # [ doc = " \\param md_buf Virtual memory address of a single physically contiguous metadata" ] # [ doc = " buffer." ] # [ doc = " \\param cb_fn Callback function invoked when the I/O command completes." ] # [ doc = " \\param cb_arg Argument passed to callback function." ] # [ doc = "" ] # [ doc = " \\return 0 on success, negated errno on failure." ] pub fn spdk_nvme_ctrlr_cmd_io_raw_with_md ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cmd : * mut spdk_nvme_cmd , buf : * mut libc :: c_void , len : u32 , md_buf : * mut libc :: c_void , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Process any outstanding completions for I/O submitted on a queue pair." ] # [ doc = "" ] # [ doc = " This call is non-blocking, i.e. it only processes completions that are ready" ] # [ doc = " at the time of this function call. It does not wait for outstanding commands" ] # [ doc = " to finish." ] # [ doc = "" ] # [ doc = " For each completed command, the request\'s callback function will be called if" ] # [ doc = " specified as non-NULL when the request was submitted." ] # [ doc = "" ] # [ doc = " The caller must ensure that each queue pair is only used from one thread at a" ] # [ doc = " time." ] # [ doc = "" ] # [ doc = " This function may be called at any point while the controller is attached to" ] # [ doc = " the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_cmd_cb" ] # [ doc = "" ] # [ doc = " \\param qpair Queue pair to check for completions." ] # [ doc = " \\param max_completions Limit the number of completions to be processed in one" ] # [ doc = " call, or 0 for unlimited." ] # [ doc = "" ] # [ doc = " \\return number of completions processed (may be 0) or negated on error." ] pub fn spdk_nvme_qpair_process_completions ( qpair : * mut spdk_nvme_qpair , max_completions : u32 ) -> i32 ; } extern "C" { # [ doc = " Send the given admin command to the NVMe controller." ] # [ doc = "" ] # [ doc = " This is a low level interface for submitting admin commands directly. Prefer" ] # [ doc = " the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will" ] # [ doc = " not be checked!" ] # [ doc = "" ] # [ doc = " When constructing the nvme_command it is not necessary to fill out the PRP" ] # [ doc = " list/SGL or the CID. The driver will handle both of those for you." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion" ] # [ doc = " of commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param cmd NVM admin command to submit." ] # [ doc = " \\param buf Virtual memory address of a single physically contiguous buffer." ] # [ doc = " \\param len Size of buffer." ] # [ doc = " \\param cb_fn Callback function invoked when the admin command completes." ] # [ doc = " \\param cb_arg Argument passed to callback function." ] # [ doc = "" ] # [ doc = " \\return 0 on success, negated errno on failure." ] pub fn spdk_nvme_ctrlr_cmd_admin_raw ( ctrlr : * mut spdk_nvme_ctrlr , cmd : * mut spdk_nvme_cmd , buf : * mut libc :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Process any outstanding completions for admin commands." ] # [ doc = "" ] # [ doc = " This will process completions for admin commands submitted on any thread." ] # [ doc = "" ] # [ doc = " This call is non-blocking, i.e. it only processes completions that are ready" ] # [ doc = " at the time of this function call. It does not wait for outstanding commands" ] # [ doc = " to finish." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = "" ] # [ doc = " \\return number of completions processed (may be 0) or negated on error." ] pub fn spdk_nvme_ctrlr_process_admin_completions ( ctrlr : * mut spdk_nvme_ctrlr ) -> i32 ; } # [ doc = " Opaque handle to a namespace. Obtained by calling spdk_nvme_ctrlr_get_ns()." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_ns { _unused : [ u8 ; 0 ] , } extern "C" { # [ doc = " Get a handle to a namespace for the given controller." ] # [ doc = "" ] # [ doc = " Namespaces are numbered from 1 to the total number of namespaces. There will" ] # [ doc = " never be any gaps in the numbering. The number of namespaces is obtained by" ] # [ doc = " calling spdk_nvme_ctrlr_get_num_ns()." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param ns_id Namespace id." ] # [ doc = "" ] # [ doc = " \\return a pointer to the namespace." ] pub fn spdk_nvme_ctrlr_get_ns ( ctrlr : * mut spdk_nvme_ctrlr , ns_id : u32 ) -> * mut spdk_nvme_ns ; } extern "C" { # [ doc = " Get a specific log page from the NVMe controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of" ] # [ doc = " commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_ctrlr_is_log_page_supported()" ] # [ doc = "" ] # [ doc = " \\param ctrlr Opaque handle to NVMe controller." ] # [ doc = " \\param log_page The log page identifier." ] # [ doc = " \\param nsid Depending on the log page, this may be 0, a namespace identifier," ] # [ doc = " or SPDK_NVME_GLOBAL_NS_TAG." ] # [ doc = " \\param payload The pointer to the payload buffer." ] # [ doc = " \\param payload_size The size of payload buffer." ] # [ doc = " \\param offset Offset in bytes within the log page to start retrieving log page" ] # [ doc = " data. May only be non-zero if the controller supports extended data for Get Log" ] # [ doc = " Page as reported in the controller data log page attributes." ] # [ doc = " \\param cb_fn Callback function to invoke when the log page has been retrieved." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if resources could not be" ] # [ doc = " allocated for this request." ] pub fn spdk_nvme_ctrlr_cmd_get_log_page ( ctrlr : * mut spdk_nvme_ctrlr , log_page : u8 , nsid : u32 , payload : * mut libc :: c_void , payload_size : u32 , offset : u64 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Abort a specific previously-submitted NVMe command." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_ctrlr_register_timeout_callback()" ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to which the command was submitted." ] # [ doc = " \\param qpair NVMe queue pair to which the command was submitted. For admin" ] # [ doc = "  commands, pass NULL for the qpair." ] # [ doc = " \\param cid Command ID of the command to abort." ] # [ doc = " \\param cb_fn Callback function to invoke when the abort has completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno value otherwise." ] pub fn spdk_nvme_ctrlr_cmd_abort ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cid : u16 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Set specific feature for the given NVMe controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of" ] # [ doc = " commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_ctrlr_cmd_get_feature()." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to manipulate." ] # [ doc = " \\param feature The feature identifier." ] # [ doc = " \\param cdw11 as defined by the specification for this command." ] # [ doc = " \\param cdw12 as defined by the specification for this command." ] # [ doc = " \\param payload The pointer to the payload buffer." ] # [ doc = " \\param payload_size The size of payload buffer." ] # [ doc = " \\param cb_fn Callback function to invoke when the feature has been set." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if resources could not be" ] # [ doc = " allocated for this request." ] pub fn spdk_nvme_ctrlr_cmd_set_feature ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , cdw12 : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Get specific feature from given NVMe controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of" ] # [ doc = " commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_ctrlr_cmd_set_feature()" ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to query." ] # [ doc = " \\param feature The feature identifier." ] # [ doc = " \\param cdw11 as defined by the specification for this command." ] # [ doc = " \\param payload The pointer to the payload buffer." ] # [ doc = " \\param payload_size The size of payload buffer." ] # [ doc = " \\param cb_fn Callback function to invoke when the feature has been retrieved." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, ENOMEM if resources could not be allocated" ] # [ doc = " for this request." ] pub fn spdk_nvme_ctrlr_cmd_get_feature ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Get specific feature from given NVMe controller." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to query." ] # [ doc = " \\param feature The feature identifier." ] # [ doc = " \\param cdw11 as defined by the specification for this command." ] # [ doc = " \\param payload The pointer to the payload buffer." ] # [ doc = " \\param payload_size The size of payload buffer." ] # [ doc = " \\param cb_fn Callback function to invoke when the feature has been retrieved." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param ns_id The namespace identifier." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, ENOMEM if resources could not be allocated" ] # [ doc = " for this request" ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " Call \\ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion" ] # [ doc = " of commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_ctrlr_cmd_set_feature_ns()" ] pub fn spdk_nvme_ctrlr_cmd_get_feature_ns ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , ns_id : u32 ) -> libc :: c_int ; } extern "C" { # [ doc = " Set specific feature for the given NVMe controller and namespace ID." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to manipulate." ] # [ doc = " \\param feature The feature identifier." ] # [ doc = " \\param cdw11 as defined by the specification for this command." ] # [ doc = " \\param cdw12 as defined by the specification for this command." ] # [ doc = " \\param payload The pointer to the payload buffer." ] # [ doc = " \\param payload_size The size of payload buffer." ] # [ doc = " \\param cb_fn Callback function to invoke when the feature has been set." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param ns_id The namespace identifier." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, ENOMEM if resources could not be allocated" ] # [ doc = " for this request." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " Call \\ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion" ] # [ doc = " of commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\sa spdk_nvme_ctrlr_cmd_get_feature_ns()" ] pub fn spdk_nvme_ctrlr_cmd_set_feature_ns ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , cdw12 : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , ns_id : u32 ) -> libc :: c_int ; } extern "C" { # [ doc = " Receive security protocol data from controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point after spdk_nvme_probe()." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of" ] # [ doc = " commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to use for security receive command submission." ] # [ doc = " \\param secp Security Protocol that is used." ] # [ doc = " \\param spsp Security Protocol Specific field." ] # [ doc = " \\param nssf NVMe Security Specific field. Indicate RPMB target when using Security" ] # [ doc = " Protocol EAh." ] # [ doc = " \\param payload The pointer to the payload buffer." ] # [ doc = " \\param payload_size The size of payload buffer." ] # [ doc = " \\param cb_fn Callback function to invoke when the security receive has completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if resources could not be allocated" ] # [ doc = " for this request." ] pub fn spdk_nvme_ctrlr_cmd_security_receive ( ctrlr : * mut spdk_nvme_ctrlr , secp : u8 , spsp : u16 , nssf : u8 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Send security protocol data to controller." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point after spdk_nvme_probe()." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of" ] # [ doc = " commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to use for security send command submission." ] # [ doc = " \\param secp Security Protocol that is used." ] # [ doc = " \\param spsp Security Protocol Specific field." ] # [ doc = " \\param nssf NVMe Security Specific field. Indicate RPMB target when using Security" ] # [ doc = " Protocol EAh." ] # [ doc = " \\param payload The pointer to the payload buffer." ] # [ doc = " \\param payload_size The size of payload buffer." ] # [ doc = " \\param cb_fn Callback function to invoke when the security send has completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if resources could not be allocated" ] # [ doc = " for this request." ] pub fn spdk_nvme_ctrlr_cmd_security_send ( ctrlr : * mut spdk_nvme_ctrlr , secp : u8 , spsp : u16 , nssf : u8 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Attach the specified namespace to controllers." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point after spdk_nvme_probe()." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of" ] # [ doc = " commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to use for command submission." ] # [ doc = " \\param nsid Namespace identifier for namespace to attach." ] # [ doc = " \\param payload The pointer to the controller list." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, ENOMEM if resources could not be allocated" ] # [ doc = " for this request." ] pub fn spdk_nvme_ctrlr_attach_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , payload : * mut spdk_nvme_ctrlr_list ) -> libc :: c_int ; } extern "C" { # [ doc = " Detach the specified namespace from controllers." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point after spdk_nvme_probe()." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of" ] # [ doc = " commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to use for command submission." ] # [ doc = " \\param nsid Namespace ID to detach." ] # [ doc = " \\param payload The pointer to the controller list." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, ENOMEM if resources could not be allocated" ] # [ doc = " for this request" ] pub fn spdk_nvme_ctrlr_detach_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , payload : * mut spdk_nvme_ctrlr_list ) -> libc :: c_int ; } extern "C" { # [ doc = " Create a namespace." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point after spdk_nvme_probe()." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to create namespace on." ] # [ doc = " \\param payload The pointer to the NVMe namespace data." ] # [ doc = "" ] # [ doc = " \\return Namespace ID (>= 1) if successfully created, or 0 if the request failed." ] pub fn spdk_nvme_ctrlr_create_ns ( ctrlr : * mut spdk_nvme_ctrlr , payload : * mut spdk_nvme_ns_data ) -> u32 ; } extern "C" { # [ doc = " Delete a namespace." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point after spdk_nvme_probe()." ] # [ doc = "" ] # [ doc = " Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of" ] # [ doc = " commands submitted through this function." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to delete namespace from." ] # [ doc = " \\param nsid The namespace identifier." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if resources could not be" ] # [ doc = " allocated" ] # [ doc = " for this request" ] pub fn spdk_nvme_ctrlr_delete_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 ) -> libc :: c_int ; } extern "C" { # [ doc = " Format NVM." ] # [ doc = "" ] # [ doc = " This function requests a low-level format of the media." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point after spdk_nvme_probe()." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to format." ] # [ doc = " \\param nsid The namespace identifier. May be SPDK_NVME_GLOBAL_NS_TAG to format" ] # [ doc = " all namespaces." ] # [ doc = " \\param format The format information for the command." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if resources could not be" ] # [ doc = " allocated for this request" ] pub fn spdk_nvme_ctrlr_format ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , format : * mut spdk_nvme_format ) -> libc :: c_int ; } extern "C" { # [ doc = " Download a new firmware image." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point after spdk_nvme_probe()." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller to perform firmware operation on." ] # [ doc = " \\param payload The data buffer for the firmware image." ] # [ doc = " \\param size The data size will be downloaded." ] # [ doc = " \\param slot The slot that the firmware image will be committed to." ] # [ doc = " \\param commit_action The action to perform when firmware is committed." ] # [ doc = " \\param completion_status output parameter. Contains the completion status of" ] # [ doc = " the firmware commit operation." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, ENOMEM if resources could not be allocated" ] # [ doc = " for this request, -1 if the size is not multiple of 4." ] pub fn spdk_nvme_ctrlr_update_firmware ( ctrlr : * mut spdk_nvme_ctrlr , payload : * mut libc :: c_void , size : u32 , slot : libc :: c_int , commit_action : spdk_nvme_fw_commit_action , completion_status : * mut spdk_nvme_status ) -> libc :: c_int ; } extern "C" { # [ doc = " Allocate an I/O buffer from the controller memory buffer (Experimental)." ] # [ doc = "" ] # [ doc = " This function allocates registered memory which belongs to the Controller" ] # [ doc = " Memory Buffer (CMB) of the specified NVMe controller. Note that the CMB has" ] # [ doc = " to support the WDS and RDS capabilities for the allocation to be successful." ] # [ doc = " Also, due to vtophys contraints the CMB must be at least 4MiB in size. Free" ] # [ doc = " memory allocated with this function using spdk_nvme_ctrlr_free_cmb_io_buffer()." ] # [ doc = "" ] # [ doc = " \\param ctrlr Controller from which to allocate memory buffer." ] # [ doc = " \\param size Size of buffer to allocate in bytes." ] # [ doc = "" ] # [ doc = " \\return Pointer to controller memory buffer allocation, or NULL if allocation" ] # [ doc = " was not possible." ] pub fn spdk_nvme_ctrlr_alloc_cmb_io_buffer ( ctrlr : * mut spdk_nvme_ctrlr , size : usize ) -> * mut libc :: c_void ; } extern "C" { # [ doc = " Free a controller memory I/O buffer (Experimental)." ] # [ doc = "" ] # [ doc = " Note this function is currently a NOP which is one reason why this and" ] # [ doc = " spdk_nvme_ctrlr_alloc_cmb_io_buffer() are currently marked as experimental." ] # [ doc = "" ] # [ doc = " \\param ctrlr Controller from which the buffer was allocated." ] # [ doc = " \\param buf Buffer previously allocated by spdk_nvme_ctrlr_alloc_cmb_io_buffer()." ] # [ doc = " \\param size Size of buf in bytes." ] pub fn spdk_nvme_ctrlr_free_cmb_io_buffer ( ctrlr : * mut spdk_nvme_ctrlr , buf : * mut libc :: c_void , size : usize ) ; } extern "C" { # [ doc = " Get the identify namespace data as defined by the NVMe specification." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace." ] # [ doc = "" ] # [ doc = " \\return a pointer to the namespace data." ] pub fn spdk_nvme_ns_get_data ( ns : * mut spdk_nvme_ns ) -> * const spdk_nvme_ns_data ; } extern "C" { # [ doc = " Get the namespace id (index number) from the given namespace handle." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace." ] # [ doc = "" ] # [ doc = " \\return namespace id." ] pub fn spdk_nvme_ns_get_id ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { # [ doc = " Get the controller with which this namespace is associated." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace." ] # [ doc = "" ] # [ doc = " \\return a pointer to the controller." ] pub fn spdk_nvme_ns_get_ctrlr ( ns : * mut spdk_nvme_ns ) -> * mut spdk_nvme_ctrlr ; } extern "C" { # [ doc = " Determine whether a namespace is active." ] # [ doc = "" ] # [ doc = " Inactive namespaces cannot be the target of I/O commands." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return true if active, or false if inactive." ] pub fn spdk_nvme_ns_is_active ( ns : * mut spdk_nvme_ns ) -> bool ; } extern "C" { # [ doc = " Get the maximum transfer size, in bytes, for an I/O sent to the given namespace." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return the maximum transfer size in bytes." ] pub fn spdk_nvme_ns_get_max_io_xfer_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { # [ doc = " Get the sector size, in bytes, of the given namespace." ] # [ doc = "" ] # [ doc = " This function returns the size of the data sector only.  It does not" ] # [ doc = " include metadata size." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " /return the sector size in bytes." ] pub fn spdk_nvme_ns_get_sector_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { # [ doc = " Get the extended sector size, in bytes, of the given namespace." ] # [ doc = "" ] # [ doc = " This function returns the size of the data sector plus metadata." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " /return the extended sector size in bytes." ] pub fn spdk_nvme_ns_get_extended_sector_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { # [ doc = " Get the number of sectors for the given namespace." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return the number of sectors." ] pub fn spdk_nvme_ns_get_num_sectors ( ns : * mut spdk_nvme_ns ) -> u64 ; } extern "C" { # [ doc = " Get the size, in bytes, of the given namespace." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return the size of the given namespace in bytes." ] pub fn spdk_nvme_ns_get_size ( ns : * mut spdk_nvme_ns ) -> u64 ; } extern "C" { # [ doc = " Get the end-to-end data protection information type of the given namespace." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return the end-to-end data protection information type." ] pub fn spdk_nvme_ns_get_pi_type ( ns : * mut spdk_nvme_ns ) -> spdk_nvme_pi_type ; } extern "C" { # [ doc = " Get the metadata size, in bytes, of the given namespace." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return the metadata size of the given namespace in bytes." ] pub fn spdk_nvme_ns_get_md_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { # [ doc = " Check whether if the namespace can support extended LBA when end-to-end data" ] # [ doc = " protection enabled." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return true if the namespace can support extended LBA when end-to-end data" ] # [ doc = " protection enabled, or false otherwise." ] pub fn spdk_nvme_ns_supports_extended_lba ( ns : * mut spdk_nvme_ns ) -> bool ; } extern "C" { # [ doc = " Determine the value returned when reading deallocated blocks." ] # [ doc = "" ] # [ doc = " If deallocated blocks return 0, the deallocate command can be used as a more" ] # [ doc = " efficient alternative to the write_zeroes command, especially for large requests." ] # [ doc = "" ] # [ doc = " \\param ns Namespace." ] # [ doc = "" ] # [ doc = " \\return the logical block read value." ] pub fn spdk_nvme_ns_get_dealloc_logical_block_read_value ( ns : * mut spdk_nvme_ns ) -> spdk_nvme_dealloc_logical_block_read_value ; } extern "C" { # [ doc = " Get the optimal I/O boundary, in blocks, for the given namespace." ] # [ doc = "" ] # [ doc = " Read and write commands should not cross the optimal I/O boundary for best" ] # [ doc = " performance." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return Optimal granularity of I/O commands, in blocks, or 0 if no optimal" ] # [ doc = " granularity is reported." ] pub fn spdk_nvme_ns_get_optimal_io_boundary ( ns : * mut spdk_nvme_ns ) -> u32 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_uuid { _unused : [ u8 ; 0 ] , } extern "C" { # [ doc = " Get the UUID for the given namespace." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return a pointer to namespace UUID, or NULL if ns does not have a UUID." ] pub fn spdk_nvme_ns_get_uuid ( ns : * const spdk_nvme_ns ) -> * const spdk_uuid ; } # [ doc = "< The deallocate command is supported" ] pub const spdk_nvme_ns_flags_SPDK_NVME_NS_DEALLOCATE_SUPPORTED : spdk_nvme_ns_flags = 1 ; # [ doc = "< The flush command is supported" ] pub const spdk_nvme_ns_flags_SPDK_NVME_NS_FLUSH_SUPPORTED : spdk_nvme_ns_flags = 2 ; # [ doc = "< The reservation command is supported" ] pub const spdk_nvme_ns_flags_SPDK_NVME_NS_RESERVATION_SUPPORTED : spdk_nvme_ns_flags = 4 ; # [ doc = "< The write zeroes command is supported" ] pub const spdk_nvme_ns_flags_SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED : spdk_nvme_ns_flags = 8 ; # [ doc = "< The end-to-end data protection is supported" ] pub const spdk_nvme_ns_flags_SPDK_NVME_NS_DPS_PI_SUPPORTED : spdk_nvme_ns_flags = 16 ; # [ doc = "< The extended lba format is supported," ] # [ doc = "metadata is transferred as a contiguous" ] # [ doc = "part of the logical block that it is associated with" ] pub const spdk_nvme_ns_flags_SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED : spdk_nvme_ns_flags = 32 ; # [ doc = " \\brief Namespace command support flags." ] pub type spdk_nvme_ns_flags = u32 ; extern "C" { # [ doc = " Get the flags for the given namespace." ] # [ doc = "" ] # [ doc = " See spdk_nvme_ns_flags for the possible flags returned." ] # [ doc = "" ] # [ doc = " This function is thread safe and can be called at any point while the controller" ] # [ doc = " is attached to the SPDK NVMe driver." ] # [ doc = "" ] # [ doc = " \\param ns Namespace to query." ] # [ doc = "" ] # [ doc = " \\return the flags for the given namespace." ] pub fn spdk_nvme_ns_get_flags ( ns : * mut spdk_nvme_ns ) -> u32 ; } # [ doc = " Restart the SGL walk to the specified offset when the command has scattered payloads." ] # [ doc = "" ] # [ doc = " \\param cb_arg Argument passed to readv/writev." ] # [ doc = " \\param offset Offset for SGL." ] pub type spdk_nvme_req_reset_sgl_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , offset : u32 ) > ; # [ doc = " Fill out *address and *length with the current SGL entry and advance to the next" ] # [ doc = " entry for the next time the callback is invoked." ] # [ doc = "" ] # [ doc = " The described segment must be physically contiguous." ] # [ doc = "" ] # [ doc = " \\param cb_arg Argument passed to readv/writev." ] # [ doc = " \\param address Virtual address of this segment." ] # [ doc = " \\param length Length of this physical segment." ] pub type spdk_nvme_req_next_sge_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , address : * mut * mut libc :: c_void , length : * mut u32 ) -> libc :: c_int > ; extern "C" { # [ doc = " Submit a write I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the write I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer to the data payload." ] # [ doc = " \\param lba Starting LBA to write the data." ] # [ doc = " \\param lba_count Length (in sectors) for the write operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in" ] # [ doc = " spdk/nvme_spec.h, for this I/O." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request" ] pub fn spdk_nvme_ns_cmd_write ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the write I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param lba Starting LBA to write the data." ] # [ doc = " \\param lba_count Length (in sectors) for the write operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined in nvme_spec.h, for this I/O." ] # [ doc = " \\param reset_sgl_fn Callback function to reset scattered payload." ] # [ doc = " \\param next_sge_fn Callback function to iterate each scattered payload memory" ] # [ doc = " segment." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_writev ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the write I/O" ] # [ doc = " \\param qpair I/O queue pair to submit the request" ] # [ doc = " \\param lba starting LBA to write the data" ] # [ doc = " \\param lba_count length (in sectors) for the write operation" ] # [ doc = " \\param cb_fn callback function to invoke when the I/O is completed" ] # [ doc = " \\param cb_arg argument to pass to the callback function" ] # [ doc = " \\param io_flags set flags, defined in nvme_spec.h, for this I/O" ] # [ doc = " \\param reset_sgl_fn callback function to reset scattered payload" ] # [ doc = " \\param next_sge_fn callback function to iterate each scattered" ] # [ doc = " payload memory segment" ] # [ doc = " \\param metadata virtual address pointer to the metadata payload, the length" ] # [ doc = " of metadata is specified by spdk_nvme_ns_get_md_size()" ] # [ doc = " \\param apptag_mask application tag mask." ] # [ doc = " \\param apptag application tag to use end-to-end protection information." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, ENOMEM if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_writev_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb , metadata : * mut libc :: c_void , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the write I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer to the data payload." ] # [ doc = " \\param metadata Virtual address pointer to the metadata payload, the length" ] # [ doc = " of metadata is specified by spdk_nvme_ns_get_md_size()." ] # [ doc = " \\param lba Starting LBA to write the data." ] # [ doc = " \\param lba_count Length (in sectors) for the write operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in" ] # [ doc = " spdk/nvme_spec.h, for this I/O." ] # [ doc = " \\param apptag_mask Application tag mask." ] # [ doc = " \\param apptag Application tag to use end-to-end protection information." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_write_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , metadata : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write zeroes I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the write zeroes I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param lba Starting LBA for this command." ] # [ doc = " \\param lba_count Length (in sectors) for the write zero operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in" ] # [ doc = " spdk/nvme_spec.h, for this I/O." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_write_zeroes ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { # [ doc = " \\brief Submits a read I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the read I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer to the data payload." ] # [ doc = " \\param lba Starting LBA to read the data." ] # [ doc = " \\param lba_count Length (in sectors) for the read operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined in nvme_spec.h, for this I/O." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_read ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a read I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the read I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param lba Starting LBA to read the data." ] # [ doc = " \\param lba_count Length (in sectors) for the read operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined in nvme_spec.h, for this I/O." ] # [ doc = " \\param reset_sgl_fn Callback function to reset scattered payload." ] # [ doc = " \\param next_sge_fn Callback function to iterate each scattered payload memory" ] # [ doc = " segment." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_readv ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a read I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the read I/O" ] # [ doc = " \\param qpair I/O queue pair to submit the request" ] # [ doc = " \\param lba starting LBA to read the data" ] # [ doc = " \\param lba_count length (in sectors) for the read operation" ] # [ doc = " \\param cb_fn callback function to invoke when the I/O is completed" ] # [ doc = " \\param cb_arg argument to pass to the callback function" ] # [ doc = " \\param io_flags set flags, defined in nvme_spec.h, for this I/O" ] # [ doc = " \\param reset_sgl_fn callback function to reset scattered payload" ] # [ doc = " \\param next_sge_fn callback function to iterate each scattered" ] # [ doc = " payload memory segment" ] # [ doc = " \\param metadata virtual address pointer to the metadata payload, the length" ] # [ doc = "\t           of metadata is specified by spdk_nvme_ns_get_md_size()" ] # [ doc = " \\param apptag_mask application tag mask." ] # [ doc = " \\param apptag application tag to use end-to-end protection information." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, ENOMEM if an nvme_request" ] # [ doc = "\t     structure cannot be allocated for the I/O request" ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any given time." ] pub fn spdk_nvme_ns_cmd_readv_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb , metadata : * mut libc :: c_void , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { # [ doc = " Submits a read I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the read I/O" ] # [ doc = " \\param qpair I/O queue pair to submit the request" ] # [ doc = " \\param payload virtual address pointer to the data payload" ] # [ doc = " \\param metadata virtual address pointer to the metadata payload, the length" ] # [ doc = " of metadata is specified by spdk_nvme_ns_get_md_size()." ] # [ doc = " \\param lba starting LBA to read the data." ] # [ doc = " \\param lba_count Length (in sectors) for the read operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined in nvme_spec.h, for this I/O." ] # [ doc = " \\param apptag_mask Application tag mask." ] # [ doc = " \\param apptag Application tag to use end-to-end protection information." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_read_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , metadata : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a data set management request to the specified NVMe namespace. Data set" ] # [ doc = " management operations are designed to optimize interaction with the block" ] # [ doc = " translation layer inside the device. The most common type of operation is" ] # [ doc = " deallocate, which is often referred to as TRIM or UNMAP." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " This is a convenience wrapper that will automatically allocate and construct" ] # [ doc = " the correct data buffers. Therefore, ranges does not need to be allocated from" ] # [ doc = " pinned memory and can be placed on the stack. If a higher performance, zero-copy" ] # [ doc = " version of DSM is required, simply build and submit a raw command using" ] # [ doc = " spdk_nvme_ctrlr_cmd_io_raw()." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the DSM request" ] # [ doc = " \\param type A bit field constructed from \\ref spdk_nvme_dsm_attribute." ] # [ doc = " \\param qpair I/O queue pair to submit the request" ] # [ doc = " \\param ranges An array of \\ref spdk_nvme_dsm_range elements describing the LBAs" ] # [ doc = " to operate on." ] # [ doc = " \\param num_ranges The number of elements in the ranges array." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed" ] # [ doc = " \\param cb_arg Argument to pass to the callback function" ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated POSIX errno values otherwise." ] pub fn spdk_nvme_ns_cmd_dataset_management ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , type_ : u32 , ranges : * const spdk_nvme_dsm_range , num_ranges : u16 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a flush request to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the flush request." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_flush ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a reservation register to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the reservation register request." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer to the reservation register data." ] # [ doc = " \\param ignore_key \'1\' the current reservation key check is disabled." ] # [ doc = " \\param action Specifies the registration action." ] # [ doc = " \\param cptpl Change the Persist Through Power Loss state." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_reservation_register ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_register_data , ignore_key : bool , action : spdk_nvme_reservation_register_action , cptpl : spdk_nvme_reservation_register_cptpl , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submits a reservation release to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the reservation release request." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer to current reservation key." ] # [ doc = " \\param ignore_key \'1\' the current reservation key check is disabled." ] # [ doc = " \\param action Specifies the reservation release action." ] # [ doc = " \\param type Reservation type for the namespace." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_reservation_release ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_key_data , ignore_key : bool , action : spdk_nvme_reservation_release_action , type_ : spdk_nvme_reservation_type , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submits a reservation acquire to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the reservation acquire request." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer to reservation acquire data." ] # [ doc = " \\param ignore_key \'1\' the current reservation key check is disabled." ] # [ doc = " \\param action Specifies the reservation acquire action." ] # [ doc = " \\param type Reservation type for the namespace." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_reservation_acquire ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_acquire_data , ignore_key : bool , action : spdk_nvme_reservation_acquire_action , type_ : spdk_nvme_reservation_type , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a reservation report to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the reservation report request." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer for reservation status data." ] # [ doc = " \\param len Length bytes for reservation status data structure." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_reservation_report ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a compare I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the compare I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer to the data payload." ] # [ doc = " \\param lba Starting LBA to compare the data." ] # [ doc = " \\param lba_count Length (in sectors) for the compare operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined in nvme_spec.h, for this I/O." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_compare ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a compare I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the compare I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param lba Starting LBA to compare the data." ] # [ doc = " \\param lba_count Length (in sectors) for the compare operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined in nvme_spec.h, for this I/O." ] # [ doc = " \\param reset_sgl_fn Callback function to reset scattered payload." ] # [ doc = " \\param next_sge_fn Callback function to iterate each scattered payload memory" ] # [ doc = " segment." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_comparev ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a compare I/O to the specified NVMe namespace." ] # [ doc = "" ] # [ doc = " The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair()." ] # [ doc = " The user must ensure that only one thread submits I/O on a given qpair at any" ] # [ doc = " given time." ] # [ doc = "" ] # [ doc = " \\param ns NVMe namespace to submit the compare I/O." ] # [ doc = " \\param qpair I/O queue pair to submit the request." ] # [ doc = " \\param payload Virtual address pointer to the data payload." ] # [ doc = " \\param metadata Virtual address pointer to the metadata payload, the length" ] # [ doc = " of metadata is specified by spdk_nvme_ns_get_md_size()." ] # [ doc = " \\param lba Starting LBA to compare the data." ] # [ doc = " \\param lba_count Length (in sectors) for the compare operation." ] # [ doc = " \\param cb_fn Callback function to invoke when the I/O is completed." ] # [ doc = " \\param cb_arg Argument to pass to the callback function." ] # [ doc = " \\param io_flags Set flags, defined in nvme_spec.h, for this I/O." ] # [ doc = " \\param apptag_mask Application tag mask." ] # [ doc = " \\param apptag Application tag to use end-to-end protection information." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully submitted, negated errno if an nvme_request structure" ] # [ doc = " cannot be allocated for the I/O request." ] pub fn spdk_nvme_ns_cmd_compare_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , metadata : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { # [ doc = " \\brief Inject an error for the next request with a given opcode." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller." ] # [ doc = " \\param qpair I/O queue pair to add the error command," ] # [ doc = "              NULL for Admin queue pair." ] # [ doc = " \\param opc Opcode for Admin or I/O commands." ] # [ doc = " \\param do_not_submit True if matching requests should not be submitted" ] # [ doc = "                      to the controller, but instead completed manually" ] # [ doc = "                      after timeout_in_us has expired.  False if matching" ] # [ doc = "                      requests should be submitted to the controller and" ] # [ doc = "                      have their completion status modified after the" ] # [ doc = "                      controller completes the request." ] # [ doc = " \\param timeout_in_us Wait specified microseconds when do_not_submit is true." ] # [ doc = " \\param err_count Number of matching requests to inject errors." ] # [ doc = " \\param sct Status code type." ] # [ doc = " \\param sc Status code." ] # [ doc = "" ] # [ doc = " \\return 0 if successfully enabled, ENOMEM if an error command" ] # [ doc = "\t     structure cannot be allocated." ] # [ doc = "" ] # [ doc = " The function can be called multiple times to inject errors for different" ] # [ doc = " commands.  If the opcode matches an existing entry, the existing entry" ] # [ doc = " will be updated with the values specified." ] pub fn spdk_nvme_qpair_add_cmd_error_injection ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , opc : u8 , do_not_submit : bool , timeout_in_us : u64 , err_count : u32 , sct : u8 , sc : u8 ) -> libc :: c_int ; } extern "C" { # [ doc = " \\brief Clear the specified NVMe command with error status." ] # [ doc = "" ] # [ doc = " \\param ctrlr NVMe controller." ] # [ doc = " \\param qpair I/O queue pair to remove the error command," ] # [ doc = " \\            NULL for Admin queue pair." ] # [ doc = " \\param opc Opcode for Admin or I/O commands." ] # [ doc = "" ] # [ doc = " The function will remove specified command in the error list." ] pub fn spdk_nvme_qpair_remove_cmd_error_injection ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , opc : u8 ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_cpuset { _unused : [ u8 ; 0 ] , } extern "C" { pub fn spdk_cpuset_alloc ( ) -> * mut spdk_cpuset ; } extern "C" { pub fn spdk_cpuset_free ( set : * mut spdk_cpuset ) ; } extern "C" { pub fn spdk_cpuset_equal ( set1 : * const spdk_cpuset , set2 : * const spdk_cpuset ) -> bool ; } extern "C" { pub fn spdk_cpuset_copy ( dst : * mut spdk_cpuset , src : * const spdk_cpuset ) ; } extern "C" { pub fn spdk_cpuset_and ( dst : * mut spdk_cpuset , src : * const spdk_cpuset ) ; } extern "C" { pub fn spdk_cpuset_or ( dst : * mut spdk_cpuset , src : * const spdk_cpuset ) ; } extern "C" { pub fn spdk_cpuset_zero ( set : * mut spdk_cpuset ) ; } extern "C" { pub fn spdk_cpuset_set_cpu ( set : * mut spdk_cpuset , cpu : u32 , state : bool ) ; } extern "C" { pub fn spdk_cpuset_get_cpu ( set : * const spdk_cpuset , cpu : u32 ) -> bool ; } extern "C" { pub fn spdk_cpuset_count ( set : * const spdk_cpuset ) -> u32 ; } extern "C" { pub fn spdk_cpuset_fmt ( set : * mut spdk_cpuset ) -> * const libc :: c_char ; } extern "C" { pub fn spdk_cpuset_parse ( set : * mut spdk_cpuset , mask : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_log_open ( ) ; } extern "C" { pub fn spdk_log_close ( ) ; } pub const spdk_log_level_SPDK_LOG_DISABLED : spdk_log_level = -1 ; pub const spdk_log_level_SPDK_LOG_ERROR : spdk_log_level = 0 ; pub const spdk_log_level_SPDK_LOG_WARN : spdk_log_level = 1 ; pub const spdk_log_level_SPDK_LOG_NOTICE : spdk_log_level = 2 ; pub const spdk_log_level_SPDK_LOG_INFO : spdk_log_level = 3 ; pub const spdk_log_level_SPDK_LOG_DEBUG : spdk_log_level = 4 ; pub type spdk_log_level = i32 ; extern "C" { pub fn spdk_log_set_level ( level : spdk_log_level ) ; } extern "C" { pub fn spdk_log_get_level ( ) -> spdk_log_level ; } extern "C" { pub fn spdk_log_set_backtrace_level ( level : spdk_log_level ) ; } extern "C" { pub fn spdk_log_get_backtrace_level ( ) -> spdk_log_level ; } extern "C" { pub fn spdk_log_set_print_level ( level : spdk_log_level ) ; } extern "C" { pub fn spdk_log_get_print_level ( ) -> spdk_log_level ; } extern "C" { pub fn spdk_log ( level : spdk_log_level , file : * const libc :: c_char , line : libc :: c_int , func : * const libc :: c_char , format : * const libc :: c_char , ... ) ; } extern "C" { pub fn spdk_trace_dump ( fp : * mut FILE , label : * const libc :: c_char , buf : * const libc :: c_void , len : usize ) ; } extern "C" { pub fn spdk_log_get_trace_flag ( flag : * const libc :: c_char ) -> bool ; } extern "C" { pub fn spdk_log_set_trace_flag ( flag : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_log_clear_trace_flag ( flag : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_tracelog_usage ( f : * mut FILE , trace_arg : * const libc :: c_char ) ; } # [ doc = " Event handler function." ] # [ doc = "" ] # [ doc = " \\param arg1 Argument 1." ] # [ doc = " \\param arg2 Argument 2." ] pub type spdk_event_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void , arg2 : * mut libc :: c_void ) > ; # [ doc = " \\brief An event is a function that is passed to and called on an lcore." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_event { _unused : [ u8 ; 0 ] , } # [ doc = " \\brief A poller is a function that is repeatedly called on an lcore." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_poller { _unused : [ u8 ; 0 ] , } # [ doc = " Callback function for customized shutdown handling of application." ] pub type spdk_app_shutdown_cb = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; # [ doc = " Signal handler fucntion." ] # [ doc = "" ] # [ doc = " \\param signal Signal number." ] pub type spdk_sighandler_t = :: std :: option :: Option < unsafe extern "C" fn ( signal : libc :: c_int ) > ; # [ doc = " \\brief Event framework initialization options" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_app_opts { pub name : * const libc :: c_char , pub config_file : * const libc :: c_char , pub rpc_addr : * const libc :: c_char , pub reactor_mask : * const libc :: c_char , pub tpoint_group_mask : * const libc :: c_char , pub shm_id : libc :: c_int , pub shutdown_cb : spdk_app_shutdown_cb , pub usr1_handler : spdk_sighandler_t , pub enable_coredump : bool , pub mem_channel : libc :: c_int , pub master_core : libc :: c_int , pub mem_size : libc :: c_int , pub no_pci : bool , pub hugepage_single_segments : bool , pub unlink_hugepage : bool , pub print_level : spdk_log_level , pub num_pci_addr : usize , pub pci_blacklist : * mut spdk_pci_addr , pub pci_whitelist : * mut spdk_pci_addr , pub max_delay_us : u64 , pub delay_subsystem_init : bool , } impl Default for spdk_app_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_reactor_tsc_stats { pub busy_tsc : u64 , pub idle_tsc : u64 , pub unknown_tsc : u64 , } extern "C" { # [ doc = " Initialize the default value of opts" ] # [ doc = "" ] # [ doc = " \\param opts Data structure where SPDK will initialize the default options." ] pub fn spdk_app_opts_init ( opts : * mut spdk_app_opts ) ; } extern "C" { # [ doc = " Start the framework." ] # [ doc = "" ] # [ doc = " Before calling this function, the fields of opts must be initialized by" ] # [ doc = " spdk_app_opts_init(). Once started, the framework will call start_fn on the" ] # [ doc = " master core with the arguments provided. This call will block until spdk_app_stop()" ] # [ doc = " is called, or if an error condition occurs during the intialization" ] # [ doc = " code within spdk_app_start(), itself, before invoking the caller\'s" ] # [ doc = " supplied function." ] # [ doc = "" ] # [ doc = " \\param opts Initialization options used for this application." ] # [ doc = " \\param start_fn Event function that is called when the framework starts." ] # [ doc = " \\param arg1 Argument passed to function start_fn." ] # [ doc = " \\param arg2 Argument passed to function start_fn." ] # [ doc = "" ] # [ doc = " \\return 0 on success or non-zero on failure." ] pub fn spdk_app_start ( opts : * mut spdk_app_opts , start_fn : spdk_event_fn , arg1 : * mut libc :: c_void , arg2 : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Perform final shutdown operations on an application using the event framework." ] pub fn spdk_app_fini ( ) ; } extern "C" { # [ doc = " Start shutting down the framework." ] # [ doc = "" ] # [ doc = " Typically this function is not called directly, and the shutdown process is" ] # [ doc = " started implicitly by a process signal. But in applications that are using" ] # [ doc = " SPDK for a subset of its process threads, this function can be called in lieu" ] # [ doc = " of a signal." ] pub fn spdk_app_start_shutdown ( ) ; } extern "C" { # [ doc = " Stop the framework." ] # [ doc = "" ] # [ doc = " This does not wait for all threads to exit. Instead, it kicks off the shutdown" ] # [ doc = " process and returns. Once the shutdown process is complete, spdk_app_start()" ] # [ doc = " will return." ] # [ doc = "" ] # [ doc = " \\param rc The rc value specified here will be returned to caller of spdk_app_start()." ] pub fn spdk_app_stop ( rc : libc :: c_int ) ; } extern "C" { # [ doc = " Generate a configuration file that corresponds to the current running state." ] # [ doc = "" ] # [ doc = " \\param config_str Values obtained from the generated configuration file." ] # [ doc = " \\param name Prefix for name of temporary configuration file to save the current config." ] # [ doc = "" ] # [ doc = " \\return 0 on success, -1 on failure." ] pub fn spdk_app_get_running_config ( config_str : * mut * mut libc :: c_char , name : * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { # [ doc = " Return the shared memory id for this application." ] # [ doc = "" ] # [ doc = " \\return shared memory id." ] pub fn spdk_app_get_shm_id ( ) -> libc :: c_int ; } extern "C" { # [ doc = " Convert a string containing a CPU core mask into a bitmask" ] # [ doc = "" ] # [ doc = " \\param mask String containing a CPU core mask." ] # [ doc = " \\param cpumask Bitmask of CPU cores." ] # [ doc = "" ] # [ doc = " \\return 0 on success, -1 on failure." ] pub fn spdk_app_parse_core_mask ( mask : * const libc :: c_char , cpumask : * mut spdk_cpuset ) -> libc :: c_int ; } extern "C" { # [ doc = " Get the mask of the CPU cores active for this application" ] # [ doc = "" ] # [ doc = " \\return the bitmask of the active CPU cores." ] pub fn spdk_app_get_core_mask ( ) -> * mut spdk_cpuset ; } pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_HELP : spdk_app_parse_args_rvals = 0 ; pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_SUCCESS : spdk_app_parse_args_rvals = 1 ; pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_FAIL : spdk_app_parse_args_rvals = 2 ; pub type spdk_app_parse_args_rvals = u32 ; pub use self :: spdk_app_parse_args_rvals as spdk_app_parse_args_rvals_t ; extern "C" { # [ doc = " Helper function for parsing arguments and printing usage messages." ] # [ doc = "" ] # [ doc = " \\param argc Count of arguments in argv parameter array." ] # [ doc = " \\param argv Array of command line arguments." ] # [ doc = " \\param opts Default options for the application." ] # [ doc = " \\param getopt_str String representing the app-specific command line parameters." ] # [ doc = " Characters in this string must not conflict with characters in SPDK_APP_GETOPT_STRING." ] # [ doc = " \\param app_long_opts Array of full-name parameters. Can be NULL." ] # [ doc = " \\param parse Function pointer to call if an argument in getopt_str is found." ] # [ doc = " \\param usage Function pointer to print usage messages for app-specific command" ] # [ doc = "\t\tline parameters." ] # [ doc = "\\return SPDK_APP_PARSE_ARGS_FAIL on failure, SPDK_APP_PARSE_ARGS_SUCCESS on" ] # [ doc = "        success, SPDK_APP_PARSE_ARGS_HELP if \'-h\' passed as an option." ] pub fn spdk_app_parse_args ( argc : libc :: c_int , argv : * mut * mut libc :: c_char , opts : * mut spdk_app_opts , getopt_str : * const libc :: c_char , app_long_opts : * mut option , parse : :: std :: option :: Option < unsafe extern "C" fn ( ch : libc :: c_int , arg : * mut libc :: c_char ) > , usage : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> spdk_app_parse_args_rvals_t ; } extern "C" { # [ doc = " Print usage strings for common SPDK command line options." ] # [ doc = "" ] # [ doc = " May only be called after spdk_app_parse_args()." ] pub fn spdk_app_usage ( ) ; } extern "C" { # [ doc = " Allocate an event to be passed to spdk_event_call()." ] # [ doc = "" ] # [ doc = " \\param lcore Lcore to run this event." ] # [ doc = " \\param fn Function used to execute event." ] # [ doc = " \\param arg1 Argument passed to function fn." ] # [ doc = " \\param arg2 Argument passed to function fn." ] # [ doc = "" ] # [ doc = " \\return a pointer to the allocated event." ] pub fn spdk_event_allocate ( lcore : u32 , fn_ : spdk_event_fn , arg1 : * mut libc :: c_void , arg2 : * mut libc :: c_void ) -> * mut spdk_event ; } extern "C" { # [ doc = " Pass the given event to the associated lcore and call the function." ] # [ doc = "" ] # [ doc = " \\param event Event to execute." ] pub fn spdk_event_call ( event : * mut spdk_event ) ; } extern "C" { # [ doc = " Enable or disable monitoring of context switches." ] # [ doc = "" ] # [ doc = " \\param enabled True to enable, false to disable." ] pub fn spdk_reactor_enable_context_switch_monitor ( enabled : bool ) ; } extern "C" { # [ doc = " Return whether context switch monitoring is enabled." ] # [ doc = "" ] # [ doc = " \\return true if enabled or false otherwise." ] pub fn spdk_reactor_context_switch_monitor_enabled ( ) -> bool ; } extern "C" { # [ doc = " Get tsc stats from a given reactor" ] # [ doc = " Copy cumulative reactor tsc values to user\'s tsc_stats structure." ] # [ doc = "" ] # [ doc = " \\param tsc_stats User\'s tsc_stats structure." ] # [ doc = " \\param core_id Get tsc data on this Reactor core id." ] pub fn spdk_reactor_get_tsc_stats ( tsc_stats : * mut spdk_reactor_tsc_stats , core_id : u32 ) -> libc :: c_int ; } pub const spdk_scsi_group_code_SPDK_SCSI_6BYTE_CMD : spdk_scsi_group_code = 0 ; pub const spdk_scsi_group_code_SPDK_SCSI_10BYTE_CMD : spdk_scsi_group_code = 32 ; pub const spdk_scsi_group_code_SPDK_SCSI_10BYTE_CMD2 : spdk_scsi_group_code = 64 ; pub const spdk_scsi_group_code_SPDK_SCSI_16BYTE_CMD : spdk_scsi_group_code = 128 ; pub const spdk_scsi_group_code_SPDK_SCSI_12BYTE_CMD : spdk_scsi_group_code = 160 ; pub type spdk_scsi_group_code = u32 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_GOOD : spdk_scsi_status = 0 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_CHECK_CONDITION : spdk_scsi_status = 2 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_CONDITION_MET : spdk_scsi_status = 4 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_BUSY : spdk_scsi_status = 8 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_INTERMEDIATE : spdk_scsi_status = 16 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_INTERMEDIATE_CONDITION_MET : spdk_scsi_status = 20 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_RESERVATION_CONFLICT : spdk_scsi_status = 24 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_Obsolete : spdk_scsi_status = 34 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_TASK_SET_FULL : spdk_scsi_status = 40 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_ACA_ACTIVE : spdk_scsi_status = 48 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_TASK_ABORTED : spdk_scsi_status = 64 ; pub type spdk_scsi_status = u32 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_NO_SENSE : spdk_scsi_sense = 0 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_RECOVERED_ERROR : spdk_scsi_sense = 1 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_NOT_READY : spdk_scsi_sense = 2 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_MEDIUM_ERROR : spdk_scsi_sense = 3 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_HARDWARE_ERROR : spdk_scsi_sense = 4 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_ILLEGAL_REQUEST : spdk_scsi_sense = 5 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_UNIT_ATTENTION : spdk_scsi_sense = 6 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_DATA_PROTECT : spdk_scsi_sense = 7 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_BLANK_CHECK : spdk_scsi_sense = 8 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_VENDOR_SPECIFIC : spdk_scsi_sense = 9 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_COPY_ABORTED : spdk_scsi_sense = 10 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_ABORTED_COMMAND : spdk_scsi_sense = 11 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_VOLUME_OVERFLOW : spdk_scsi_sense = 13 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_MISCOMPARE : spdk_scsi_sense = 14 ; pub type spdk_scsi_sense = u32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_NO_ADDITIONAL_SENSE : spdk_scsi_asc = 0 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_PERIPHERAL_DEVICE_WRITE_FAULT : spdk_scsi_asc = 3 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_UNIT_NOT_READY : spdk_scsi_asc = 4 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_WARNING : spdk_scsi_asc = 11 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_GUARD_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_UNRECOVERED_READ_ERROR : spdk_scsi_asc = 17 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_MISCOMPARE_DURING_VERIFY_OPERATION : spdk_scsi_asc = 29 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INVALID_COMMAND_OPERATION_CODE : spdk_scsi_asc = 32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_ACCESS_DENIED : spdk_scsi_asc = 32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE : spdk_scsi_asc = 33 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INVALID_FIELD_IN_CDB : spdk_scsi_asc = 36 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED : spdk_scsi_asc = 37 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_WRITE_PROTECTED : spdk_scsi_asc = 39 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_FORMAT_COMMAND_FAILED : spdk_scsi_asc = 49 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_SAVING_PARAMETERS_NOT_SUPPORTED : spdk_scsi_asc = 57 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INTERNAL_TARGET_FAILURE : spdk_scsi_asc = 68 ; pub type spdk_scsi_asc = u32 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_CAUSE_NOT_REPORTABLE : spdk_scsi_ascq = 0 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_BECOMING_READY : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_FORMAT_COMMAND_FAILED : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_GUARD_CHECK_FAILED : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED : spdk_scsi_ascq = 2 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_NO_ACCESS_RIGHTS : spdk_scsi_ascq = 2 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED : spdk_scsi_ascq = 3 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_POWER_LOSS_EXPECTED : spdk_scsi_ascq = 8 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_INVALID_LU_IDENTIFIER : spdk_scsi_ascq = 9 ; pub type spdk_scsi_ascq = u32 ; pub const spdk_spc_opcode_SPDK_SPC_ACCESS_CONTROL_IN : spdk_spc_opcode = 134 ; pub const spdk_spc_opcode_SPDK_SPC_ACCESS_CONTROL_OUT : spdk_spc_opcode = 135 ; pub const spdk_spc_opcode_SPDK_SPC_EXTENDED_COPY : spdk_spc_opcode = 131 ; pub const spdk_spc_opcode_SPDK_SPC_INQUIRY : spdk_spc_opcode = 18 ; pub const spdk_spc_opcode_SPDK_SPC_LOG_SELECT : spdk_spc_opcode = 76 ; pub const spdk_spc_opcode_SPDK_SPC_LOG_SENSE : spdk_spc_opcode = 77 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SELECT_6 : spdk_spc_opcode = 21 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SELECT_10 : spdk_spc_opcode = 85 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SENSE_6 : spdk_spc_opcode = 26 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SENSE_10 : spdk_spc_opcode = 90 ; pub const spdk_spc_opcode_SPDK_SPC_PERSISTENT_RESERVE_IN : spdk_spc_opcode = 94 ; pub const spdk_spc_opcode_SPDK_SPC_PERSISTENT_RESERVE_OUT : spdk_spc_opcode = 95 ; pub const spdk_spc_opcode_SPDK_SPC_PREVENT_ALLOW_MEDIUM_REMOVAL : spdk_spc_opcode = 30 ; pub const spdk_spc_opcode_SPDK_SPC_READ_ATTRIBUTE : spdk_spc_opcode = 140 ; pub const spdk_spc_opcode_SPDK_SPC_READ_BUFFER : spdk_spc_opcode = 60 ; pub const spdk_spc_opcode_SPDK_SPC_RECEIVE_COPY_RESULTS : spdk_spc_opcode = 132 ; pub const spdk_spc_opcode_SPDK_SPC_RECEIVE_DIAGNOSTIC_RESULTS : spdk_spc_opcode = 28 ; pub const spdk_spc_opcode_SPDK_SPC_REPORT_LUNS : spdk_spc_opcode = 160 ; pub const spdk_spc_opcode_SPDK_SPC_REQUEST_SENSE : spdk_spc_opcode = 3 ; pub const spdk_spc_opcode_SPDK_SPC_SEND_DIAGNOSTIC : spdk_spc_opcode = 29 ; pub const spdk_spc_opcode_SPDK_SPC_TEST_UNIT_READY : spdk_spc_opcode = 0 ; pub const spdk_spc_opcode_SPDK_SPC_WRITE_ATTRIBUTE : spdk_spc_opcode = 141 ; pub const spdk_spc_opcode_SPDK_SPC_WRITE_BUFFER : spdk_spc_opcode = 59 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_IN_12 : spdk_spc_opcode = 171 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_OUT_12 : spdk_spc_opcode = 169 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_IN_16 : spdk_spc_opcode = 158 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_OUT_16 : spdk_spc_opcode = 159 ; pub const spdk_spc_opcode_SPDK_SPC_VARIABLE_LENGTH : spdk_spc_opcode = 127 ; pub const spdk_spc_opcode_SPDK_SPC_MO_CHANGE_ALIASES : spdk_spc_opcode = 11 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_DEVICE_IDENTIFIER : spdk_spc_opcode = 6 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_PRIORITY : spdk_spc_opcode = 14 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_TARGET_PORT_GROUPS : spdk_spc_opcode = 10 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_TIMESTAMP : spdk_spc_opcode = 15 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_ALIASES : spdk_spc_opcode = 11 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_DEVICE_IDENTIFIER : spdk_spc_opcode = 5 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_PRIORITY : spdk_spc_opcode = 14 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_SUPPORTED_OPERATION_CODES : spdk_spc_opcode = 12 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_SUPPORTED_TASK_MANAGEMENT_FUNCTIONS : spdk_spc_opcode = 13 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_TARGET_PORT_GROUPS : spdk_spc_opcode = 10 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_TIMESTAMP : spdk_spc_opcode = 15 ; pub const spdk_spc_opcode_SPDK_SPC2_RELEASE_6 : spdk_spc_opcode = 23 ; pub const spdk_spc_opcode_SPDK_SPC2_RELEASE_10 : spdk_spc_opcode = 87 ; pub const spdk_spc_opcode_SPDK_SPC2_RESERVE_6 : spdk_spc_opcode = 22 ; pub const spdk_spc_opcode_SPDK_SPC2_RESERVE_10 : spdk_spc_opcode = 86 ; pub type spdk_spc_opcode = u32 ; pub const spdk_scc_opcode_SPDK_SCC_MAINTENANCE_IN : spdk_scc_opcode = 163 ; pub const spdk_scc_opcode_SPDK_SCC_MAINTENANCE_OUT : spdk_scc_opcode = 164 ; pub type spdk_scc_opcode = u32 ; pub const spdk_sbc_opcode_SPDK_SBC_COMPARE_AND_WRITE : spdk_sbc_opcode = 137 ; pub const spdk_sbc_opcode_SPDK_SBC_FORMAT_UNIT : spdk_sbc_opcode = 4 ; pub const spdk_sbc_opcode_SPDK_SBC_GET_LBA_STATUS : spdk_sbc_opcode = 1179806 ; pub const spdk_sbc_opcode_SPDK_SBC_ORWRITE_16 : spdk_sbc_opcode = 139 ; pub const spdk_sbc_opcode_SPDK_SBC_PRE_FETCH_10 : spdk_sbc_opcode = 52 ; pub const spdk_sbc_opcode_SPDK_SBC_PRE_FETCH_16 : spdk_sbc_opcode = 144 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_6 : spdk_sbc_opcode = 8 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_10 : spdk_sbc_opcode = 40 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_12 : spdk_sbc_opcode = 168 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_16 : spdk_sbc_opcode = 136 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_ATTRIBUTE : spdk_sbc_opcode = 140 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_BUFFER : spdk_sbc_opcode = 60 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_CAPACITY_10 : spdk_sbc_opcode = 37 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_DEFECT_DATA_10 : spdk_sbc_opcode = 55 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_DEFECT_DATA_12 : spdk_sbc_opcode = 183 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_LONG_10 : spdk_sbc_opcode = 62 ; pub const spdk_sbc_opcode_SPDK_SBC_REASSIGN_BLOCKS : spdk_sbc_opcode = 7 ; pub const spdk_sbc_opcode_SPDK_SBC_SANITIZE : spdk_sbc_opcode = 72 ; pub const spdk_sbc_opcode_SPDK_SBC_START_STOP_UNIT : spdk_sbc_opcode = 27 ; pub const spdk_sbc_opcode_SPDK_SBC_SYNCHRONIZE_CACHE_10 : spdk_sbc_opcode = 53 ; pub const spdk_sbc_opcode_SPDK_SBC_SYNCHRONIZE_CACHE_16 : spdk_sbc_opcode = 145 ; pub const spdk_sbc_opcode_SPDK_SBC_UNMAP : spdk_sbc_opcode = 66 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_10 : spdk_sbc_opcode = 47 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_12 : spdk_sbc_opcode = 175 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_16 : spdk_sbc_opcode = 143 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_6 : spdk_sbc_opcode = 10 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_10 : spdk_sbc_opcode = 42 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_12 : spdk_sbc_opcode = 170 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_16 : spdk_sbc_opcode = 138 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_10 : spdk_sbc_opcode = 46 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_12 : spdk_sbc_opcode = 174 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_16 : spdk_sbc_opcode = 142 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_LONG_10 : spdk_sbc_opcode = 63 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_SAME_10 : spdk_sbc_opcode = 65 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_SAME_16 : spdk_sbc_opcode = 147 ; pub const spdk_sbc_opcode_SPDK_SBC_XDREAD_10 : spdk_sbc_opcode = 82 ; pub const spdk_sbc_opcode_SPDK_SBC_XDWRITE_10 : spdk_sbc_opcode = 80 ; pub const spdk_sbc_opcode_SPDK_SBC_XDWRITEREAD_10 : spdk_sbc_opcode = 83 ; pub const spdk_sbc_opcode_SPDK_SBC_XPWRITE_10 : spdk_sbc_opcode = 81 ; pub const spdk_sbc_opcode_SPDK_SBC_SAI_READ_CAPACITY_16 : spdk_sbc_opcode = 16 ; pub const spdk_sbc_opcode_SPDK_SBC_SAI_READ_LONG_16 : spdk_sbc_opcode = 17 ; pub const spdk_sbc_opcode_SPDK_SBC_SAO_WRITE_LONG_16 : spdk_sbc_opcode = 17 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_READ_32 : spdk_sbc_opcode = 9 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_VERIFY_32 : spdk_sbc_opcode = 10 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_32 : spdk_sbc_opcode = 11 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_AND_VERIFY_32 : spdk_sbc_opcode = 12 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_SAME_32 : spdk_sbc_opcode = 13 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDREAD_32 : spdk_sbc_opcode = 3 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDWRITE_32 : spdk_sbc_opcode = 4 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDWRITEREAD_32 : spdk_sbc_opcode = 7 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XPWRITE_32 : spdk_sbc_opcode = 6 ; pub type spdk_sbc_opcode = u32 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DISC_STRUCTURE : spdk_mmc_opcode = 173 ; pub const spdk_mmc_opcode_SPDK_MMC_BLANK : spdk_mmc_opcode = 161 ; pub const spdk_mmc_opcode_SPDK_MMC_CLOSE_TRACK_SESSION : spdk_mmc_opcode = 91 ; pub const spdk_mmc_opcode_SPDK_MMC_ERASE_10 : spdk_mmc_opcode = 44 ; pub const spdk_mmc_opcode_SPDK_MMC_FORMAT_UNIT : spdk_mmc_opcode = 4 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_CONFIGURATION : spdk_mmc_opcode = 70 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_EVENT_STATUS_NOTIFICATION : spdk_mmc_opcode = 74 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_PERFORMANCE : spdk_mmc_opcode = 172 ; pub const spdk_mmc_opcode_SPDK_MMC_INQUIRY : spdk_mmc_opcode = 18 ; pub const spdk_mmc_opcode_SPDK_MMC_LOAD_UNLOAD_MEDIUM : spdk_mmc_opcode = 166 ; pub const spdk_mmc_opcode_SPDK_MMC_MECHANISM_STATUS : spdk_mmc_opcode = 189 ; pub const spdk_mmc_opcode_SPDK_MMC_MODE_SELECT_10 : spdk_mmc_opcode = 85 ; pub const spdk_mmc_opcode_SPDK_MMC_MODE_SENSE_10 : spdk_mmc_opcode = 90 ; pub const spdk_mmc_opcode_SPDK_MMC_PAUSE_RESUME : spdk_mmc_opcode = 75 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_10 : spdk_mmc_opcode = 69 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_12 : spdk_mmc_opcode = 165 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_MSF : spdk_mmc_opcode = 71 ; pub const spdk_mmc_opcode_SPDK_MMC_PREVENT_ALLOW_MEDIUM_REMOVAL : spdk_mmc_opcode = 30 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_10 : spdk_mmc_opcode = 40 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_12 : spdk_mmc_opcode = 168 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_BUFFER : spdk_mmc_opcode = 60 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_BUFFER_CAPACITY : spdk_mmc_opcode = 92 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CAPACITY : spdk_mmc_opcode = 37 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CD : spdk_mmc_opcode = 190 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CD_MSF : spdk_mmc_opcode = 185 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DISC_INFORMATION : spdk_mmc_opcode = 81 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DVD_STRUCTURE : spdk_mmc_opcode = 173 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_FORMAT_CAPACITIES : spdk_mmc_opcode = 35 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_SUB_CHANNEL : spdk_mmc_opcode = 66 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_TOC_PMA_ATIP : spdk_mmc_opcode = 67 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_TRACK_INFORMATION : spdk_mmc_opcode = 82 ; pub const spdk_mmc_opcode_SPDK_MMC_REPAIR_TRACK : spdk_mmc_opcode = 88 ; pub const spdk_mmc_opcode_SPDK_MMC_REPORT_KEY : spdk_mmc_opcode = 164 ; pub const spdk_mmc_opcode_SPDK_MMC_REQUEST_SENSE : spdk_mmc_opcode = 3 ; pub const spdk_mmc_opcode_SPDK_MMC_RESERVE_TRACK : spdk_mmc_opcode = 83 ; pub const spdk_mmc_opcode_SPDK_MMC_SCAN : spdk_mmc_opcode = 186 ; pub const spdk_mmc_opcode_SPDK_MMC_SEEK_10 : spdk_mmc_opcode = 43 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_CUE_SHEET : spdk_mmc_opcode = 93 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_DVD_STRUCTURE : spdk_mmc_opcode = 191 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_KEY : spdk_mmc_opcode = 163 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_OPC_INFORMATION : spdk_mmc_opcode = 84 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_CD_SPEED : spdk_mmc_opcode = 187 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_READ_AHEAD : spdk_mmc_opcode = 167 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_STREAMING : spdk_mmc_opcode = 182 ; pub const spdk_mmc_opcode_SPDK_MMC_START_STOP_UNIT : spdk_mmc_opcode = 27 ; pub const spdk_mmc_opcode_SPDK_MMC_STOP_PLAY_SCAN : spdk_mmc_opcode = 78 ; pub const spdk_mmc_opcode_SPDK_MMC_SYNCHRONIZE_CACHE : spdk_mmc_opcode = 53 ; pub const spdk_mmc_opcode_SPDK_MMC_TEST_UNIT_READY : spdk_mmc_opcode = 0 ; pub const spdk_mmc_opcode_SPDK_MMC_VERIFY_10 : spdk_mmc_opcode = 47 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_10 : spdk_mmc_opcode = 162 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_12 : spdk_mmc_opcode = 170 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_AND_VERIFY_10 : spdk_mmc_opcode = 46 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_BUFFER : spdk_mmc_opcode = 59 ; pub type spdk_mmc_opcode = u32 ; pub const spdk_ssc_opcode_SPDK_SSC_ERASE_6 : spdk_ssc_opcode = 25 ; pub const spdk_ssc_opcode_SPDK_SSC_FORMAT_MEDIUM : spdk_ssc_opcode = 4 ; pub const spdk_ssc_opcode_SPDK_SSC_LOAD_UNLOAD : spdk_ssc_opcode = 27 ; pub const spdk_ssc_opcode_SPDK_SSC_LOCATE_10 : spdk_ssc_opcode = 43 ; pub const spdk_ssc_opcode_SPDK_SSC_LOCATE_16 : spdk_ssc_opcode = 146 ; pub const spdk_ssc_opcode_SPDK_SSC_MOVE_MEDIUM_ATTACHED : spdk_ssc_opcode = 167 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_6 : spdk_ssc_opcode = 8 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_BLOCK_LIMITS : spdk_ssc_opcode = 5 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_ELEMENT_STATUS_ATTACHED : spdk_ssc_opcode = 180 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_POSITION : spdk_ssc_opcode = 52 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_REVERSE_6 : spdk_ssc_opcode = 15 ; pub const spdk_ssc_opcode_SPDK_SSC_RECOVER_BUFFERED_DATA : spdk_ssc_opcode = 20 ; pub const spdk_ssc_opcode_SPDK_SSC_REPORT_DENSITY_SUPPORT : spdk_ssc_opcode = 68 ; pub const spdk_ssc_opcode_SPDK_SSC_REWIND : spdk_ssc_opcode = 1 ; pub const spdk_ssc_opcode_SPDK_SSC_SET_CAPACITY : spdk_ssc_opcode = 11 ; pub const spdk_ssc_opcode_SPDK_SSC_SPACE_6 : spdk_ssc_opcode = 17 ; pub const spdk_ssc_opcode_SPDK_SSC_SPACE_16 : spdk_ssc_opcode = 145 ; pub const spdk_ssc_opcode_SPDK_SSC_VERIFY_6 : spdk_ssc_opcode = 19 ; pub const spdk_ssc_opcode_SPDK_SSC_WRITE_6 : spdk_ssc_opcode = 10 ; pub const spdk_ssc_opcode_SPDK_SSC_WRITE_FILEMARKS_6 : spdk_ssc_opcode = 16 ; pub type spdk_ssc_opcode = u32 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_DEVICE_IDENTIFICATION : spdk_spc_vpd = 131 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_EXTENDED_INQUIRY_DATA : spdk_spc_vpd = 134 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_MANAGEMENT_NETWORK_ADDRESSES : spdk_spc_vpd = 133 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_MODE_PAGE_POLICY : spdk_spc_vpd = 135 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SCSI_PORTS : spdk_spc_vpd = 136 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SOFTWARE_INTERFACE_IDENTIFICATION : spdk_spc_vpd = 132 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SUPPORTED_VPD_PAGES : spdk_spc_vpd = 0 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_UNIT_SERIAL_NUMBER : spdk_spc_vpd = 128 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_LIMITS : spdk_spc_vpd = 176 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_DEV_CHARS : spdk_spc_vpd = 177 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_THIN_PROVISION : spdk_spc_vpd = 178 ; pub type spdk_spc_vpd = u32 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_CONNECTED : spdk_spc_peripheral_qualifier = 0 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_NOT_CONNECTED : spdk_spc_peripheral_qualifier = 1 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_NOT_CAPABLE : spdk_spc_peripheral_qualifier = 3 ; pub type spdk_spc_peripheral_qualifier = u32 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_DISK : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_TAPE : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_DVD : _bindgen_ty_34 = 5 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_CHANGER : _bindgen_ty_34 = 8 ; pub const SPDK_SPC_VERSION_NONE : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_VERSION_SPC : _bindgen_ty_34 = 3 ; pub const SPDK_SPC_VERSION_SPC2 : _bindgen_ty_34 = 4 ; pub const SPDK_SPC_VERSION_SPC3 : _bindgen_ty_34 = 5 ; pub const SPDK_SPC_VERSION_SPC4 : _bindgen_ty_34 = 6 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_FC : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_PSCSI : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_SSA : _bindgen_ty_34 = 2 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_IEEE1394 : _bindgen_ty_34 = 3 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_RDMA : _bindgen_ty_34 = 4 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ISCSI : _bindgen_ty_34 = 5 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_SAS : _bindgen_ty_34 = 6 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ADT : _bindgen_ty_34 = 7 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ATA : _bindgen_ty_34 = 8 ; pub const SPDK_SPC_VPD_CODE_SET_BINARY : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_VPD_CODE_SET_ASCII : _bindgen_ty_34 = 2 ; pub const SPDK_SPC_VPD_CODE_SET_UTF8 : _bindgen_ty_34 = 3 ; pub const SPDK_SPC_VPD_ASSOCIATION_LOGICAL_UNIT : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_VPD_ASSOCIATION_TARGET_PORT : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_VPD_ASSOCIATION_TARGET_DEVICE : _bindgen_ty_34 = 2 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_VENDOR_SPECIFIC : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_T10_VENDOR_ID : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_EUI64 : _bindgen_ty_34 = 2 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_NAA : _bindgen_ty_34 = 3 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_RELATIVE_TARGET_PORT : _bindgen_ty_34 = 4 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_TARGET_PORT_GROUP : _bindgen_ty_34 = 5 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_LOGICAL_UNIT_GROUP : _bindgen_ty_34 = 6 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_MD5_LOGICAL_UNIT : _bindgen_ty_34 = 7 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_SCSI_NAME : _bindgen_ty_34 = 8 ; pub type _bindgen_ty_34 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_cdb_inquiry { pub opcode : u8 , pub evpd : u8 , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub control : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_cdb_inquiry_data { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub rmb : u8 , pub version : u8 , pub response : u8 , pub add_len : u8 , pub flags : u8 , pub flags2 : u8 , pub flags3 : u8 , pub t10_vendor_id : [ u8 ; 8usize ] , pub product_id : [ u8 ; 16usize ] , pub product_rev : [ u8 ; 4usize ] , pub vendor : [ u8 ; 20usize ] , pub ius : u8 , pub reserved : u8 , pub desc : __IncompleteArrayField < u8 > , } impl spdk_scsi_cdb_inquiry_data { # [ inline ] pub fn peripheral_device_type ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_device_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn peripheral_qualifier ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_qualifier ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( peripheral_device_type : u8 , peripheral_qualifier : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let peripheral_device_type : u8 = unsafe { :: std :: mem :: transmute ( peripheral_device_type ) } ; peripheral_device_type as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let peripheral_qualifier : u8 = unsafe { :: std :: mem :: transmute ( peripheral_qualifier ) } ; peripheral_qualifier as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_vpd_page { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub params : __IncompleteArrayField < u8 > , } impl spdk_scsi_vpd_page { # [ inline ] pub fn peripheral_device_type ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_device_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn peripheral_qualifier ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_qualifier ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( peripheral_device_type : u8 , peripheral_qualifier : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let peripheral_device_type : u8 = unsafe { :: std :: mem :: transmute ( peripheral_device_type ) } ; peripheral_device_type as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let peripheral_qualifier : u8 = unsafe { :: std :: mem :: transmute ( peripheral_qualifier ) } ; peripheral_qualifier as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_scsi_vpd_ext_inquiry { pub peripheral : u8 , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub check : u8 , pub sup : u8 , pub sup2 : u8 , pub luiclr : u8 , pub cbcs : u8 , pub micro_dl : u8 , pub reserved : [ u8 ; 54usize ] , } impl Default for spdk_scsi_vpd_ext_inquiry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_desig_desc { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub reserved1 : u8 , pub len : u8 , pub desig : __IncompleteArrayField < u8 > , } impl spdk_scsi_desig_desc { # [ inline ] pub fn code_set ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_code_set ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn protocol_id ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_protocol_id ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn association ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_association ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved0 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved0 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn piv ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_piv ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( code_set : u8 , protocol_id : u8 , type_ : u8 , association : u8 , reserved0 : u8 , piv : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let code_set : u8 = unsafe { :: std :: mem :: transmute ( code_set ) } ; code_set as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let protocol_id : u8 = unsafe { :: std :: mem :: transmute ( protocol_id ) } ; protocol_id as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let association : u8 = unsafe { :: std :: mem :: transmute ( association ) } ; association as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let reserved0 : u8 = unsafe { :: std :: mem :: transmute ( reserved0 ) } ; reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let piv : u8 = unsafe { :: std :: mem :: transmute ( piv ) } ; piv as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_mpage_policy_desc { pub page_code : u8 , pub sub_page_code : u8 , pub policy : u8 , pub reserved : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_tgt_port_desc { pub code_set : u8 , pub desig_type : u8 , pub reserved : u8 , pub len : u8 , pub designator : __IncompleteArrayField < u8 > , } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_port_desc { pub reserved : u16 , pub rel_port_id : u16 , pub reserved2 : u16 , pub init_port_len : u16 , pub init_port_id : u16 , pub reserved3 : u16 , pub tgt_desc_len : u16 , pub tgt_desc : __IncompleteArrayField < u8 > , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_unmap_bdesc { pub lba : u64 , pub block_count : u32 , pub reserved : u32 , } pub const spdk_json_val_type_SPDK_JSON_VAL_INVALID : spdk_json_val_type = 0 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NULL : spdk_json_val_type = 1 ; pub const spdk_json_val_type_SPDK_JSON_VAL_TRUE : spdk_json_val_type = 2 ; pub const spdk_json_val_type_SPDK_JSON_VAL_FALSE : spdk_json_val_type = 3 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NUMBER : spdk_json_val_type = 4 ; pub const spdk_json_val_type_SPDK_JSON_VAL_STRING : spdk_json_val_type = 5 ; pub const spdk_json_val_type_SPDK_JSON_VAL_ARRAY_BEGIN : spdk_json_val_type = 6 ; pub const spdk_json_val_type_SPDK_JSON_VAL_ARRAY_END : spdk_json_val_type = 7 ; pub const spdk_json_val_type_SPDK_JSON_VAL_OBJECT_BEGIN : spdk_json_val_type = 8 ; pub const spdk_json_val_type_SPDK_JSON_VAL_OBJECT_END : spdk_json_val_type = 9 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NAME : spdk_json_val_type = 10 ; pub type spdk_json_val_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_val { pub start : * mut libc :: c_void , pub len : u32 , pub type_ : spdk_json_val_type , } impl Default for spdk_json_val { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_json_parse ( json : * mut libc :: c_void , size : usize , values : * mut spdk_json_val , num_values : usize , end : * mut * mut libc :: c_void , flags : u32 ) -> isize ; } pub type spdk_json_decode_fn = :: std :: option :: Option < unsafe extern "C" fn ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_object_decoder { pub name : * const libc :: c_char , pub offset : usize , pub decode_func : spdk_json_decode_fn , pub optional : bool , } impl Default for spdk_json_object_decoder { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_json_decode_object ( values : * const spdk_json_val , decoders : * const spdk_json_object_decoder , num_decoders : usize , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_array ( values : * const spdk_json_val , decode_func : spdk_json_decode_fn , out : * mut libc :: c_void , max_size : usize , out_size : * mut usize , stride : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_bool ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_uint16 ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_int32 ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_uint32 ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_uint64 ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_string ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_val_len ( val : * const spdk_json_val ) -> usize ; } extern "C" { pub fn spdk_json_strequal ( val : * const spdk_json_val , str : * const libc :: c_char ) -> bool ; } extern "C" { pub fn spdk_json_strdup ( val : * const spdk_json_val ) -> * mut libc :: c_char ; } extern "C" { pub fn spdk_json_number_to_uint16 ( val : * const spdk_json_val , num : * mut u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_number_to_int32 ( val : * const spdk_json_val , num : * mut i32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_number_to_uint32 ( val : * const spdk_json_val , num : * mut u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_number_to_uint64 ( val : * const spdk_json_val , num : * mut u64 ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_write_ctx { _unused : [ u8 ; 0 ] , } pub type spdk_json_write_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , data : * const libc :: c_void , size : usize ) -> libc :: c_int > ; extern "C" { pub fn spdk_json_write_begin ( write_cb : spdk_json_write_cb , cb_ctx : * mut libc :: c_void , flags : u32 ) -> * mut spdk_json_write_ctx ; } extern "C" { pub fn spdk_json_write_end ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_null ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_bool ( w : * mut spdk_json_write_ctx , val : bool ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_int32 ( w : * mut spdk_json_write_ctx , val : i32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_uint32 ( w : * mut spdk_json_write_ctx , val : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_int64 ( w : * mut spdk_json_write_ctx , val : i64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_uint64 ( w : * mut spdk_json_write_ctx , val : u64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string ( w : * mut spdk_json_write_ctx , val : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_raw ( w : * mut spdk_json_write_ctx , val : * const libc :: c_char , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_utf16le ( w : * mut spdk_json_write_ctx , val : * const u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_utf16le_raw ( w : * mut spdk_json_write_ctx , val : * const u16 , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_fmt ( w : * mut spdk_json_write_ctx , fmt : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_fmt_v ( w : * mut spdk_json_write_ctx , fmt : * const libc :: c_char , args : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_array_begin ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_array_end ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_object_begin ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_object_end ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_name ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_name_raw ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_val ( w : * mut spdk_json_write_ctx , val : * const spdk_json_val ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_val_raw ( w : * mut spdk_json_write_ctx , data : * const libc :: c_void , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_null ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_bool ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : bool ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_int32 ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : i32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_uint32 ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_uint64 ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : u64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_int64 ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : i64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_string ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_string_fmt ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , fmt : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_string_fmt_v ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , fmt : * const libc :: c_char , args : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_array_begin ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_object_begin ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char ) -> libc :: c_int ; } # [ doc = " Block device remove callback." ] # [ doc = "" ] # [ doc = " \\param remove_ctx Context for the removed block device." ] pub type spdk_bdev_remove_cb_t = :: std :: option :: Option < unsafe extern "C" fn ( remove_ctx : * mut libc :: c_void ) > ; # [ doc = " Block device I/O" ] # [ doc = "" ] # [ doc = " This is an I/O that is passed to an spdk_bdev." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_fn_table { _unused : [ u8 ; 0 ] , } pub const spdk_bdev_status_SPDK_BDEV_STATUS_INVALID : spdk_bdev_status = 0 ; pub const spdk_bdev_status_SPDK_BDEV_STATUS_READY : spdk_bdev_status = 1 ; pub const spdk_bdev_status_SPDK_BDEV_STATUS_REMOVING : spdk_bdev_status = 2 ; # [ doc = " bdev status" ] pub type spdk_bdev_status = u32 ; # [ doc = " \\brief SPDK block device." ] # [ doc = "" ] # [ doc = " This is a virtual representation of a block device that is exported by the backend." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev { _unused : [ u8 ; 0 ] , } # [ doc = " \\brief Handle to an opened SPDK block device." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_desc { _unused : [ u8 ; 0 ] , } pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_INVALID : spdk_bdev_io_type = 0 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_READ : spdk_bdev_io_type = 1 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_WRITE : spdk_bdev_io_type = 2 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_UNMAP : spdk_bdev_io_type = 3 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_FLUSH : spdk_bdev_io_type = 4 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_RESET : spdk_bdev_io_type = 5 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_ADMIN : spdk_bdev_io_type = 6 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_IO : spdk_bdev_io_type = 7 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_IO_MD : spdk_bdev_io_type = 8 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_WRITE_ZEROES : spdk_bdev_io_type = 9 ; pub const spdk_bdev_io_type_SPDK_BDEV_NUM_IO_TYPES : spdk_bdev_io_type = 10 ; # [ doc = " bdev I/O type" ] pub type spdk_bdev_io_type = u32 ; # [ doc = " IOPS rate limit for both read and write" ] pub const spdk_bdev_qos_rate_limit_type_SPDK_BDEV_QOS_RW_IOPS_RATE_LIMIT : spdk_bdev_qos_rate_limit_type = 0 ; # [ doc = " Byte per second rate limit for both read and write" ] pub const spdk_bdev_qos_rate_limit_type_SPDK_BDEV_QOS_RW_BPS_RATE_LIMIT : spdk_bdev_qos_rate_limit_type = 1 ; # [ doc = " Keep last" ] pub const spdk_bdev_qos_rate_limit_type_SPDK_BDEV_QOS_NUM_RATE_LIMIT_TYPES : spdk_bdev_qos_rate_limit_type = 2 ; # [ doc = " bdev QoS rate limit type" ] pub type spdk_bdev_qos_rate_limit_type = u32 ; # [ doc = " Block device completion callback." ] # [ doc = "" ] # [ doc = " \\param bdev_io Block device I/O that has completed." ] # [ doc = " \\param success True if I/O completed successfully or false if it failed;" ] # [ doc = " additional error information may be retrieved from bdev_io by calling" ] # [ doc = " spdk_bdev_io_get_nvme_status() or spdk_bdev_io_get_scsi_status()." ] # [ doc = " \\param cb_arg Callback argument specified when bdev_io was submitted." ] pub type spdk_bdev_io_completion_cb = :: std :: option :: Option < unsafe extern "C" fn ( bdev_io : * mut spdk_bdev_io , success : bool , cb_arg : * mut libc :: c_void ) > ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_io_stat { pub bytes_read : u64 , pub num_read_ops : u64 , pub bytes_written : u64 , pub num_write_ops : u64 , pub read_latency_ticks : u64 , pub write_latency_ticks : u64 , pub ticks_rate : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_opts { pub bdev_io_pool_size : u32 , pub bdev_io_cache_size : u32 , } extern "C" { pub fn spdk_bdev_get_opts ( opts : * mut spdk_bdev_opts ) ; } extern "C" { pub fn spdk_bdev_set_opts ( opts : * mut spdk_bdev_opts ) -> libc :: c_int ; } # [ doc = " Block device initialization callback." ] # [ doc = "" ] # [ doc = " \\param cb_arg Callback argument." ] # [ doc = " \\param rc 0 if block device initialized successfully or negative errno if it failed." ] pub type spdk_bdev_init_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , rc : libc :: c_int ) > ; # [ doc = " Block device finish callback." ] # [ doc = "" ] # [ doc = " \\param cb_arg Callback argument." ] pub type spdk_bdev_fini_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void ) > ; pub type spdk_bdev_get_device_stat_cb = :: std :: option :: Option < unsafe extern "C" fn ( bdev : * mut spdk_bdev , stat : * mut spdk_bdev_io_stat , cb_arg : * mut libc :: c_void , rc : libc :: c_int ) > ; extern "C" { # [ doc = " Initialize block device modules." ] # [ doc = "" ] # [ doc = " \\param cb_fn Called when the initialization is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bdev_initialize ( cb_fn : spdk_bdev_init_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Perform cleanup work to remove the registered block device modules." ] # [ doc = "" ] # [ doc = " \\param cb_fn Called when the removal is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bdev_finish ( cb_fn : spdk_bdev_fini_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Get the configuration options for the registered block device modules." ] # [ doc = "" ] # [ doc = " \\param fp The pointer to a file that will be written to the configuration options." ] pub fn spdk_bdev_config_text ( fp : * mut FILE ) ; } extern "C" { # [ doc = " Get the full configuration options for the registered block device modules and created bdevs." ] # [ doc = "" ] # [ doc = " \\param w pointer to a JSON write context where the configuration will be written." ] pub fn spdk_bdev_subsystem_config_json ( w : * mut spdk_json_write_ctx ) ; } extern "C" { # [ doc = " Get block device by the block device name." ] # [ doc = "" ] # [ doc = " \\param bdev_name The name of the block device." ] # [ doc = " \\return Block device associated with the name or NULL if no block device with" ] # [ doc = " bdev_name is currently registered." ] pub fn spdk_bdev_get_by_name ( bdev_name : * const libc :: c_char ) -> * mut spdk_bdev ; } extern "C" { # [ doc = " Get the first registered block device." ] # [ doc = "" ] # [ doc = " \\return The first registered block device." ] pub fn spdk_bdev_first ( ) -> * mut spdk_bdev ; } extern "C" { # [ doc = " Get the next registered block device." ] # [ doc = "" ] # [ doc = " \\param prev The current block device." ] # [ doc = " \\return The next registered block device." ] pub fn spdk_bdev_next ( prev : * mut spdk_bdev ) -> * mut spdk_bdev ; } extern "C" { # [ doc = " Get the first block device without virtual block devices on top." ] # [ doc = "" ] # [ doc = " This function only traverses over block devices which have no virtual block" ] # [ doc = " devices on top of them, then get the first one." ] # [ doc = "" ] # [ doc = " \\return The first block device without virtual block devices on top." ] pub fn spdk_bdev_first_leaf ( ) -> * mut spdk_bdev ; } extern "C" { # [ doc = " Get the next block device without virtual block devices on top." ] # [ doc = "" ] # [ doc = " This function only traverses over block devices which have no virtual block" ] # [ doc = " devices on top of them, then get the next one." ] # [ doc = "" ] # [ doc = " \\param prev The current block device." ] # [ doc = " \\return The next block device without virtual block devices on top." ] pub fn spdk_bdev_next_leaf ( prev : * mut spdk_bdev ) -> * mut spdk_bdev ; } extern "C" { # [ doc = " Open a block device for I/O operations." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to open." ] # [ doc = " \\param write true is read/write access requested, false if read-only" ] # [ doc = " \\param remove_cb callback function for hot remove the device. Will" ] # [ doc = " always be called on the same thread that spdk_bdev_open() was called on." ] # [ doc = " \\param remove_ctx param for hot removal callback function." ] # [ doc = " \\param desc output parameter for the descriptor when operation is successful" ] # [ doc = " \\return 0 if operation is successful, suitable errno value otherwise" ] pub fn spdk_bdev_open ( bdev : * mut spdk_bdev , write : bool , remove_cb : spdk_bdev_remove_cb_t , remove_ctx : * mut libc :: c_void , desc : * mut * mut spdk_bdev_desc ) -> libc :: c_int ; } extern "C" { # [ doc = " Close a previously opened block device." ] # [ doc = "" ] # [ doc = " Must be called on the same thread that the spdk_bdev_open()" ] # [ doc = " was performed on." ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor to close." ] pub fn spdk_bdev_close ( desc : * mut spdk_bdev_desc ) ; } extern "C" { # [ doc = " Get the bdev associated with a bdev descriptor." ] # [ doc = "" ] # [ doc = " \\param desc Open block device desciptor" ] # [ doc = " \\return bdev associated with the descriptor" ] pub fn spdk_bdev_desc_get_bdev ( desc : * mut spdk_bdev_desc ) -> * mut spdk_bdev ; } extern "C" { # [ doc = " Check whether the block device supports the I/O type." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to check." ] # [ doc = " \\param io_type The specific I/O type like read, write, flush, unmap." ] # [ doc = " \\return true if support, false otherwise." ] pub fn spdk_bdev_io_type_supported ( bdev : * mut spdk_bdev , io_type : spdk_bdev_io_type ) -> bool ; } extern "C" { # [ doc = " Output driver-specific information to a JSON stream." ] # [ doc = "" ] # [ doc = " The JSON write context will be initialized with an open object, so the bdev" ] # [ doc = " driver should write a name(based on the driver name) followed by a JSON value" ] # [ doc = " (most likely another nested object)." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\param w JSON write context. It will store the driver-specific configuration context." ] # [ doc = " \\return 0 on success, negated errno on failure." ] pub fn spdk_bdev_dump_info_json ( bdev : * mut spdk_bdev , w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { # [ doc = " Get block device name." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\return Name of bdev as a null-terminated string." ] pub fn spdk_bdev_get_name ( bdev : * const spdk_bdev ) -> * const libc :: c_char ; } extern "C" { # [ doc = " Get block device product name." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\return Product name of bdev as a null-terminated string." ] pub fn spdk_bdev_get_product_name ( bdev : * const spdk_bdev ) -> * const libc :: c_char ; } extern "C" { # [ doc = " Get block device logical block size." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\return Size of logical block for this bdev in bytes." ] pub fn spdk_bdev_get_block_size ( bdev : * const spdk_bdev ) -> u32 ; } extern "C" { # [ doc = " Get size of block device in logical blocks." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\return Size of bdev in logical blocks." ] # [ doc = "" ] # [ doc = " Logical blocks are numbered from 0 to spdk_bdev_get_num_blocks(bdev) - 1, inclusive." ] pub fn spdk_bdev_get_num_blocks ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { # [ doc = " Get the string of quality of service rate limit." ] # [ doc = "" ] # [ doc = " \\param type Type of rate limit to query." ] # [ doc = " \\return String of QoS type." ] pub fn spdk_bdev_get_qos_rpc_type ( type_ : spdk_bdev_qos_rate_limit_type ) -> * const libc :: c_char ; } extern "C" { # [ doc = " Get the quality of service rate limits on a bdev." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\param limits Pointer to the QoS rate limits array which holding the limits." ] # [ doc = "" ] # [ doc = " The limits are ordered based on the @ref spdk_bdev_qos_rate_limit_type enum." ] pub fn spdk_bdev_get_qos_rate_limits ( bdev : * mut spdk_bdev , limits : * mut u64 ) ; } extern "C" { # [ doc = " Set the quality of service rate limits on a bdev." ] # [ doc = "" ] # [ doc = " \\param bdev Block device." ] # [ doc = " \\param limits Pointer to the QoS rate limits array which holding the limits." ] # [ doc = " \\param cb_fn Callback function to be called when the QoS limit has been updated." ] # [ doc = " \\param cb_arg Argument to pass to cb_fn." ] # [ doc = "" ] # [ doc = " The limits are ordered based on the @ref spdk_bdev_qos_rate_limit_type enum." ] pub fn spdk_bdev_set_qos_rate_limits ( bdev : * mut spdk_bdev , limits : * mut u64 , cb_fn : :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , status : libc :: c_int ) > , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Get minimum I/O buffer address alignment for a bdev." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\return Required alignment of I/O buffers in bytes." ] pub fn spdk_bdev_get_buf_align ( bdev : * const spdk_bdev ) -> usize ; } extern "C" { # [ doc = " Get optimal I/O boundary for a bdev." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\return Optimal I/O boundary in blocks that should not be crossed for best performance, or 0 if" ] # [ doc = "         no optimal boundary is reported." ] pub fn spdk_bdev_get_optimal_io_boundary ( bdev : * const spdk_bdev ) -> u32 ; } extern "C" { # [ doc = " Query whether block device has an enabled write cache." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\return true if block device has a volatile write cache enabled." ] # [ doc = "" ] # [ doc = " If this function returns true, written data may not be persistent until a flush command" ] # [ doc = " is issued." ] pub fn spdk_bdev_has_write_cache ( bdev : * const spdk_bdev ) -> bool ; } extern "C" { # [ doc = " Get a bdev\'s UUID." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\return Pointer to UUID." ] # [ doc = "" ] # [ doc = " Not all bdevs will have a UUID; in this case, the returned UUID will be" ] # [ doc = " the nil UUID (all bytes zero)." ] pub fn spdk_bdev_get_uuid ( bdev : * const spdk_bdev ) -> * const spdk_uuid ; } extern "C" { # [ doc = " Get the most recently measured queue depth from a bdev." ] # [ doc = "" ] # [ doc = " The reported queue depth is the aggregate of outstanding I/O" ] # [ doc = " across all open channels associated with this bdev." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = "" ] # [ doc = " \\return The most recent queue depth measurement for the bdev." ] # [ doc = " If tracking is not enabled, the function will return UINT64_MAX" ] # [ doc = " It is also possible to receive UINT64_MAX after enabling tracking" ] # [ doc = " but before the first period has expired." ] pub fn spdk_bdev_get_qd ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { # [ doc = " Get the queue depth polling period." ] # [ doc = "" ] # [ doc = " The return value of this function is only valid if the bdev\'s" ] # [ doc = " queue depth tracking status is set to true." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = "" ] # [ doc = " \\return The period at which this bdev\'s gueue depth is being refreshed." ] pub fn spdk_bdev_get_qd_sampling_period ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { # [ doc = " Enable or disable queue depth sampling for this bdev." ] # [ doc = "" ] # [ doc = " Enables queue depth sampling when period is greater than 0. Disables it when the period" ] # [ doc = " is equal to zero. The resulting queue depth is stored in the spdk_bdev object as" ] # [ doc = " measured_queue_depth." ] # [ doc = "" ] # [ doc = " \\param bdev Block device on which to enable queue depth tracking." ] # [ doc = " \\param period The period at which to poll this bdev\'s queue depth. If this is set" ] # [ doc = " to zero, polling will be disabled." ] pub fn spdk_bdev_set_qd_sampling_period ( bdev : * mut spdk_bdev , period : u64 ) ; } extern "C" { # [ doc = " Get the time spent processing IO for this device." ] # [ doc = "" ] # [ doc = " This value is dependent upon the queue depth sampling period and is" ] # [ doc = " incremented at sampling time by the sampling period only if the measured" ] # [ doc = " queue depth is greater than 0." ] # [ doc = "" ] # [ doc = " The disk utilization can be calculated by the following formula:" ] # [ doc = " disk_util = (io_time_2 - io_time_1) / elapsed_time." ] # [ doc = " The user is responsible for tracking the elapsed time between two measurements." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = "" ] # [ doc = " \\return The io time for this device in microseconds." ] pub fn spdk_bdev_get_io_time ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { # [ doc = " Get the weighted IO processing time for this bdev." ] # [ doc = "" ] # [ doc = " This value is dependent upon the queue depth sampling period and is" ] # [ doc = " equal to the time spent reading from or writing to a device times" ] # [ doc = " the measured queue depth during each sampling period." ] # [ doc = "" ] # [ doc = " The average queue depth can be calculated by the following formula:" ] # [ doc = " queue_depth = (weighted_io_time_2 - weighted_io_time_1) / elapsed_time." ] # [ doc = " The user is responsible for tracking the elapsed time between two measurements." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = "" ] # [ doc = " \\return The weighted io time for this device in microseconds." ] pub fn spdk_bdev_get_weighted_io_time ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { # [ doc = " Obtain an I/O channel for the block device opened by the specified" ] # [ doc = " descriptor. I/O channels are bound to threads, so the resulting I/O" ] # [ doc = " channel may only be used from the thread it was originally obtained" ] # [ doc = " from." ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = "" ] # [ doc = " \\return A handle to the I/O channel or NULL on failure." ] pub fn spdk_bdev_get_io_channel ( desc : * mut spdk_bdev_desc ) -> * mut spdk_io_channel ; } extern "C" { # [ doc = " Submit a read request to the bdev on the given channel." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param buf Data buffer to read into." ] # [ doc = " \\param offset The offset, in bytes, from the start of the block device." ] # [ doc = " \\param nbytes The number of bytes to read." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset and/or nbytes are not aligned or out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] pub fn spdk_bdev_read ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut libc :: c_void , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a read request to the bdev on the given channel." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param buf Data buffer to read into." ] # [ doc = " \\param offset_blocks The offset, in blocks, from the start of the block device." ] # [ doc = " \\param num_blocks The number of blocks to read." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset_blocks and/or num_blocks are out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] pub fn spdk_bdev_read_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut libc :: c_void , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a read request to the bdev on the given channel. This differs from" ] # [ doc = " spdk_bdev_read by allowing the data buffer to be described in a scatter" ] # [ doc = " gather list. Some physical devices place memory alignment requirements on" ] # [ doc = " data and may not be able to directly transfer into the buffers provided. In" ] # [ doc = " this case, the request may fail." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param iov A scatter gather list of buffers to be read into." ] # [ doc = " \\param iovcnt The number of elements in iov." ] # [ doc = " \\param offset The offset, in bytes, from the start of the block device." ] # [ doc = " \\param nbytes The number of bytes to read." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset and/or nbytes are not aligned or out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] pub fn spdk_bdev_readv ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a read request to the bdev on the given channel. This differs from" ] # [ doc = " spdk_bdev_read by allowing the data buffer to be described in a scatter" ] # [ doc = " gather list. Some physical devices place memory alignment requirements on" ] # [ doc = " data and may not be able to directly transfer into the buffers provided. In" ] # [ doc = " this case, the request may fail." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param iov A scatter gather list of buffers to be read into." ] # [ doc = " \\param iovcnt The number of elements in iov." ] # [ doc = " \\param offset_blocks The offset, in blocks, from the start of the block device." ] # [ doc = " \\param num_blocks The number of blocks to read." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset_blocks and/or num_blocks are out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] pub fn spdk_bdev_readv_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write request to the bdev on the given channel." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param buf Data buffer to written from." ] # [ doc = " \\param offset The offset, in bytes, from the start of the block device." ] # [ doc = " \\param nbytes The number of bytes to write. buf must be greater than or equal to this size." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset and/or nbytes are not aligned or out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_write ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut libc :: c_void , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write request to the bdev on the given channel." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param buf Data buffer to written from." ] # [ doc = " \\param offset_blocks The offset, in blocks, from the start of the block device." ] # [ doc = " \\param num_blocks The number of blocks to write. buf must be greater than or equal to this size." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset_blocks and/or num_blocks are out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_write_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut libc :: c_void , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write request to the bdev on the given channel. This differs from" ] # [ doc = " spdk_bdev_write by allowing the data buffer to be described in a scatter" ] # [ doc = " gather list. Some physical devices place memory alignment requirements on" ] # [ doc = " data and may not be able to directly transfer out of the buffers provided. In" ] # [ doc = " this case, the request may fail." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param iov A scatter gather list of buffers to be written from." ] # [ doc = " \\param iovcnt The number of elements in iov." ] # [ doc = " \\param offset The offset, in bytes, from the start of the block device." ] # [ doc = " \\param len The size of data to write." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset and/or nbytes are not aligned or out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_writev ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , len : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write request to the bdev on the given channel. This differs from" ] # [ doc = " spdk_bdev_write by allowing the data buffer to be described in a scatter" ] # [ doc = " gather list. Some physical devices place memory alignment requirements on" ] # [ doc = " data and may not be able to directly transfer out of the buffers provided. In" ] # [ doc = " this case, the request may fail." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param iov A scatter gather list of buffers to be written from." ] # [ doc = " \\param iovcnt The number of elements in iov." ] # [ doc = " \\param offset_blocks The offset, in blocks, from the start of the block device." ] # [ doc = " \\param num_blocks The number of blocks to write." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset_blocks and/or num_blocks are out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_writev_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write zeroes request to the bdev on the given channel. This command" ] # [ doc = "  ensures that all bytes in the specified range are set to 00h" ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param offset The offset, in bytes, from the start of the block device." ] # [ doc = " \\param len The size of data to zero." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset and/or nbytes are not aligned or out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_write_zeroes ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , len : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a write zeroes request to the bdev on the given channel. This command" ] # [ doc = "  ensures that all bytes in the specified range are set to 00h" ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param offset_blocks The offset, in blocks, from the start of the block device." ] # [ doc = " \\param num_blocks The number of blocks to zero." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset_blocks and/or num_blocks are out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_write_zeroes_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit an unmap request to the block device. Unmap is sometimes also called trim or" ] # [ doc = " deallocate. This notifies the device that the data in the blocks described is no" ] # [ doc = " longer valid. Reading blocks that have been unmapped results in indeterminate data." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param offset The offset, in bytes, from the start of the block device." ] # [ doc = " \\param nbytes The number of bytes to unmap. Must be a multiple of the block size." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset and/or nbytes are not aligned or out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_unmap ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit an unmap request to the block device. Unmap is sometimes also called trim or" ] # [ doc = " deallocate. This notifies the device that the data in the blocks described is no" ] # [ doc = " longer valid. Reading blocks that have been unmapped results in indeterminate data." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param offset_blocks The offset, in blocks, from the start of the block device." ] # [ doc = " \\param num_blocks The number of blocks to unmap." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset_blocks and/or num_blocks are out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_unmap_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a flush request to the bdev on the given channel. For devices with volatile" ] # [ doc = " caches, data is not guaranteed to be persistent until the completion of a flush" ] # [ doc = " request. Call spdk_bdev_has_write_cache() to check if the bdev has a volatile cache." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param offset The offset, in bytes, from the start of the block device." ] # [ doc = " \\param length The number of bytes." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset and/or nbytes are not aligned or out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_flush ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , length : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a flush request to the bdev on the given channel. For devices with volatile" ] # [ doc = " caches, data is not guaranteed to be persistent until the completion of a flush" ] # [ doc = " request. Call spdk_bdev_has_write_cache() to check if the bdev has a volatile cache." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param offset_blocks The offset, in blocks, from the start of the block device." ] # [ doc = " \\param num_blocks The number of blocks." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -EINVAL - offset_blocks and/or num_blocks are out of range" ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_flush_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit a reset request to the bdev on the given channel." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] pub fn spdk_bdev_reset ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit an NVMe Admin command to the bdev. This passes directly through" ] # [ doc = " the block layer to the device. Support for NVMe passthru is optional," ] # [ doc = " indicated by calling spdk_bdev_io_type_supported()." ] # [ doc = "" ] # [ doc = " The SGL/PRP will be automated generated based on the given buffer," ] # [ doc = " so that portion of the command may be left empty." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " \\param desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param cmd The raw NVMe command. Must be an admin command." ] # [ doc = " \\param buf Data buffer to written from." ] # [ doc = " \\param nbytes The number of bytes to transfer. buf must be greater than or equal to this size." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_nvme_admin_passthru ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut libc :: c_void , nbytes : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit an NVMe I/O command to the bdev. This passes directly through" ] # [ doc = " the block layer to the device. Support for NVMe passthru is optional," ] # [ doc = " indicated by calling spdk_bdev_io_type_supported()." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " The SGL/PRP will be automated generated based on the given buffer," ] # [ doc = " so that portion of the command may be left empty. Also, the namespace" ] # [ doc = " id (nsid) will be populated automatically." ] # [ doc = "" ] # [ doc = " \\param bdev_desc Block device descriptor." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param cmd The raw NVMe command. Must be in the NVM command set." ] # [ doc = " \\param buf Data buffer to written from." ] # [ doc = " \\param nbytes The number of bytes to transfer. buf must be greater than or equal to this size." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_nvme_io_passthru ( bdev_desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut libc :: c_void , nbytes : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Submit an NVMe I/O command to the bdev. This passes directly through" ] # [ doc = " the block layer to the device. Support for NVMe passthru is optional," ] # [ doc = " indicated by calling spdk_bdev_io_type_supported()." ] # [ doc = "" ] # [ doc = " \\ingroup bdev_io_submit_functions" ] # [ doc = "" ] # [ doc = " The SGL/PRP will be automated generated based on the given buffer," ] # [ doc = " so that portion of the command may be left empty. Also, the namespace" ] # [ doc = " id (nsid) will be populated automatically." ] # [ doc = "" ] # [ doc = " \\param bdev_desc Block device descriptor" ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param cmd The raw NVMe command. Must be in the NVM command set." ] # [ doc = " \\param buf Data buffer to written from." ] # [ doc = " \\param nbytes The number of bytes to transfer. buf must be greater than or equal to this size." ] # [ doc = " \\param md_buf Meta data buffer to written from." ] # [ doc = " \\param md_len md_buf size to transfer. md_buf must be greater than or equal to this size." ] # [ doc = " \\param cb Called when the request is complete." ] # [ doc = " \\param cb_arg Argument passed to cb." ] # [ doc = "" ] # [ doc = " \\return 0 on success. On success, the callback will always" ] # [ doc = " be called (even if the request ultimately failed). Return" ] # [ doc = " negated errno on failure, in which case the callback will not be called." ] # [ doc = "   * -ENOMEM - spdk_bdev_io buffer cannot be allocated" ] # [ doc = "   * -EBADF - desc not open for writing" ] pub fn spdk_bdev_nvme_io_passthru_md ( bdev_desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut libc :: c_void , nbytes : usize , md_buf : * mut libc :: c_void , md_len : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { # [ doc = " Free an I/O request. This should only be called after the completion callback" ] # [ doc = " for the I/O has been called and notifies the bdev layer that memory may now" ] # [ doc = " be released." ] # [ doc = "" ] # [ doc = " \\param bdev_io I/O request." ] pub fn spdk_bdev_free_io ( bdev_io : * mut spdk_bdev_io ) ; } # [ doc = " Block device I/O wait callback" ] # [ doc = "" ] # [ doc = " Callback function to notify when an spdk_bdev_io structure is available" ] # [ doc = " to satisfy a call to one of the @ref bdev_io_submit_functions." ] pub type spdk_bdev_io_wait_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void ) > ; # [ doc = " Structure to register a callback when an spdk_bdev_io becomes available." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io_wait_entry { pub bdev : * mut spdk_bdev , pub cb_fn : spdk_bdev_io_wait_cb , pub cb_arg : * mut libc :: c_void , pub link : spdk_bdev_io_wait_entry__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io_wait_entry__bindgen_ty_1 { pub tqe_next : * mut spdk_bdev_io_wait_entry , pub tqe_prev : * mut * mut spdk_bdev_io_wait_entry , } impl Default for spdk_bdev_io_wait_entry__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_io_wait_entry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ doc = " Add an entry into the calling thread\'s queue to be notified when an" ] # [ doc = " spdk_bdev_io becomes available." ] # [ doc = "" ] # [ doc = " When one of the @ref bdev_io_submit_functions returns -ENOMEM, it means" ] # [ doc = " the spdk_bdev_io buffer pool has no available buffers. This function may" ] # [ doc = " be called to register a callback to be notified when a buffer becomes" ] # [ doc = " available on the calling thread." ] # [ doc = "" ] # [ doc = " The callback function will always be called on the same thread as this" ] # [ doc = " function was called." ] # [ doc = "" ] # [ doc = " This function must only be called immediately after one of the" ] # [ doc = " @ref bdev_io_submit_functions returns -ENOMEM." ] # [ doc = "" ] # [ doc = " \\param bdev Block device.  The block device that the caller will submit" ] # [ doc = "             an I/O to when the callback is invoked.  Must match the bdev" ] # [ doc = "             member in the entry parameter." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param entry Data structure allocated by the caller specifying the callback" ] # [ doc = "              function and argument." ] # [ doc = "" ] # [ doc = " \\return 0 on success." ] # [ doc = "         -EINVAL if bdev parameter does not match bdev member in entry" ] # [ doc = "         -EINVAL if an spdk_bdev_io structure was available on this thread." ] pub fn spdk_bdev_queue_io_wait ( bdev : * mut spdk_bdev , ch : * mut spdk_io_channel , entry : * mut spdk_bdev_io_wait_entry ) -> libc :: c_int ; } extern "C" { # [ doc = " Return I/O statistics for this channel." ] # [ doc = "" ] # [ doc = " \\param bdev Block device." ] # [ doc = " \\param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel()." ] # [ doc = " \\param stat The per-channel statistics." ] # [ doc = "" ] pub fn spdk_bdev_get_io_stat ( bdev : * mut spdk_bdev , ch : * mut spdk_io_channel , stat : * mut spdk_bdev_io_stat ) ; } extern "C" { # [ doc = " Return I/O statistics for this bdev. All the required information will be passed" ] # [ doc = " via the callback function." ] # [ doc = "" ] # [ doc = " \\param bdev Block device to query." ] # [ doc = " \\param stat Structure for aggregating collected statistics.  Passed as argument to cb." ] # [ doc = " \\param cb Called when this operation completes." ] # [ doc = " \\param cb_arg Argument passed to callback function." ] pub fn spdk_bdev_get_device_stat ( bdev : * mut spdk_bdev , stat : * mut spdk_bdev_io_stat , cb : spdk_bdev_get_device_stat_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Get the status of bdev_io as an NVMe status code." ] # [ doc = "" ] # [ doc = " \\param bdev_io I/O to get the status from." ] # [ doc = " \\param sct Status Code Type return value, as defined by the NVMe specification." ] # [ doc = " \\param sc Status Code return value, as defined by the NVMe specification." ] pub fn spdk_bdev_io_get_nvme_status ( bdev_io : * const spdk_bdev_io , sct : * mut libc :: c_int , sc : * mut libc :: c_int ) ; } extern "C" { # [ doc = " Get the status of bdev_io as a SCSI status code." ] # [ doc = "" ] # [ doc = " \\param bdev_io I/O to get the status from." ] # [ doc = " \\param sc SCSI Status Code." ] # [ doc = " \\param sk SCSI Sense Key." ] # [ doc = " \\param asc SCSI Additional Sense Code." ] # [ doc = " \\param ascq SCSI Additional Sense Code Qualifier." ] pub fn spdk_bdev_io_get_scsi_status ( bdev_io : * const spdk_bdev_io , sc : * mut libc :: c_int , sk : * mut libc :: c_int , asc : * mut libc :: c_int , ascq : * mut libc :: c_int ) ; } extern "C" { # [ doc = " Get the iovec describing the data buffer of a bdev_io." ] # [ doc = "" ] # [ doc = " \\param bdev_io I/O to describe with iovec." ] # [ doc = " \\param iovp Pointer to be filled with iovec." ] # [ doc = " \\param iovcntp Pointer to be filled with number of iovec entries." ] pub fn spdk_bdev_io_get_iovec ( bdev_io : * mut spdk_bdev_io , iovp : * mut * mut iovec , iovcntp : * mut libc :: c_int ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_module { _unused : [ u8 ; 0 ] , } extern "C" { # [ doc = " Create a blobstore block device from a bdev." ] # [ doc = "" ] # [ doc = " \\param bdev Bdev to use." ] # [ doc = " \\param remove_cb Called when the block device is removed." ] # [ doc = " \\param remove_ctx Argument passed to function remove_cb." ] # [ doc = "" ] # [ doc = " \\return a pointer to the blobstore block device on success or NULL otherwise." ] pub fn spdk_bdev_create_bs_dev ( bdev : * mut spdk_bdev , remove_cb : spdk_bdev_remove_cb_t , remove_ctx : * mut libc :: c_void ) -> * mut spdk_bs_dev ; } extern "C" { # [ doc = " Claim the bdev module for the given blobstore." ] # [ doc = "" ] # [ doc = " \\param bs_dev Blobstore block device." ] # [ doc = " \\param module Bdev module to claim." ] # [ doc = "" ] # [ doc = " \\return 0 on success, negative errno on failure." ] pub fn spdk_bs_bdev_claim ( bs_dev : * mut spdk_bs_dev , module : * mut spdk_bdev_module ) -> libc :: c_int ; } pub type spdk_blob_id = u64 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob_store { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_xattr_names { _unused : [ u8 ; 0 ] , } # [ doc = " Blobstore operation completion callback." ] # [ doc = "" ] # [ doc = " \\param cb_arg Callback argument." ] # [ doc = " \\param bserrno 0 if it completed successfully, or negative errno if it failed." ] pub type spdk_bs_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , bserrno : libc :: c_int ) > ; # [ doc = " Blobstore operation completion callback with handle." ] # [ doc = "" ] # [ doc = " \\param cb_arg Callback argument." ] # [ doc = " \\param bs Handle to a blobstore." ] # [ doc = " \\param bserrno 0 if it completed successfully, or negative errno if it failed." ] pub type spdk_bs_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , bs : * mut spdk_blob_store , bserrno : libc :: c_int ) > ; # [ doc = " Blob operation completion callback." ] # [ doc = "" ] # [ doc = " \\param cb_arg Callback argument." ] # [ doc = " \\param bserrno 0 if it completed successfully, or negative errno if it failed." ] pub type spdk_blob_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , bserrno : libc :: c_int ) > ; # [ doc = " Blob operation completion callback with blob ID." ] # [ doc = "" ] # [ doc = " \\param cb_arg Callback argument." ] # [ doc = " \\param blobid Blob ID." ] # [ doc = " \\param bserrno 0 if it completed successfully, or negative errno if it failed." ] pub type spdk_blob_op_with_id_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , blobid : spdk_blob_id , bserrno : libc :: c_int ) > ; # [ doc = " Blob operation completion callback with handle." ] # [ doc = "" ] # [ doc = " \\param cb_arg Callback argument." ] # [ doc = " \\param bs Handle to a blob." ] # [ doc = " \\param bserrno 0 if it completed successfully, or negative errno if it failed." ] pub type spdk_blob_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , blb : * mut spdk_blob , bserrno : libc :: c_int ) > ; # [ doc = " Blobstore device completion callback." ] # [ doc = "" ] # [ doc = " \\param channel I/O channel the operation was initiated on." ] # [ doc = " \\param cb_arg Callback argument." ] # [ doc = " \\param bserrno 0 if it completed successfully, or negative errno if it failed." ] pub type spdk_bs_dev_cpl = :: std :: option :: Option < unsafe extern "C" fn ( channel : * mut spdk_io_channel , cb_arg : * mut libc :: c_void , bserrno : libc :: c_int ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bs_dev_cb_args { pub cb_fn : spdk_bs_dev_cpl , pub channel : * mut spdk_io_channel , pub cb_arg : * mut libc :: c_void , } impl Default for spdk_bs_dev_cb_args { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bs_dev { pub create_channel : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev ) -> * mut spdk_io_channel > , pub destroy_channel : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel ) > , pub destroy : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev ) > , pub read : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub write : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub readv : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub writev : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub flush : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , cb_args : * mut spdk_bs_dev_cb_args ) > , pub write_zeroes : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub unmap : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub blockcnt : u64 , pub blocklen : u32 , } impl Default for spdk_bs_dev { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bs_type { pub bstype : [ libc :: c_char ; 16usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bs_opts { # [ doc = " Size of cluster in bytes. Must be multiple of 4KiB page size." ] pub cluster_sz : u32 , # [ doc = " Count of the number of pages reserved for metadata" ] pub num_md_pages : u32 , # [ doc = " Maximum simultaneous metadata operations" ] pub max_md_ops : u32 , # [ doc = " Maximum simultaneous operations per channel" ] pub max_channel_ops : u32 , # [ doc = " Blobstore type" ] pub bstype : spdk_bs_type , # [ doc = " Callback function to invoke for each blob." ] pub iter_cb_fn : spdk_blob_op_with_handle_complete , # [ doc = " Argument passed to iter_cb_fn for each blob." ] pub iter_cb_arg : * mut libc :: c_void , } impl Default for spdk_bs_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ doc = " Initialize a spdk_bs_opts structure to the default blobstore option values." ] # [ doc = "" ] # [ doc = " \\param opts The spdk_bs_opts structure to be initialized." ] pub fn spdk_bs_opts_init ( opts : * mut spdk_bs_opts ) ; } extern "C" { # [ doc = " Load a blobstore from the given device." ] # [ doc = "" ] # [ doc = " \\param dev Blobstore block device." ] # [ doc = " \\param opts The structure which contains the option values for the blobstore." ] # [ doc = " \\param cb_fn Called when the loading is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_load ( dev : * mut spdk_bs_dev , opts : * mut spdk_bs_opts , cb_fn : spdk_bs_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Initialize a blobstore on the given device." ] # [ doc = "" ] # [ doc = " \\param dev Blobstore block device." ] # [ doc = " \\param opts The structure which contains the option values for the blobstore." ] # [ doc = " \\param cb_fn Called when the initialization is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_init ( dev : * mut spdk_bs_dev , opts : * mut spdk_bs_opts , cb_fn : spdk_bs_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } pub type spdk_bs_dump_print_xattr = :: std :: option :: Option < unsafe extern "C" fn ( fp : * mut FILE , bstype : * const libc :: c_char , name : * const libc :: c_char , value : * const libc :: c_void , value_length : usize ) > ; extern "C" { # [ doc = " Dump a blobstore\'s metadata to a given FILE in human-readable format." ] # [ doc = "" ] # [ doc = " \\param dev Blobstore block device." ] # [ doc = " \\param fp FILE pointer to dump the metadata contents." ] # [ doc = " \\param print_xattr_fn Callback function to interpret external xattrs." ] # [ doc = " \\param cb_fn Called when the dump is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_dump ( dev : * mut spdk_bs_dev , fp : * mut FILE , print_xattr_fn : spdk_bs_dump_print_xattr , cb_fn : spdk_bs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Destroy the blobstore." ] # [ doc = "" ] # [ doc = " It will destroy the blobstore by zeroing the super block." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to destroy." ] # [ doc = " \\param cb_fn Called when the destruction is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_destroy ( bs : * mut spdk_blob_store , cb_fn : spdk_bs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Unload the blobstore." ] # [ doc = "" ] # [ doc = " It will flush all volatile data to disk." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to unload." ] # [ doc = " \\param cb_fn Called when the unloading is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_unload ( bs : * mut spdk_blob_store , cb_fn : spdk_bs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Set a super blob on the given blobstore." ] # [ doc = "" ] # [ doc = " This will be retrievable immediately after spdk_bs_load() on the next initializaiton." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param blobid The id of the blob which will be set as the super blob." ] # [ doc = " \\param cb_fn Called when the setting is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_set_super ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , cb_fn : spdk_bs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Get the super blob. The obtained blob id will be passed to the callback function." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_get_super ( bs : * mut spdk_blob_store , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Get the cluster size in bytes." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to query." ] # [ doc = "" ] # [ doc = " \\return cluster size." ] pub fn spdk_bs_get_cluster_size ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { # [ doc = " Get the page size in bytes. This is the write and read granularity of blobs." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to query." ] # [ doc = "" ] # [ doc = " \\return page size." ] pub fn spdk_bs_get_page_size ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { # [ doc = " Get the io unit size in bytes." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to query." ] # [ doc = "" ] # [ doc = " \\return io unit size." ] pub fn spdk_bs_get_io_unit_size ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { # [ doc = " Get the number of free clusters." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to query." ] # [ doc = "" ] # [ doc = " \\return the number of free clusters." ] pub fn spdk_bs_free_cluster_count ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { # [ doc = " Get the total number of clusters accessible by user." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to query." ] # [ doc = "" ] # [ doc = " \\return the total number of clusters accessible by user." ] pub fn spdk_bs_total_data_cluster_count ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { # [ doc = " Get the blob id." ] # [ doc = "" ] # [ doc = " \\param blob Blob struct to query." ] # [ doc = "" ] # [ doc = " \\return blob id." ] pub fn spdk_blob_get_id ( blob : * mut spdk_blob ) -> spdk_blob_id ; } extern "C" { # [ doc = " Get the number of pages allocated to the blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob struct to query." ] # [ doc = "" ] # [ doc = " \\return the number of pages." ] pub fn spdk_blob_get_num_pages ( blob : * mut spdk_blob ) -> u64 ; } extern "C" { # [ doc = " Get the number of io_units allocated to the blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob struct to query." ] # [ doc = "" ] # [ doc = " \\return the number of io_units." ] pub fn spdk_blob_get_num_io_units ( blob : * mut spdk_blob ) -> u64 ; } extern "C" { # [ doc = " Get the number of clusters allocated to the blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob struct to query." ] # [ doc = "" ] # [ doc = " \\return the number of clusters." ] pub fn spdk_blob_get_num_clusters ( blob : * mut spdk_blob ) -> u64 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob_xattr_opts { pub count : usize , pub names : * mut * mut libc :: c_char , pub ctx : * mut libc :: c_void , pub get_value : :: std :: option :: Option < unsafe extern "C" fn ( xattr_ctx : * mut libc :: c_void , name : * const libc :: c_char , value : * mut * const libc :: c_void , value_len : * mut usize ) > , } impl Default for spdk_blob_xattr_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob_opts { pub num_clusters : u64 , pub thin_provision : bool , pub xattrs : spdk_blob_xattr_opts , } impl Default for spdk_blob_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ doc = " Initialize a spdk_blob_opts structure to the default blob option values." ] # [ doc = "" ] # [ doc = " \\param opts spdk_blob_opts structure to initialize." ] pub fn spdk_blob_opts_init ( opts : * mut spdk_blob_opts ) ; } extern "C" { # [ doc = " Create a new blob with options on the given blobstore. The new blob id will" ] # [ doc = " be passed to the callback function." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param opts The structure which contains the option values for the new blob." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to funcion cb_fn." ] pub fn spdk_bs_create_blob_ext ( bs : * mut spdk_blob_store , opts : * const spdk_blob_opts , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Create a new blob with default option values on the given blobstore." ] # [ doc = " The new blob id will be passed to the callback function." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_create_blob ( bs : * mut spdk_blob_store , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Create a read-only snapshot of specified blob with provided options." ] # [ doc = " This will automatically sync specified blob." ] # [ doc = "" ] # [ doc = " When operation is done, original blob is converted to the thin-provisioned" ] # [ doc = " blob with a newly created read-only snapshot set as a backing blob." ] # [ doc = " Structure snapshot_xattrs as well as anything it references (like e.g. names" ] # [ doc = " array) must be valid until the completion is called." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param blobid Id of the source blob used to create a snapshot." ] # [ doc = " \\param snapshot_xattrs xattrs specified for snapshot." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_create_snapshot ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , snapshot_xattrs : * const spdk_blob_xattr_opts , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Create a clone of specified read-only blob." ] # [ doc = "" ] # [ doc = " Structure clone_xattrs as well as anything it references (like e.g. names" ] # [ doc = " array) must be valid until the completion is called." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param blobid Id of the read only blob used as a snapshot for new clone." ] # [ doc = " \\param clone_xattrs xattrs specified for clone." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_create_clone ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , clone_xattrs : * const spdk_blob_xattr_opts , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Provide table with blob id\'s of clones are dependent on specified snapshot." ] # [ doc = "" ] # [ doc = " Ids array should be allocated and the count parameter set to the number of" ] # [ doc = " id\'s it can store, before calling this function." ] # [ doc = "" ] # [ doc = " If ids is NULL or count parameter is not sufficient to handle ids of all" ] # [ doc = " clones, -ENOMEM error is returned and count parameter is updated to the" ] # [ doc = " total number of clones." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param blobid Snapshots blob id." ] # [ doc = " \\param ids Array of the clone ids or NULL to get required size in count." ] # [ doc = " \\param count Size of ids. After call it is updated to the number of clones." ] # [ doc = "" ] # [ doc = " \\return -ENOMEM if count is not sufficient to store all clones." ] pub fn spdk_blob_get_clones ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , ids : * mut spdk_blob_id , count : * mut usize ) -> libc :: c_int ; } extern "C" { # [ doc = " Get the blob id for the parent snapshot of this blob." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param blobid Blob id." ] # [ doc = "" ] # [ doc = " \\return blob id of parent blob or SPDK_BLOBID_INVALID if have no parent" ] pub fn spdk_blob_get_parent_snapshot ( bs : * mut spdk_blob_store , blobid : spdk_blob_id ) -> spdk_blob_id ; } extern "C" { # [ doc = " Check if blob is read only." ] # [ doc = "" ] # [ doc = " \\param blob Blob." ] # [ doc = "" ] # [ doc = " \\return true if blob is read only." ] pub fn spdk_blob_is_read_only ( blob : * mut spdk_blob ) -> bool ; } extern "C" { # [ doc = " Check if blob is a snapshot." ] # [ doc = "" ] # [ doc = " \\param blob Blob." ] # [ doc = "" ] # [ doc = " \\return true if blob is a snapshot." ] pub fn spdk_blob_is_snapshot ( blob : * mut spdk_blob ) -> bool ; } extern "C" { # [ doc = " Check if blob is a clone." ] # [ doc = "" ] # [ doc = " \\param blob Blob." ] # [ doc = "" ] # [ doc = " \\return true if blob is a clone." ] pub fn spdk_blob_is_clone ( blob : * mut spdk_blob ) -> bool ; } extern "C" { # [ doc = " Check if blob is thin-provisioned." ] # [ doc = "" ] # [ doc = " \\param blob Blob." ] # [ doc = "" ] # [ doc = " \\return true if blob is thin-provisioned." ] pub fn spdk_blob_is_thin_provisioned ( blob : * mut spdk_blob ) -> bool ; } extern "C" { # [ doc = " Delete an existing blob from the given blobstore." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param blobid The id of the blob to delete." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_delete_blob ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Allocate all clusters in this blob. Data for allocated clusters is copied" ] # [ doc = " from backing blob(s) if they exist." ] # [ doc = "" ] # [ doc = " This call removes all dependencies on any backing blobs." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param channel IO channel used to inflate blob." ] # [ doc = " \\param blobid The id of the blob to inflate." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_inflate_blob ( bs : * mut spdk_blob_store , channel : * mut spdk_io_channel , blobid : spdk_blob_id , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Remove dependency on parent blob." ] # [ doc = "" ] # [ doc = " This call allocates and copies data for any clusters that are allocated in" ] # [ doc = " the parent blob, and decouples parent updating dependencies of blob to" ] # [ doc = " its ancestor." ] # [ doc = "" ] # [ doc = " If blob have no parent -EINVAL error is reported." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param channel IO channel used to inflate blob." ] # [ doc = " \\param blobid The id of the blob." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_blob_decouple_parent ( bs : * mut spdk_blob_store , channel : * mut spdk_io_channel , blobid : spdk_blob_id , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Open a blob from the given blobstore." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\param blobid The id of the blob to open." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_open_blob ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , cb_fn : spdk_blob_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Resize a blob to \'sz\' clusters. These changes are not persisted to disk until" ] # [ doc = " spdk_bs_md_sync_blob() is called." ] # [ doc = " If called before previous resize finish, it will fail with errno -EBUSY" ] # [ doc = "" ] # [ doc = " \\param blob Blob to resize." ] # [ doc = " \\param sz The new number of clusters." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] # [ doc = "" ] pub fn spdk_blob_resize ( blob : * mut spdk_blob , sz : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Set blob as read only." ] # [ doc = "" ] # [ doc = " These changes do not take effect until spdk_blob_sync_md() is called." ] # [ doc = "" ] # [ doc = " \\param blob Blob to set." ] pub fn spdk_blob_set_read_only ( blob : * mut spdk_blob ) -> libc :: c_int ; } extern "C" { # [ doc = " Sync a blob." ] # [ doc = "" ] # [ doc = " Make a blob persistent. This applies to open, resize, set xattr, and remove" ] # [ doc = " xattr. These operations will not be persistent until the blob has been synced." ] # [ doc = "" ] # [ doc = " \\param blob Blob to sync." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_blob_sync_md ( blob : * mut spdk_blob , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Close a blob. This will automatically sync." ] # [ doc = "" ] # [ doc = " \\param blob Blob to close." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_blob_close ( blob : * mut spdk_blob , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Allocate an I/O channel for the given blobstore." ] # [ doc = "" ] # [ doc = " \\param bs blobstore." ] # [ doc = " \\return a pointer to the allocated I/O channel." ] pub fn spdk_bs_alloc_io_channel ( bs : * mut spdk_blob_store ) -> * mut spdk_io_channel ; } extern "C" { # [ doc = " Free the I/O channel." ] # [ doc = "" ] # [ doc = " \\param channel I/O channel to free." ] pub fn spdk_bs_free_io_channel ( channel : * mut spdk_io_channel ) ; } extern "C" { # [ doc = " Write data to a blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob to write." ] # [ doc = " \\param channel The I/O channel used to submit requests." ] # [ doc = " \\param payload The specified buffer which should contain the data to be written." ] # [ doc = " \\param offset Offset is in io units from the beginning of the blob." ] # [ doc = " \\param length Size of data in io units." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_blob_io_write ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Read data from a blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob to read." ] # [ doc = " \\param channel The I/O channel used to submit requests." ] # [ doc = " \\param payload The specified buffer which will store the obtained data." ] # [ doc = " \\param offset Offset is in io units from the beginning of the blob." ] # [ doc = " \\param length Size of data in io units." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_blob_io_read ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Write the data described by \'iov\' to \'length\' pages beginning at \'offset\' pages" ] # [ doc = " into the blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob to write." ] # [ doc = " \\param channel I/O channel used to submit requests." ] # [ doc = " \\param iov The pointer points to an array of iovec structures." ] # [ doc = " \\param iovcnt The number of buffers." ] # [ doc = " \\param offset Offset is in io units from the beginning of the blob." ] # [ doc = " \\param length Size of data in io units." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_blob_io_writev ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Read \'length\' pages starting at \'offset\' pages into the blob into the memory" ] # [ doc = " described by \'iov\'." ] # [ doc = "" ] # [ doc = " \\param blob Blob to read." ] # [ doc = " \\param channel I/O channel used to submit requests." ] # [ doc = " \\param iov The pointer points to an array of iovec structures." ] # [ doc = " \\param iovcnt The number of buffers." ] # [ doc = " \\param offset Offset is in io units from the beginning of the blob." ] # [ doc = " \\param length Size of data in io units." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_blob_io_readv ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Unmap \'length\' pages beginning at \'offset\' pages on the blob as unused. Unmapped" ] # [ doc = " pages may allow the underlying storage media to behave more effciently." ] # [ doc = "" ] # [ doc = " \\param blob Blob to unmap." ] # [ doc = " \\param channel I/O channel used to submit requests." ] # [ doc = " \\param offset Offset is in io units from the beginning of the blob." ] # [ doc = " \\param length Size of unmap area in pages." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_blob_io_unmap ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Write zeros into area of a blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob to write." ] # [ doc = " \\param channel I/O channel used to submit requests." ] # [ doc = " \\param offset Offset is in io units from the beginning of the blob." ] # [ doc = " \\param length Size of data in io units." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_blob_io_write_zeroes ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Get the first blob of the blobstore. The obtained blob will be passed to" ] # [ doc = " the callback function." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to traverse." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_iter_first ( bs : * mut spdk_blob_store , cb_fn : spdk_blob_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Get the next blob by using the current blob. The obtained blob will be passed" ] # [ doc = " to the callback function." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to traverse." ] # [ doc = " \\param blob The current blob." ] # [ doc = " \\param cb_fn Called when the operation is complete." ] # [ doc = " \\param cb_arg Argument passed to function cb_fn." ] pub fn spdk_bs_iter_next ( bs : * mut spdk_blob_store , blob : * mut spdk_blob , cb_fn : spdk_blob_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { # [ doc = " Set an extended attribute for the given blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob to set attribute." ] # [ doc = " \\param name Name of the extended attribute." ] # [ doc = " \\param value Value of the extended attribute." ] # [ doc = " \\param value_len Length of the value." ] # [ doc = "" ] # [ doc = " \\return 0 on success, -1 on failure." ] pub fn spdk_blob_set_xattr ( blob : * mut spdk_blob , name : * const libc :: c_char , value : * const libc :: c_void , value_len : u16 ) -> libc :: c_int ; } extern "C" { # [ doc = " Remove the extended attribute from the given blob." ] # [ doc = "" ] # [ doc = " \\param blob Blob to remove attribute." ] # [ doc = " \\param name Name of the extended attribute." ] # [ doc = "" ] # [ doc = " \\return 0 on success, negative errno on failure." ] pub fn spdk_blob_remove_xattr ( blob : * mut spdk_blob , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { # [ doc = " Get the value of the specified extended attribute. The obtained value and its" ] # [ doc = " size will be stored in value and value_len." ] # [ doc = "" ] # [ doc = " \\param blob Blob to query." ] # [ doc = " \\param name Name of the extended attribute." ] # [ doc = " \\param value Parameter as output." ] # [ doc = " \\param value_len Parameter as output." ] # [ doc = "" ] # [ doc = " \\return 0 on success, negative errno on failure." ] pub fn spdk_blob_get_xattr_value ( blob : * mut spdk_blob , name : * const libc :: c_char , value : * mut * const libc :: c_void , value_len : * mut usize ) -> libc :: c_int ; } extern "C" { # [ doc = " Iterate through all extended attributes of the blob. Get the names of all extended" ] # [ doc = " attributes that will be stored in names." ] # [ doc = "" ] # [ doc = " \\param blob Blob to query." ] # [ doc = " \\param names Parameter as output." ] # [ doc = "" ] # [ doc = " \\return 0 on success, negative errno on failure." ] pub fn spdk_blob_get_xattr_names ( blob : * mut spdk_blob , names : * mut * mut spdk_xattr_names ) -> libc :: c_int ; } extern "C" { # [ doc = " Get the number of extended attributes." ] # [ doc = "" ] # [ doc = " \\param names Names of total extended attributes of the blob." ] # [ doc = "" ] # [ doc = " \\return the number of extended attributes." ] pub fn spdk_xattr_names_get_count ( names : * mut spdk_xattr_names ) -> u32 ; } extern "C" { # [ doc = " Get the attribute name specified by the index." ] # [ doc = "" ] # [ doc = " \\param names Names of total extended attributes of the blob." ] # [ doc = " \\param index Index position of the specified attribute." ] # [ doc = "" ] # [ doc = " \\return attribute name." ] pub fn spdk_xattr_names_get_name ( names : * mut spdk_xattr_names , index : u32 ) -> * const libc :: c_char ; } extern "C" { # [ doc = " Free the attribute names." ] # [ doc = "" ] # [ doc = " \\param names Names of total extended attributes of the blob." ] pub fn spdk_xattr_names_free ( names : * mut spdk_xattr_names ) ; } extern "C" { # [ doc = " Get blobstore type of the given device." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to query." ] # [ doc = "" ] # [ doc = " \\return blobstore type." ] pub fn spdk_bs_get_bstype ( bs : * mut spdk_blob_store ) -> spdk_bs_type ; } extern "C" { # [ doc = " Set blobstore type to the given device." ] # [ doc = "" ] # [ doc = " \\param bs blobstore to set to." ] # [ doc = " \\param bstype Type label to set." ] pub fn spdk_bs_set_bstype ( bs : * mut spdk_blob_store , bstype : spdk_bs_type ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_thread { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_io_channel_iter { _unused : [ u8 ; 0 ] , } pub type spdk_thread_fn = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void ) > ; pub type spdk_thread_pass_msg = :: std :: option :: Option < unsafe extern "C" fn ( fn_ : spdk_thread_fn , ctx : * mut libc :: c_void , thread_ctx : * mut libc :: c_void ) > ; pub type spdk_poller_fn = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void ) -> libc :: c_int > ; pub type spdk_start_poller = :: std :: option :: Option < unsafe extern "C" fn ( thread_ctx : * mut libc :: c_void , fn_ : spdk_poller_fn , arg : * mut libc :: c_void , period_microseconds : u64 ) -> * mut spdk_poller > ; pub type spdk_stop_poller = :: std :: option :: Option < unsafe extern "C" fn ( poller : * mut spdk_poller , thread_ctx : * mut libc :: c_void ) > ; pub type spdk_io_channel_create_cb = :: std :: option :: Option < unsafe extern "C" fn ( io_device : * mut libc :: c_void , ctx_buf : * mut libc :: c_void ) -> libc :: c_int > ; pub type spdk_io_channel_destroy_cb = :: std :: option :: Option < unsafe extern "C" fn ( io_device : * mut libc :: c_void , ctx_buf : * mut libc :: c_void ) > ; pub type spdk_io_device_unregister_cb = :: std :: option :: Option < unsafe extern "C" fn ( io_device : * mut libc :: c_void ) > ; pub type spdk_channel_msg = :: std :: option :: Option < unsafe extern "C" fn ( i : * mut spdk_io_channel_iter ) > ; pub type spdk_channel_for_each_cpl = :: std :: option :: Option < unsafe extern "C" fn ( i : * mut spdk_io_channel_iter , status : libc :: c_int ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_io_channel { pub thread : * mut spdk_thread , pub dev : * mut io_device , pub ref_ : u32 , pub destroy_ref : u32 , pub tailq : spdk_io_channel__bindgen_ty_1 , pub destroy_cb : spdk_io_channel_destroy_cb , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_io_channel__bindgen_ty_1 { pub tqe_next : * mut spdk_io_channel , pub tqe_prev : * mut * mut spdk_io_channel , } impl Default for spdk_io_channel__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_io_channel { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_thread_lib_init ( ) -> libc :: c_int ; } extern "C" { pub fn spdk_thread_lib_fini ( ) ; } extern "C" { pub fn spdk_allocate_thread ( msg_fn : spdk_thread_pass_msg , start_poller_fn : spdk_start_poller , stop_poller_fn : spdk_stop_poller , thread_ctx : * mut libc :: c_void , name : * const libc :: c_char ) -> * mut spdk_thread ; } extern "C" { pub fn spdk_free_thread ( ) ; } extern "C" { pub fn spdk_thread_get_count ( ) -> u32 ; } extern "C" { pub fn spdk_get_thread ( ) -> * mut spdk_thread ; } extern "C" { pub fn spdk_thread_get_name ( thread : * const spdk_thread ) -> * const libc :: c_char ; } extern "C" { pub fn spdk_thread_send_msg ( thread : * const spdk_thread , fn_ : spdk_thread_fn , ctx : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_for_each_thread ( fn_ : spdk_thread_fn , ctx : * mut libc :: c_void , cpl : spdk_thread_fn ) ; } extern "C" { pub fn spdk_poller_register ( fn_ : spdk_poller_fn , arg : * mut libc :: c_void , period_microseconds : u64 ) -> * mut spdk_poller ; } extern "C" { pub fn spdk_poller_unregister ( ppoller : * mut * mut spdk_poller ) ; } extern "C" { pub fn spdk_io_device_register ( io_device : * mut libc :: c_void , create_cb : spdk_io_channel_create_cb , destroy_cb : spdk_io_channel_destroy_cb , ctx_size : u32 , name : * const libc :: c_char ) ; } extern "C" { pub fn spdk_io_device_unregister ( io_device : * mut libc :: c_void , unregister_cb : spdk_io_device_unregister_cb ) ; } extern "C" { pub fn spdk_get_io_channel ( io_device : * mut libc :: c_void ) -> * mut spdk_io_channel ; } extern "C" { pub fn spdk_put_io_channel ( ch : * mut spdk_io_channel ) ; } extern "C" { pub fn spdk_io_channel_from_ctx ( ctx : * mut libc :: c_void ) -> * mut spdk_io_channel ; } extern "C" { pub fn spdk_io_channel_get_thread ( ch : * mut spdk_io_channel ) -> * mut spdk_thread ; } extern "C" { pub fn spdk_for_each_channel ( io_device : * mut libc :: c_void , fn_ : spdk_channel_msg , ctx : * mut libc :: c_void , cpl : spdk_channel_for_each_cpl ) ; } extern "C" { pub fn spdk_io_channel_iter_get_io_device ( i : * mut spdk_io_channel_iter ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_io_channel_iter_get_channel ( i : * mut spdk_io_channel_iter ) -> * mut spdk_io_channel ; } extern "C" { pub fn spdk_io_channel_iter_get_ctx ( i : * mut spdk_io_channel_iter ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_for_each_channel_continue ( i : * mut spdk_io_channel_iter , status : libc :: c_int ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : libc :: c_uint , pub fp_offset : libc :: c_uint , pub overflow_arg_area : * mut libc :: c_void , pub reg_save_area : * mut libc :: c_void , } impl Default for __va_list_tag { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iface { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct io_device { pub _address : u8 , }