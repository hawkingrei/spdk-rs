/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index =
            if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index =
            if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index =
                if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
 # [ repr ( C ) ] # [ derive ( Default ) ] pub struct __IncompleteArrayField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __IncompleteArrayField < T > { # [ inline ] pub fn new ( ) -> Self { __IncompleteArrayField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ptr ( & self ) -> * const T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut_ptr ( & mut self ) -> * mut T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_slice ( & self , len : usize ) -> & [ T ] { :: std :: slice :: from_raw_parts ( self . as_ptr ( ) , len ) } # [ inline ] pub unsafe fn as_mut_slice ( & mut self , len : usize ) -> & mut [ T ] { :: std :: slice :: from_raw_parts_mut ( self . as_mut_ptr ( ) , len ) } } impl < T > :: std :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter < '_ > ) -> :: std :: fmt :: Result { fmt . write_str ( "__IncompleteArrayField" ) } } impl < T > :: std :: clone :: Clone for __IncompleteArrayField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __IncompleteArrayField < T > { } extern "C" { pub fn __assert_fail ( __assertion : * const libc :: c_char , __file : * const libc :: c_char , __line : libc :: c_uint , __function : * const libc :: c_char ) ; } extern "C" { pub fn __assert_perror_fail ( __errnum : libc :: c_int , __file : * const libc :: c_char , __line : libc :: c_uint , __function : * const libc :: c_char ) ; } extern "C" { pub fn __assert ( __assertion : * const libc :: c_char , __file : * const libc :: c_char , __line : libc :: c_int ) ; } pub type __u_char = libc :: c_uchar ; pub type __u_short = libc :: c_ushort ; pub type __u_int = libc :: c_uint ; pub type __u_long = libc :: c_ulong ; pub type __int8_t = libc :: c_schar ; pub type __uint8_t = libc :: c_uchar ; pub type __int16_t = libc :: c_short ; pub type __uint16_t = libc :: c_ushort ; pub type __int32_t = libc :: c_int ; pub type __uint32_t = libc :: c_uint ; pub type __int64_t = libc :: c_long ; pub type __uint64_t = libc :: c_ulong ; pub type __quad_t = libc :: c_long ; pub type __u_quad_t = libc :: c_ulong ; pub type __intmax_t = libc :: c_long ; pub type __uintmax_t = libc :: c_ulong ; pub type __dev_t = libc :: c_ulong ; pub type __uid_t = libc :: c_uint ; pub type __gid_t = libc :: c_uint ; pub type __ino_t = libc :: c_ulong ; pub type __ino64_t = libc :: c_ulong ; pub type __mode_t = libc :: c_uint ; pub type __nlink_t = libc :: c_ulong ; pub type __off_t = libc :: c_long ; pub type __off64_t = libc :: c_long ; pub type __pid_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ libc :: c_int ; 2usize ] , } pub type __clock_t = libc :: c_long ; pub type __rlim_t = libc :: c_ulong ; pub type __rlim64_t = libc :: c_ulong ; pub type __id_t = libc :: c_uint ; pub type __time_t = libc :: c_long ; pub type __useconds_t = libc :: c_uint ; pub type __suseconds_t = libc :: c_long ; pub type __daddr_t = libc :: c_int ; pub type __key_t = libc :: c_int ; pub type __clockid_t = libc :: c_int ; pub type __timer_t = * mut libc :: c_void ; pub type __blksize_t = libc :: c_long ; pub type __blkcnt_t = libc :: c_long ; pub type __blkcnt64_t = libc :: c_long ; pub type __fsblkcnt_t = libc :: c_ulong ; pub type __fsblkcnt64_t = libc :: c_ulong ; pub type __fsfilcnt_t = libc :: c_ulong ; pub type __fsfilcnt64_t = libc :: c_ulong ; pub type __fsword_t = libc :: c_long ; pub type __ssize_t = libc :: c_long ; pub type __syscall_slong_t = libc :: c_long ; pub type __syscall_ulong_t = libc :: c_ulong ; pub type __loff_t = __off64_t ; pub type __caddr_t = * mut libc :: c_char ; pub type __intptr_t = libc :: c_long ; pub type __socklen_t = libc :: c_uint ; pub type __sig_atomic_t = libc :: c_int ; pub const _ISupper : _bindgen_ty_1 = 256 ; pub const _ISlower : _bindgen_ty_1 = 512 ; pub const _ISalpha : _bindgen_ty_1 = 1024 ; pub const _ISdigit : _bindgen_ty_1 = 2048 ; pub const _ISxdigit : _bindgen_ty_1 = 4096 ; pub const _ISspace : _bindgen_ty_1 = 8192 ; pub const _ISprint : _bindgen_ty_1 = 16384 ; pub const _ISgraph : _bindgen_ty_1 = 32768 ; pub const _ISblank : _bindgen_ty_1 = 1 ; pub const _IScntrl : _bindgen_ty_1 = 2 ; pub const _ISpunct : _bindgen_ty_1 = 4 ; pub const _ISalnum : _bindgen_ty_1 = 8 ; pub type _bindgen_ty_1 = u32 ; extern "C" { pub fn __ctype_b_loc ( ) -> * mut * const libc :: c_ushort ; } extern "C" { pub fn __ctype_tolower_loc ( ) -> * mut * const __int32_t ; } extern "C" { pub fn __ctype_toupper_loc ( ) -> * mut * const __int32_t ; } extern "C" { pub fn isalnum ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isalpha ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn iscntrl ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isdigit ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn islower ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isgraph ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isprint ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ispunct ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isspace ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isupper ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isxdigit ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tolower ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn toupper ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isblank ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isascii ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn toascii ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _toupper ( arg1 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _tolower ( arg1 : libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const libc :: c_ushort , pub __ctype_tolower : * const libc :: c_int , pub __ctype_toupper : * const libc :: c_int , pub __names : [ * const libc :: c_char ; 13usize ] , } impl Default for __locale_struct { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { pub fn isalnum_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isalpha_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn iscntrl_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isdigit_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn islower_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isgraph_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isprint_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn ispunct_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isspace_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isupper_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isxdigit_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn isblank_l ( arg1 : libc :: c_int , arg2 : locale_t ) -> libc :: c_int ; } extern "C" { pub fn __tolower_l ( __c : libc :: c_int , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn tolower_l ( __c : libc :: c_int , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn __toupper_l ( __c : libc :: c_int , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn toupper_l ( __c : libc :: c_int , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn __errno_location ( ) -> * mut libc :: c_int ; } pub type int_least8_t = libc :: c_schar ; pub type int_least16_t = libc :: c_short ; pub type int_least32_t = libc :: c_int ; pub type int_least64_t = libc :: c_long ; pub type uint_least8_t = libc :: c_uchar ; pub type uint_least16_t = libc :: c_ushort ; pub type uint_least32_t = libc :: c_uint ; pub type uint_least64_t = libc :: c_ulong ; pub type int_fast8_t = libc :: c_schar ; pub type int_fast16_t = libc :: c_long ; pub type int_fast32_t = libc :: c_long ; pub type int_fast64_t = libc :: c_long ; pub type uint_fast8_t = libc :: c_uchar ; pub type uint_fast16_t = libc :: c_ulong ; pub type uint_fast32_t = libc :: c_ulong ; pub type uint_fast64_t = libc :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; pub type __gwchar_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct imaxdiv_t { pub quot : libc :: c_long , pub rem : libc :: c_long , } extern "C" { pub fn imaxabs ( __n : intmax_t ) -> intmax_t ; } extern "C" { pub fn imaxdiv ( __numer : intmax_t , __denom : intmax_t ) -> imaxdiv_t ; } extern "C" { pub fn strtoimax ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> intmax_t ; } extern "C" { pub fn strtoumax ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> uintmax_t ; } extern "C" { pub fn wcstoimax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : libc :: c_int ) -> intmax_t ; } extern "C" { pub fn wcstoumax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : libc :: c_int ) -> uintmax_t ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; pub type wchar_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : libc :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 , } pub type __FILE = _IO_FILE ; pub type FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : libc :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : libc :: c_uint , pub __wchb : [ libc :: c_char ; 4usize ] , _bindgen_union_align : u32 , } impl Default for __mbstate_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for __mbstate_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } impl Default for _G_fpos_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } impl Default for _G_fpos64_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t { _unused : [ u8 ; 0 ] , } pub type _IO_lock_t = libc :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : libc :: c_int , } impl Default for _IO_marker { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const __codecvt_result___codecvt_ok : __codecvt_result = 0 ; pub const __codecvt_result___codecvt_partial : __codecvt_result = 1 ; pub const __codecvt_result___codecvt_error : __codecvt_result = 2 ; pub const __codecvt_result___codecvt_noconv : __codecvt_result = 3 ; pub type __codecvt_result = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE { pub _flags : libc :: c_int , pub _IO_read_ptr : * mut libc :: c_char , pub _IO_read_end : * mut libc :: c_char , pub _IO_read_base : * mut libc :: c_char , pub _IO_write_base : * mut libc :: c_char , pub _IO_write_ptr : * mut libc :: c_char , pub _IO_write_end : * mut libc :: c_char , pub _IO_buf_base : * mut libc :: c_char , pub _IO_buf_end : * mut libc :: c_char , pub _IO_save_base : * mut libc :: c_char , pub _IO_backup_base : * mut libc :: c_char , pub _IO_save_end : * mut libc :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : libc :: c_int , pub _flags2 : libc :: c_int , pub _old_offset : __off_t , pub _cur_column : libc :: c_ushort , pub _vtable_offset : libc :: c_schar , pub _shortbuf : [ libc :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut libc :: c_void , pub __pad2 : * mut libc :: c_void , pub __pad3 : * mut libc :: c_void , pub __pad4 : * mut libc :: c_void , pub __pad5 : usize , pub _mode : libc :: c_int , pub _unused2 : [ libc :: c_char ; 20usize ] , } impl Default for _IO_FILE { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE_plus { _unused : [ u8 ; 0 ] , } pub type __io_read_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut libc :: c_void , __buf : * mut libc :: c_char , __nbytes : usize ) -> __ssize_t > ; pub type __io_write_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut libc :: c_void , __buf : * const libc :: c_char , __n : usize ) -> __ssize_t > ; pub type __io_seek_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut libc :: c_void , __pos : * mut __off64_t , __w : libc :: c_int ) -> libc :: c_int > ; pub type __io_close_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut libc :: c_void ) -> libc :: c_int > ; extern "C" { pub fn __underflow ( arg1 : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn __uflow ( arg1 : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn __overflow ( arg1 : * mut _IO_FILE , arg2 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _IO_getc ( __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_putc ( __c : libc :: c_int , __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_feof ( __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_ferror ( __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_peekc_locked ( __fp : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_flockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_funlockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_ftrylockfile ( arg1 : * mut _IO_FILE ) -> libc :: c_int ; } extern "C" { pub fn _IO_vfscanf ( arg1 : * mut _IO_FILE , arg2 : * const libc :: c_char , arg3 : * mut __va_list_tag , arg4 : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _IO_vfprintf ( arg1 : * mut _IO_FILE , arg2 : * const libc :: c_char , arg3 : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn _IO_padn ( arg1 : * mut _IO_FILE , arg2 : libc :: c_int , arg3 : __ssize_t ) -> __ssize_t ; } extern "C" { pub fn _IO_sgetn ( arg1 : * mut _IO_FILE , arg2 : * mut libc :: c_void , arg3 : usize ) -> usize ; } extern "C" { pub fn _IO_seekoff ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : libc :: c_int , arg4 : libc :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_seekpos ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : libc :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_free_backup_area ( arg1 : * mut _IO_FILE ) ; } pub type off_t = __off_t ; pub type fpos_t = _G_fpos_t ; extern "C" { pub fn remove ( __filename : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn rename ( __old : * const libc :: c_char , __new : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn renameat ( __oldfd : libc :: c_int , __old : * const libc :: c_char , __newfd : libc :: c_int , __new : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { pub fn tmpnam ( __s : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn tmpnam_r ( __s : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn tempnam ( __dir : * const libc :: c_char , __pfx : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn fclose ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fflush ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fflush_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fopen ( __filename : * const libc :: c_char , __modes : * const libc :: c_char ) -> * mut FILE ; } extern "C" { pub fn freopen ( __filename : * const libc :: c_char , __modes : * const libc :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn fdopen ( __fd : libc :: c_int , __modes : * const libc :: c_char ) -> * mut FILE ; } extern "C" { pub fn fmemopen ( __s : * mut libc :: c_void , __len : usize , __modes : * const libc :: c_char ) -> * mut FILE ; } extern "C" { pub fn open_memstream ( __bufloc : * mut * mut libc :: c_char , __sizeloc : * mut usize ) -> * mut FILE ; } extern "C" { pub fn setbuf ( __stream : * mut FILE , __buf : * mut libc :: c_char ) ; } extern "C" { pub fn setvbuf ( __stream : * mut FILE , __buf : * mut libc :: c_char , __modes : libc :: c_int , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn setbuffer ( __stream : * mut FILE , __buf : * mut libc :: c_char , __size : usize ) ; } extern "C" { pub fn setlinebuf ( __stream : * mut FILE ) ; } extern "C" { pub fn fprintf ( __stream : * mut FILE , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn printf ( __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn sprintf ( __s : * mut libc :: c_char , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn vfprintf ( __s : * mut FILE , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vprintf ( __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vsprintf ( __s : * mut libc :: c_char , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn snprintf ( __s : * mut libc :: c_char , __maxlen : usize , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn vsnprintf ( __s : * mut libc :: c_char , __maxlen : usize , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vdprintf ( __fd : libc :: c_int , __fmt : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn dprintf ( __fd : libc :: c_int , __fmt : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn fscanf ( __stream : * mut FILE , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn scanf ( __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn sscanf ( __s : * const libc :: c_char , __format : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn vfscanf ( __s : * mut FILE , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vscanf ( __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn vsscanf ( __s : * const libc :: c_char , __format : * const libc :: c_char , __arg : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn fgetc ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn getc ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn getchar ( ) -> libc :: c_int ; } extern "C" { pub fn getc_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn getchar_unlocked ( ) -> libc :: c_int ; } extern "C" { pub fn fgetc_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fputc ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putc ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putchar ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn fputc_unlocked ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putc_unlocked ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putchar_unlocked ( __c : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getw ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn putw ( __w : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fgets ( __s : * mut libc :: c_char , __n : libc :: c_int , __stream : * mut FILE ) -> * mut libc :: c_char ; } extern "C" { pub fn __getdelim ( __lineptr : * mut * mut libc :: c_char , __n : * mut usize , __delimiter : libc :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getdelim ( __lineptr : * mut * mut libc :: c_char , __n : * mut usize , __delimiter : libc :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getline ( __lineptr : * mut * mut libc :: c_char , __n : * mut usize , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn fputs ( __s : * const libc :: c_char , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn puts ( __s : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn ungetc ( __c : libc :: c_int , __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fread ( __ptr : * mut libc :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite ( __ptr : * const libc :: c_void , __size : usize , __n : usize , __s : * mut FILE ) -> usize ; } extern "C" { pub fn fread_unlocked ( __ptr : * mut libc :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite_unlocked ( __ptr : * const libc :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fseek ( __stream : * mut FILE , __off : libc :: c_long , __whence : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ftell ( __stream : * mut FILE ) -> libc :: c_long ; } extern "C" { pub fn rewind ( __stream : * mut FILE ) ; } extern "C" { pub fn fseeko ( __stream : * mut FILE , __off : __off_t , __whence : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ftello ( __stream : * mut FILE ) -> __off_t ; } extern "C" { pub fn fgetpos ( __stream : * mut FILE , __pos : * mut fpos_t ) -> libc :: c_int ; } extern "C" { pub fn fsetpos ( __stream : * mut FILE , __pos : * const fpos_t ) -> libc :: c_int ; } extern "C" { pub fn clearerr ( __stream : * mut FILE ) ; } extern "C" { pub fn feof ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn ferror ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn clearerr_unlocked ( __stream : * mut FILE ) ; } extern "C" { pub fn feof_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn ferror_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn perror ( __s : * const libc :: c_char ) ; } extern "C" { pub fn fileno ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn fileno_unlocked ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn popen ( __command : * const libc :: c_char , __modes : * const libc :: c_char ) -> * mut FILE ; } extern "C" { pub fn pclose ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn ctermid ( __s : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn flockfile ( __stream : * mut FILE ) ; } extern "C" { pub fn ftrylockfile ( __stream : * mut FILE ) -> libc :: c_int ; } extern "C" { pub fn funlockfile ( __stream : * mut FILE ) ; } pub const idtype_t_P_ALL : idtype_t = 0 ; pub const idtype_t_P_PID : idtype_t = 1 ; pub const idtype_t_P_PGID : idtype_t = 2 ; pub type idtype_t = u32 ; pub type _Float32 = f32 ; pub type _Float64 = f64 ; pub type _Float32x = f64 ; pub type _Float64x = f64 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct div_t { pub quot : libc :: c_int , pub rem : libc :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ldiv_t { pub quot : libc :: c_long , pub rem : libc :: c_long , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct lldiv_t { pub quot : libc :: c_longlong , pub rem : libc :: c_longlong , } extern "C" { pub fn __ctype_get_mb_cur_max ( ) -> usize ; } extern "C" { pub fn atof ( __nptr : * const libc :: c_char ) -> f64 ; } extern "C" { pub fn atoi ( __nptr : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn atol ( __nptr : * const libc :: c_char ) -> libc :: c_long ; } extern "C" { pub fn atoll ( __nptr : * const libc :: c_char ) -> libc :: c_longlong ; } extern "C" { pub fn strtod ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char ) -> f64 ; } extern "C" { pub fn strtof ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char ) -> f32 ; } extern "C" { pub fn strtold ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char ) -> f64 ; } extern "C" { pub fn strtol ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_long ; } extern "C" { pub fn strtoul ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_ulong ; } extern "C" { pub fn strtoq ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_longlong ; } extern "C" { pub fn strtouq ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_ulonglong ; } extern "C" { pub fn strtoll ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_longlong ; } extern "C" { pub fn strtoull ( __nptr : * const libc :: c_char , __endptr : * mut * mut libc :: c_char , __base : libc :: c_int ) -> libc :: c_ulonglong ; } extern "C" { pub fn l64a ( __n : libc :: c_long ) -> * mut libc :: c_char ; } extern "C" { pub fn a64l ( __s : * const libc :: c_char ) -> libc :: c_long ; } pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type clockid_t = __clockid_t ; pub type time_t = __time_t ; pub type timer_t = __timer_t ; pub type ulong = libc :: c_ulong ; pub type ushort = libc :: c_ushort ; pub type uint = libc :: c_uint ; pub type u_int8_t = libc :: c_uchar ; pub type u_int16_t = libc :: c_ushort ; pub type u_int32_t = libc :: c_uint ; pub type u_int64_t = libc :: c_ulong ; pub type register_t = libc :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ libc :: c_ulong ; 16usize ] , } pub type sigset_t = __sigset_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = libc :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask ; 16usize ] , } pub type fd_mask = __fd_mask ; extern "C" { pub fn select ( __nfds : libc :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval ) -> libc :: c_int ; } extern "C" { pub fn pselect ( __nfds : libc :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t ) -> libc :: c_int ; } extern "C" { pub fn gnu_dev_major ( __dev : __dev_t ) -> libc :: c_uint ; } extern "C" { pub fn gnu_dev_minor ( __dev : __dev_t ) -> libc :: c_uint ; } extern "C" { pub fn gnu_dev_makedev ( __major : libc :: c_uint , __minor : libc :: c_uint ) -> __dev_t ; } pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_rwlock_arch_t { pub __readers : libc :: c_uint , pub __writers : libc :: c_uint , pub __wrphase_futex : libc :: c_uint , pub __writers_futex : libc :: c_uint , pub __pad3 : libc :: c_uint , pub __pad4 : libc :: c_uint , pub __cur_writer : libc :: c_int , pub __shared : libc :: c_int , pub __rwelision : libc :: c_schar , pub __pad1 : [ libc :: c_uchar ; 7usize ] , pub __pad2 : libc :: c_ulong , pub __flags : libc :: c_uint , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } impl Default for __pthread_internal_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_mutex_s { pub __lock : libc :: c_int , pub __count : libc :: c_uint , pub __owner : libc :: c_int , pub __nusers : libc :: c_uint , pub __kind : libc :: c_int , pub __spins : libc :: c_short , pub __elision : libc :: c_short , pub __list : __pthread_list_t , } impl Default for __pthread_mutex_s { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __pthread_cond_s { pub __bindgen_anon_1 : __pthread_cond_s__bindgen_ty_1 , pub __bindgen_anon_2 : __pthread_cond_s__bindgen_ty_2 , pub __g_refs : [ libc :: c_uint ; 2usize ] , pub __g_size : [ libc :: c_uint ; 2usize ] , pub __g1_orig_size : libc :: c_uint , pub __wrefs : libc :: c_uint , pub __g_signals : [ libc :: c_uint ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_1 { pub __wseq : libc :: c_ulonglong , pub __wseq32 : __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 { pub __low : libc :: c_uint , pub __high : libc :: c_uint , } impl Default for __pthread_cond_s__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_2 { pub __g1_start : libc :: c_ulonglong , pub __g1_start32 : __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 { pub __low : libc :: c_uint , pub __high : libc :: c_uint , } impl Default for __pthread_cond_s__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for __pthread_cond_s { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_t = libc :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ libc :: c_char ; 4usize ] , pub __align : libc :: c_int , _bindgen_union_align : u32 , } impl Default for pthread_mutexattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ libc :: c_char ; 4usize ] , pub __align : libc :: c_int , _bindgen_union_align : u32 , } impl Default for pthread_condattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_key_t = libc :: c_uint ; pub type pthread_once_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ libc :: c_char ; 56usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } impl Default for pthread_attr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [ libc :: c_char ; 40usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } impl Default for pthread_mutex_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [ libc :: c_char ; 48usize ] , pub __align : libc :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } impl Default for pthread_cond_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : __pthread_rwlock_arch_t , pub __size : [ libc :: c_char ; 56usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } impl Default for pthread_rwlock_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ libc :: c_char ; 8usize ] , pub __align : libc :: c_long , _bindgen_union_align : u64 , } impl Default for pthread_rwlockattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_spinlock_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ libc :: c_char ; 32usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } impl Default for pthread_barrier_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ libc :: c_char ; 4usize ] , pub __align : libc :: c_int , _bindgen_union_align : u32 , } impl Default for pthread_barrierattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn random ( ) -> libc :: c_long ; } extern "C" { pub fn srandom ( __seed : libc :: c_uint ) ; } extern "C" { pub fn initstate ( __seed : libc :: c_uint , __statebuf : * mut libc :: c_char , __statelen : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn setstate ( __statebuf : * mut libc :: c_char ) -> * mut libc :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : libc :: c_int , pub rand_deg : libc :: c_int , pub rand_sep : libc :: c_int , pub end_ptr : * mut i32 , } impl Default for random_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn random_r ( __buf : * mut random_data , __result : * mut i32 ) -> libc :: c_int ; } extern "C" { pub fn srandom_r ( __seed : libc :: c_uint , __buf : * mut random_data ) -> libc :: c_int ; } extern "C" { pub fn initstate_r ( __seed : libc :: c_uint , __statebuf : * mut libc :: c_char , __statelen : usize , __buf : * mut random_data ) -> libc :: c_int ; } extern "C" { pub fn setstate_r ( __statebuf : * mut libc :: c_char , __buf : * mut random_data ) -> libc :: c_int ; } extern "C" { pub fn rand ( ) -> libc :: c_int ; } extern "C" { pub fn srand ( __seed : libc :: c_uint ) ; } extern "C" { pub fn rand_r ( __seed : * mut libc :: c_uint ) -> libc :: c_int ; } extern "C" { pub fn drand48 ( ) -> f64 ; } extern "C" { pub fn erand48 ( __xsubi : * mut libc :: c_ushort ) -> f64 ; } extern "C" { pub fn lrand48 ( ) -> libc :: c_long ; } extern "C" { pub fn nrand48 ( __xsubi : * mut libc :: c_ushort ) -> libc :: c_long ; } extern "C" { pub fn mrand48 ( ) -> libc :: c_long ; } extern "C" { pub fn jrand48 ( __xsubi : * mut libc :: c_ushort ) -> libc :: c_long ; } extern "C" { pub fn srand48 ( __seedval : libc :: c_long ) ; } extern "C" { pub fn seed48 ( __seed16v : * mut libc :: c_ushort ) -> * mut libc :: c_ushort ; } extern "C" { pub fn lcong48 ( __param : * mut libc :: c_ushort ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct drand48_data { pub __x : [ libc :: c_ushort ; 3usize ] , pub __old_x : [ libc :: c_ushort ; 3usize ] , pub __c : libc :: c_ushort , pub __init : libc :: c_ushort , pub __a : libc :: c_ulonglong , } extern "C" { pub fn drand48_r ( __buffer : * mut drand48_data , __result : * mut f64 ) -> libc :: c_int ; } extern "C" { pub fn erand48_r ( __xsubi : * mut libc :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64 ) -> libc :: c_int ; } extern "C" { pub fn lrand48_r ( __buffer : * mut drand48_data , __result : * mut libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn nrand48_r ( __xsubi : * mut libc :: c_ushort , __buffer : * mut drand48_data , __result : * mut libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn mrand48_r ( __buffer : * mut drand48_data , __result : * mut libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn jrand48_r ( __xsubi : * mut libc :: c_ushort , __buffer : * mut drand48_data , __result : * mut libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn srand48_r ( __seedval : libc :: c_long , __buffer : * mut drand48_data ) -> libc :: c_int ; } extern "C" { pub fn seed48_r ( __seed16v : * mut libc :: c_ushort , __buffer : * mut drand48_data ) -> libc :: c_int ; } extern "C" { pub fn lcong48_r ( __param : * mut libc :: c_ushort , __buffer : * mut drand48_data ) -> libc :: c_int ; } extern "C" { pub fn malloc ( __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn calloc ( __nmemb : usize , __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn realloc ( __ptr : * mut libc :: c_void , __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn free ( __ptr : * mut libc :: c_void ) ; } extern "C" { pub fn alloca ( __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn valloc ( __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn posix_memalign ( __memptr : * mut * mut libc :: c_void , __alignment : usize , __size : usize ) -> libc :: c_int ; } extern "C" { pub fn aligned_alloc ( __alignment : usize , __size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn abort ( ) ; } extern "C" { pub fn atexit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> libc :: c_int ; } extern "C" { pub fn at_quick_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> libc :: c_int ; } extern "C" { pub fn on_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( __status : libc :: c_int , __arg : * mut libc :: c_void ) > , __arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn exit ( __status : libc :: c_int ) ; } extern "C" { pub fn quick_exit ( __status : libc :: c_int ) ; } extern "C" { pub fn _Exit ( __status : libc :: c_int ) ; } extern "C" { pub fn getenv ( __name : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn putenv ( __string : * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn setenv ( __name : * const libc :: c_char , __value : * const libc :: c_char , __replace : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn unsetenv ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn clearenv ( ) -> libc :: c_int ; } extern "C" { pub fn mktemp ( __template : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn mkstemp ( __template : * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn mkstemps ( __template : * mut libc :: c_char , __suffixlen : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn mkdtemp ( __template : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn system ( __command : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn realpath ( __name : * const libc :: c_char , __resolved : * mut libc :: c_char ) -> * mut libc :: c_char ; } pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const libc :: c_void , arg2 : * const libc :: c_void ) -> libc :: c_int > ; extern "C" { pub fn bsearch ( __key : * const libc :: c_void , __base : * const libc :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) -> * mut libc :: c_void ; } extern "C" { pub fn qsort ( __base : * mut libc :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) ; } extern "C" { pub fn abs ( __x : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn labs ( __x : libc :: c_long ) -> libc :: c_long ; } extern "C" { pub fn llabs ( __x : libc :: c_longlong ) -> libc :: c_longlong ; } extern "C" { pub fn div ( __numer : libc :: c_int , __denom : libc :: c_int ) -> div_t ; } extern "C" { pub fn ldiv ( __numer : libc :: c_long , __denom : libc :: c_long ) -> ldiv_t ; } extern "C" { pub fn lldiv ( __numer : libc :: c_longlong , __denom : libc :: c_longlong ) -> lldiv_t ; } extern "C" { pub fn ecvt ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn fcvt ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn gcvt ( __value : f64 , __ndigit : libc :: c_int , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn qecvt ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn qfcvt ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn qgcvt ( __value : f64 , __ndigit : libc :: c_int , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn ecvt_r ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn fcvt_r ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn qecvt_r ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn qfcvt_r ( __value : f64 , __ndigit : libc :: c_int , __decpt : * mut libc :: c_int , __sign : * mut libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn mblen ( __s : * const libc :: c_char , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn mbtowc ( __pwc : * mut wchar_t , __s : * const libc :: c_char , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn wctomb ( __s : * mut libc :: c_char , __wchar : wchar_t ) -> libc :: c_int ; } extern "C" { pub fn mbstowcs ( __pwcs : * mut wchar_t , __s : * const libc :: c_char , __n : usize ) -> usize ; } extern "C" { pub fn wcstombs ( __s : * mut libc :: c_char , __pwcs : * const wchar_t , __n : usize ) -> usize ; } extern "C" { pub fn rpmatch ( __response : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getsubopt ( __optionp : * mut * mut libc :: c_char , __tokens : * const * mut libc :: c_char , __valuep : * mut * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getloadavg ( __loadavg : * mut f64 , __nelem : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn memcpy ( __dest : * mut libc :: c_void , __src : * const libc :: c_void , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn memmove ( __dest : * mut libc :: c_void , __src : * const libc :: c_void , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn memccpy ( __dest : * mut libc :: c_void , __src : * const libc :: c_void , __c : libc :: c_int , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn memset ( __s : * mut libc :: c_void , __c : libc :: c_int , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn memcmp ( __s1 : * const libc :: c_void , __s2 : * const libc :: c_void , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn memchr ( __s : * const libc :: c_void , __c : libc :: c_int , __n : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn strcpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strncpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn strcat ( __dest : * mut libc :: c_char , __src : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strncat ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn strcmp ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn strncmp ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn strcoll ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn strxfrm ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> libc :: c_ulong ; } extern "C" { pub fn strcoll_l ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __l : locale_t ) -> libc :: c_int ; } extern "C" { pub fn strxfrm_l ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize , __l : locale_t ) -> usize ; } extern "C" { pub fn strdup ( __s : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strndup ( __string : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn strchr ( __s : * const libc :: c_char , __c : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn strrchr ( __s : * const libc :: c_char , __c : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn strcspn ( __s : * const libc :: c_char , __reject : * const libc :: c_char ) -> libc :: c_ulong ; } extern "C" { pub fn strspn ( __s : * const libc :: c_char , __accept : * const libc :: c_char ) -> libc :: c_ulong ; } extern "C" { pub fn strpbrk ( __s : * const libc :: c_char , __accept : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strstr ( __haystack : * const libc :: c_char , __needle : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strtok ( __s : * mut libc :: c_char , __delim : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn __strtok_r ( __s : * mut libc :: c_char , __delim : * const libc :: c_char , __save_ptr : * mut * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strtok_r ( __s : * mut libc :: c_char , __delim : * const libc :: c_char , __save_ptr : * mut * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strlen ( __s : * const libc :: c_char ) -> libc :: c_ulong ; } extern "C" { pub fn strnlen ( __string : * const libc :: c_char , __maxlen : usize ) -> usize ; } extern "C" { pub fn strerror ( __errnum : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn strerror_r ( __errnum : libc :: c_int , __buf : * mut libc :: c_char , __buflen : usize ) -> libc :: c_int ; } extern "C" { pub fn strerror_l ( __errnum : libc :: c_int , __l : locale_t ) -> * mut libc :: c_char ; } extern "C" { pub fn bcmp ( __s1 : * const libc :: c_void , __s2 : * const libc :: c_void , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn bcopy ( __src : * const libc :: c_void , __dest : * mut libc :: c_void , __n : usize ) ; } extern "C" { pub fn bzero ( __s : * mut libc :: c_void , __n : usize ) ; } extern "C" { pub fn index ( __s : * const libc :: c_char , __c : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn rindex ( __s : * const libc :: c_char , __c : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn ffs ( __i : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ffsl ( __l : libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn ffsll ( __ll : libc :: c_longlong ) -> libc :: c_int ; } extern "C" { pub fn strcasecmp ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn strncasecmp ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __n : usize ) -> libc :: c_int ; } extern "C" { pub fn strcasecmp_l ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __loc : locale_t ) -> libc :: c_int ; } extern "C" { pub fn strncasecmp_l ( __s1 : * const libc :: c_char , __s2 : * const libc :: c_char , __n : usize , __loc : locale_t ) -> libc :: c_int ; } extern "C" { pub fn explicit_bzero ( __s : * mut libc :: c_void , __n : usize ) ; } extern "C" { pub fn strsep ( __stringp : * mut * mut libc :: c_char , __delim : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn strsignal ( __sig : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn __stpcpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn stpcpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn __stpncpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn stpncpy ( __dest : * mut libc :: c_char , __src : * const libc :: c_char , __n : usize ) -> * mut libc :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tm { pub tm_sec : libc :: c_int , pub tm_min : libc :: c_int , pub tm_hour : libc :: c_int , pub tm_mday : libc :: c_int , pub tm_mon : libc :: c_int , pub tm_year : libc :: c_int , pub tm_wday : libc :: c_int , pub tm_yday : libc :: c_int , pub tm_isdst : libc :: c_int , pub tm_gmtoff : libc :: c_long , pub tm_zone : * const libc :: c_char , } impl Default for tm { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct itimerspec { pub it_interval : timespec , pub it_value : timespec , } extern "C" { pub fn clock ( ) -> clock_t ; } extern "C" { pub fn time ( __timer : * mut time_t ) -> time_t ; } extern "C" { pub fn difftime ( __time1 : time_t , __time0 : time_t ) -> f64 ; } extern "C" { pub fn mktime ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn strftime ( __s : * mut libc :: c_char , __maxsize : usize , __format : * const libc :: c_char , __tp : * const tm ) -> usize ; } extern "C" { pub fn strftime_l ( __s : * mut libc :: c_char , __maxsize : usize , __format : * const libc :: c_char , __tp : * const tm , __loc : locale_t ) -> usize ; } extern "C" { pub fn gmtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { pub fn localtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { pub fn gmtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { pub fn localtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { pub fn asctime ( __tp : * const tm ) -> * mut libc :: c_char ; } extern "C" { pub fn ctime ( __timer : * const time_t ) -> * mut libc :: c_char ; } extern "C" { pub fn asctime_r ( __tp : * const tm , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn ctime_r ( __timer : * const time_t , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn tzset ( ) ; } extern "C" { pub fn stime ( __when : * const time_t ) -> libc :: c_int ; } extern "C" { pub fn timegm ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn timelocal ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn dysize ( __year : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn nanosleep ( __requested_time : * const timespec , __remaining : * mut timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_getres ( __clock_id : clockid_t , __res : * mut timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_gettime ( __clock_id : clockid_t , __tp : * mut timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_settime ( __clock_id : clockid_t , __tp : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_nanosleep ( __clock_id : clockid_t , __flags : libc :: c_int , __req : * const timespec , __rem : * mut timespec ) -> libc :: c_int ; } extern "C" { pub fn clock_getcpuclockid ( __pid : pid_t , __clock_id : * mut clockid_t ) -> libc :: c_int ; } extern "C" { pub fn timer_create ( __clock_id : clockid_t , __evp : * mut sigevent , __timerid : * mut timer_t ) -> libc :: c_int ; } extern "C" { pub fn timer_delete ( __timerid : timer_t ) -> libc :: c_int ; } extern "C" { pub fn timer_settime ( __timerid : timer_t , __flags : libc :: c_int , __value : * const itimerspec , __ovalue : * mut itimerspec ) -> libc :: c_int ; } extern "C" { pub fn timer_gettime ( __timerid : timer_t , __value : * mut itimerspec ) -> libc :: c_int ; } extern "C" { pub fn timer_getoverrun ( __timerid : timer_t ) -> libc :: c_int ; } extern "C" { pub fn timespec_get ( __ts : * mut timespec , __base : libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct iovec { pub iov_base : * mut libc :: c_void , pub iov_len : usize , } impl Default for iovec { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type socklen_t = __socklen_t ; pub const __socket_type_SOCK_STREAM : __socket_type = 1 ; pub const __socket_type_SOCK_DGRAM : __socket_type = 2 ; pub const __socket_type_SOCK_RAW : __socket_type = 3 ; pub const __socket_type_SOCK_RDM : __socket_type = 4 ; pub const __socket_type_SOCK_SEQPACKET : __socket_type = 5 ; pub const __socket_type_SOCK_DCCP : __socket_type = 6 ; pub const __socket_type_SOCK_PACKET : __socket_type = 10 ; pub const __socket_type_SOCK_CLOEXEC : __socket_type = 524288 ; pub const __socket_type_SOCK_NONBLOCK : __socket_type = 2048 ; pub type __socket_type = u32 ; pub type sa_family_t = libc :: c_ushort ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sockaddr { pub sa_family : sa_family_t , pub sa_data : [ libc :: c_char ; 14usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_storage { pub ss_family : sa_family_t , pub __ss_padding : [ libc :: c_char ; 118usize ] , pub __ss_align : libc :: c_ulong , } impl Default for sockaddr_storage { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const MSG_OOB : _bindgen_ty_2 = 1 ; pub const MSG_PEEK : _bindgen_ty_2 = 2 ; pub const MSG_DONTROUTE : _bindgen_ty_2 = 4 ; pub const MSG_CTRUNC : _bindgen_ty_2 = 8 ; pub const MSG_PROXY : _bindgen_ty_2 = 16 ; pub const MSG_TRUNC : _bindgen_ty_2 = 32 ; pub const MSG_DONTWAIT : _bindgen_ty_2 = 64 ; pub const MSG_EOR : _bindgen_ty_2 = 128 ; pub const MSG_WAITALL : _bindgen_ty_2 = 256 ; pub const MSG_FIN : _bindgen_ty_2 = 512 ; pub const MSG_SYN : _bindgen_ty_2 = 1024 ; pub const MSG_CONFIRM : _bindgen_ty_2 = 2048 ; pub const MSG_RST : _bindgen_ty_2 = 4096 ; pub const MSG_ERRQUEUE : _bindgen_ty_2 = 8192 ; pub const MSG_NOSIGNAL : _bindgen_ty_2 = 16384 ; pub const MSG_MORE : _bindgen_ty_2 = 32768 ; pub const MSG_WAITFORONE : _bindgen_ty_2 = 65536 ; pub const MSG_BATCH : _bindgen_ty_2 = 262144 ; pub const MSG_ZEROCOPY : _bindgen_ty_2 = 67108864 ; pub const MSG_FASTOPEN : _bindgen_ty_2 = 536870912 ; pub const MSG_CMSG_CLOEXEC : _bindgen_ty_2 = 1073741824 ; pub type _bindgen_ty_2 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct msghdr { pub msg_name : * mut libc :: c_void , pub msg_namelen : socklen_t , pub msg_iov : * mut iovec , pub msg_iovlen : usize , pub msg_control : * mut libc :: c_void , pub msg_controllen : usize , pub msg_flags : libc :: c_int , } impl Default for msghdr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct cmsghdr { pub cmsg_len : usize , pub cmsg_level : libc :: c_int , pub cmsg_type : libc :: c_int , pub __cmsg_data : __IncompleteArrayField < libc :: c_uchar > , } extern "C" { pub fn __cmsg_nxthdr ( __mhdr : * mut msghdr , __cmsg : * mut cmsghdr ) -> * mut cmsghdr ; } pub const SCM_RIGHTS : _bindgen_ty_3 = 1 ; pub type _bindgen_ty_3 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct linger { pub l_onoff : libc :: c_int , pub l_linger : libc :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct osockaddr { pub sa_family : libc :: c_ushort , pub sa_data : [ libc :: c_uchar ; 14usize ] , } pub const SHUT_RD : _bindgen_ty_4 = 0 ; pub const SHUT_WR : _bindgen_ty_4 = 1 ; pub const SHUT_RDWR : _bindgen_ty_4 = 2 ; pub type _bindgen_ty_4 = u32 ; extern "C" { pub fn socket ( __domain : libc :: c_int , __type : libc :: c_int , __protocol : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn socketpair ( __domain : libc :: c_int , __type : libc :: c_int , __protocol : libc :: c_int , __fds : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn bind ( __fd : libc :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> libc :: c_int ; } extern "C" { pub fn getsockname ( __fd : libc :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> libc :: c_int ; } extern "C" { pub fn connect ( __fd : libc :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> libc :: c_int ; } extern "C" { pub fn getpeername ( __fd : libc :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> libc :: c_int ; } extern "C" { pub fn send ( __fd : libc :: c_int , __buf : * const libc :: c_void , __n : usize , __flags : libc :: c_int ) -> isize ; } extern "C" { pub fn recv ( __fd : libc :: c_int , __buf : * mut libc :: c_void , __n : usize , __flags : libc :: c_int ) -> isize ; } extern "C" { pub fn sendto ( __fd : libc :: c_int , __buf : * const libc :: c_void , __n : usize , __flags : libc :: c_int , __addr : * const sockaddr , __addr_len : socklen_t ) -> isize ; } extern "C" { pub fn recvfrom ( __fd : libc :: c_int , __buf : * mut libc :: c_void , __n : usize , __flags : libc :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> isize ; } extern "C" { pub fn sendmsg ( __fd : libc :: c_int , __message : * const msghdr , __flags : libc :: c_int ) -> isize ; } extern "C" { pub fn recvmsg ( __fd : libc :: c_int , __message : * mut msghdr , __flags : libc :: c_int ) -> isize ; } extern "C" { pub fn getsockopt ( __fd : libc :: c_int , __level : libc :: c_int , __optname : libc :: c_int , __optval : * mut libc :: c_void , __optlen : * mut socklen_t ) -> libc :: c_int ; } extern "C" { pub fn setsockopt ( __fd : libc :: c_int , __level : libc :: c_int , __optname : libc :: c_int , __optval : * const libc :: c_void , __optlen : socklen_t ) -> libc :: c_int ; } extern "C" { pub fn listen ( __fd : libc :: c_int , __n : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn accept ( __fd : libc :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> libc :: c_int ; } extern "C" { pub fn shutdown ( __fd : libc :: c_int , __how : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sockatmark ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn isfdtype ( __fd : libc :: c_int , __fdtype : libc :: c_int ) -> libc :: c_int ; } pub type in_addr_t = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct in_addr { pub s_addr : in_addr_t , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ip_opts { pub ip_dst : in_addr , pub ip_opts : [ libc :: c_char ; 40usize ] , } impl Default for ip_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreqn { pub imr_multiaddr : in_addr , pub imr_address : in_addr , pub imr_ifindex : libc :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct in_pktinfo { pub ipi_ifindex : libc :: c_int , pub ipi_spec_dst : in_addr , pub ipi_addr : in_addr , } pub const IPPROTO_IP : _bindgen_ty_5 = 0 ; pub const IPPROTO_ICMP : _bindgen_ty_5 = 1 ; pub const IPPROTO_IGMP : _bindgen_ty_5 = 2 ; pub const IPPROTO_IPIP : _bindgen_ty_5 = 4 ; pub const IPPROTO_TCP : _bindgen_ty_5 = 6 ; pub const IPPROTO_EGP : _bindgen_ty_5 = 8 ; pub const IPPROTO_PUP : _bindgen_ty_5 = 12 ; pub const IPPROTO_UDP : _bindgen_ty_5 = 17 ; pub const IPPROTO_IDP : _bindgen_ty_5 = 22 ; pub const IPPROTO_TP : _bindgen_ty_5 = 29 ; pub const IPPROTO_DCCP : _bindgen_ty_5 = 33 ; pub const IPPROTO_IPV6 : _bindgen_ty_5 = 41 ; pub const IPPROTO_RSVP : _bindgen_ty_5 = 46 ; pub const IPPROTO_GRE : _bindgen_ty_5 = 47 ; pub const IPPROTO_ESP : _bindgen_ty_5 = 50 ; pub const IPPROTO_AH : _bindgen_ty_5 = 51 ; pub const IPPROTO_MTP : _bindgen_ty_5 = 92 ; pub const IPPROTO_BEETPH : _bindgen_ty_5 = 94 ; pub const IPPROTO_ENCAP : _bindgen_ty_5 = 98 ; pub const IPPROTO_PIM : _bindgen_ty_5 = 103 ; pub const IPPROTO_COMP : _bindgen_ty_5 = 108 ; pub const IPPROTO_SCTP : _bindgen_ty_5 = 132 ; pub const IPPROTO_UDPLITE : _bindgen_ty_5 = 136 ; pub const IPPROTO_MPLS : _bindgen_ty_5 = 137 ; pub const IPPROTO_RAW : _bindgen_ty_5 = 255 ; pub const IPPROTO_MAX : _bindgen_ty_5 = 256 ; pub type _bindgen_ty_5 = u32 ; pub const IPPROTO_HOPOPTS : _bindgen_ty_6 = 0 ; pub const IPPROTO_ROUTING : _bindgen_ty_6 = 43 ; pub const IPPROTO_FRAGMENT : _bindgen_ty_6 = 44 ; pub const IPPROTO_ICMPV6 : _bindgen_ty_6 = 58 ; pub const IPPROTO_NONE : _bindgen_ty_6 = 59 ; pub const IPPROTO_DSTOPTS : _bindgen_ty_6 = 60 ; pub const IPPROTO_MH : _bindgen_ty_6 = 135 ; pub type _bindgen_ty_6 = u32 ; pub type in_port_t = u16 ; pub const IPPORT_ECHO : _bindgen_ty_7 = 7 ; pub const IPPORT_DISCARD : _bindgen_ty_7 = 9 ; pub const IPPORT_SYSTAT : _bindgen_ty_7 = 11 ; pub const IPPORT_DAYTIME : _bindgen_ty_7 = 13 ; pub const IPPORT_NETSTAT : _bindgen_ty_7 = 15 ; pub const IPPORT_FTP : _bindgen_ty_7 = 21 ; pub const IPPORT_TELNET : _bindgen_ty_7 = 23 ; pub const IPPORT_SMTP : _bindgen_ty_7 = 25 ; pub const IPPORT_TIMESERVER : _bindgen_ty_7 = 37 ; pub const IPPORT_NAMESERVER : _bindgen_ty_7 = 42 ; pub const IPPORT_WHOIS : _bindgen_ty_7 = 43 ; pub const IPPORT_MTP : _bindgen_ty_7 = 57 ; pub const IPPORT_TFTP : _bindgen_ty_7 = 69 ; pub const IPPORT_RJE : _bindgen_ty_7 = 77 ; pub const IPPORT_FINGER : _bindgen_ty_7 = 79 ; pub const IPPORT_TTYLINK : _bindgen_ty_7 = 87 ; pub const IPPORT_SUPDUP : _bindgen_ty_7 = 95 ; pub const IPPORT_EXECSERVER : _bindgen_ty_7 = 512 ; pub const IPPORT_LOGINSERVER : _bindgen_ty_7 = 513 ; pub const IPPORT_CMDSERVER : _bindgen_ty_7 = 514 ; pub const IPPORT_EFSSERVER : _bindgen_ty_7 = 520 ; pub const IPPORT_BIFFUDP : _bindgen_ty_7 = 512 ; pub const IPPORT_WHOSERVER : _bindgen_ty_7 = 513 ; pub const IPPORT_ROUTESERVER : _bindgen_ty_7 = 520 ; pub const IPPORT_RESERVED : _bindgen_ty_7 = 1024 ; pub const IPPORT_USERRESERVED : _bindgen_ty_7 = 5000 ; pub type _bindgen_ty_7 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct in6_addr { pub __in6_u : in6_addr__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union in6_addr__bindgen_ty_1 { pub __u6_addr8 : [ u8 ; 16usize ] , pub __u6_addr16 : [ u16 ; 8usize ] , pub __u6_addr32 : [ u32 ; 4usize ] , _bindgen_union_align : [ u32 ; 4usize ] , } impl Default for in6_addr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for in6_addr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sockaddr_in { pub sin_family : sa_family_t , pub sin_port : in_port_t , pub sin_addr : in_addr , pub sin_zero : [ libc :: c_uchar ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_in6 { pub sin6_family : sa_family_t , pub sin6_port : in_port_t , pub sin6_flowinfo : u32 , pub sin6_addr : in6_addr , pub sin6_scope_id : u32 , } impl Default for sockaddr_in6 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreq { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreq_source { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , pub imr_sourceaddr : in_addr , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ipv6_mreq { pub ipv6mr_multiaddr : in6_addr , pub ipv6mr_interface : libc :: c_uint , } impl Default for ipv6_mreq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_req { pub gr_interface : u32 , pub gr_group : sockaddr_storage , } impl Default for group_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_source_req { pub gsr_interface : u32 , pub gsr_group : sockaddr_storage , pub gsr_source : sockaddr_storage , } impl Default for group_source_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_msfilter { pub imsf_multiaddr : in_addr , pub imsf_interface : in_addr , pub imsf_fmode : u32 , pub imsf_numsrc : u32 , pub imsf_slist : [ in_addr ; 1usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_filter { pub gf_interface : u32 , pub gf_group : sockaddr_storage , pub gf_fmode : u32 , pub gf_numsrc : u32 , pub gf_slist : [ sockaddr_storage ; 1usize ] , } impl Default for group_filter { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn ntohl ( __netlong : u32 ) -> u32 ; } extern "C" { pub fn ntohs ( __netshort : u16 ) -> u16 ; } extern "C" { pub fn htonl ( __hostlong : u32 ) -> u32 ; } extern "C" { pub fn htons ( __hostshort : u16 ) -> u16 ; } extern "C" { pub fn bindresvport ( __sockfd : libc :: c_int , __sock_in : * mut sockaddr_in ) -> libc :: c_int ; } extern "C" { pub fn bindresvport6 ( __sockfd : libc :: c_int , __sock_in : * mut sockaddr_in6 ) -> libc :: c_int ; } extern "C" { pub fn inet_addr ( __cp : * const libc :: c_char ) -> in_addr_t ; } extern "C" { pub fn inet_lnaof ( __in : in_addr ) -> in_addr_t ; } extern "C" { pub fn inet_makeaddr ( __net : in_addr_t , __host : in_addr_t ) -> in_addr ; } extern "C" { pub fn inet_netof ( __in : in_addr ) -> in_addr_t ; } extern "C" { pub fn inet_network ( __cp : * const libc :: c_char ) -> in_addr_t ; } extern "C" { pub fn inet_ntoa ( __in : in_addr ) -> * mut libc :: c_char ; } extern "C" { pub fn inet_pton ( __af : libc :: c_int , __cp : * const libc :: c_char , __buf : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn inet_ntop ( __af : libc :: c_int , __cp : * const libc :: c_void , __buf : * mut libc :: c_char , __len : socklen_t ) -> * const libc :: c_char ; } extern "C" { pub fn inet_aton ( __cp : * const libc :: c_char , __inp : * mut in_addr ) -> libc :: c_int ; } extern "C" { pub fn inet_neta ( __net : in_addr_t , __buf : * mut libc :: c_char , __len : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn inet_net_ntop ( __af : libc :: c_int , __cp : * const libc :: c_void , __bits : libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn inet_net_pton ( __af : libc :: c_int , __cp : * const libc :: c_char , __buf : * mut libc :: c_void , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn inet_nsap_addr ( __cp : * const libc :: c_char , __buf : * mut libc :: c_uchar , __len : libc :: c_int ) -> libc :: c_uint ; } extern "C" { pub fn inet_nsap_ntoa ( __len : libc :: c_int , __cp : * const libc :: c_uchar , __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct dirent { pub d_ino : __ino_t , pub d_off : __off_t , pub d_reclen : libc :: c_ushort , pub d_type : libc :: c_uchar , pub d_name : [ libc :: c_char ; 256usize ] , } impl Default for dirent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const DT_UNKNOWN : _bindgen_ty_8 = 0 ; pub const DT_FIFO : _bindgen_ty_8 = 1 ; pub const DT_CHR : _bindgen_ty_8 = 2 ; pub const DT_DIR : _bindgen_ty_8 = 4 ; pub const DT_BLK : _bindgen_ty_8 = 6 ; pub const DT_REG : _bindgen_ty_8 = 8 ; pub const DT_LNK : _bindgen_ty_8 = 10 ; pub const DT_SOCK : _bindgen_ty_8 = 12 ; pub const DT_WHT : _bindgen_ty_8 = 14 ; pub type _bindgen_ty_8 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __dirstream { _unused : [ u8 ; 0 ] , } pub type DIR = __dirstream ; extern "C" { pub fn opendir ( __name : * const libc :: c_char ) -> * mut DIR ; } extern "C" { pub fn fdopendir ( __fd : libc :: c_int ) -> * mut DIR ; } extern "C" { pub fn closedir ( __dirp : * mut DIR ) -> libc :: c_int ; } extern "C" { pub fn readdir ( __dirp : * mut DIR ) -> * mut dirent ; } extern "C" { pub fn readdir_r ( __dirp : * mut DIR , __entry : * mut dirent , __result : * mut * mut dirent ) -> libc :: c_int ; } extern "C" { pub fn rewinddir ( __dirp : * mut DIR ) ; } extern "C" { pub fn seekdir ( __dirp : * mut DIR , __pos : libc :: c_long ) ; } extern "C" { pub fn telldir ( __dirp : * mut DIR ) -> libc :: c_long ; } extern "C" { pub fn dirfd ( __dirp : * mut DIR ) -> libc :: c_int ; } extern "C" { pub fn scandir ( __dir : * const libc :: c_char , __namelist : * mut * mut * mut dirent , __selector : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const dirent ) -> libc :: c_int > , __cmp : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut * const dirent , arg2 : * mut * const dirent ) -> libc :: c_int > ) -> libc :: c_int ; } extern "C" { pub fn alphasort ( __e1 : * mut * const dirent , __e2 : * mut * const dirent ) -> libc :: c_int ; } extern "C" { pub fn getdirentries ( __fd : libc :: c_int , __buf : * mut libc :: c_char , __nbytes : usize , __basep : * mut __off_t ) -> __ssize_t ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct flock { pub l_type : libc :: c_short , pub l_whence : libc :: c_short , pub l_start : __off_t , pub l_len : __off_t , pub l_pid : __pid_t , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct stat { pub st_dev : __dev_t , pub st_ino : __ino_t , pub st_nlink : __nlink_t , pub st_mode : __mode_t , pub st_uid : __uid_t , pub st_gid : __gid_t , pub __pad0 : libc :: c_int , pub st_rdev : __dev_t , pub st_size : __off_t , pub st_blksize : __blksize_t , pub st_blocks : __blkcnt_t , pub st_atim : timespec , pub st_mtim : timespec , pub st_ctim : timespec , pub __glibc_reserved : [ __syscall_slong_t ; 3usize ] , } extern "C" { pub fn fcntl ( __fd : libc :: c_int , __cmd : libc :: c_int , ... ) -> libc :: c_int ; } extern "C" { pub fn open ( __file : * const libc :: c_char , __oflag : libc :: c_int , ... ) -> libc :: c_int ; } extern "C" { pub fn openat ( __fd : libc :: c_int , __file : * const libc :: c_char , __oflag : libc :: c_int , ... ) -> libc :: c_int ; } extern "C" { pub fn creat ( __file : * const libc :: c_char , __mode : mode_t ) -> libc :: c_int ; } extern "C" { pub fn lockf ( __fd : libc :: c_int , __cmd : libc :: c_int , __len : off_t ) -> libc :: c_int ; } extern "C" { pub fn posix_fadvise ( __fd : libc :: c_int , __offset : off_t , __len : off_t , __advise : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn posix_fallocate ( __fd : libc :: c_int , __offset : off_t , __len : off_t ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifaddrs { pub ifa_next : * mut ifaddrs , pub ifa_name : * mut libc :: c_char , pub ifa_flags : libc :: c_uint , pub ifa_addr : * mut sockaddr , pub ifa_netmask : * mut sockaddr , pub ifa_ifu : ifaddrs__bindgen_ty_1 , pub ifa_data : * mut libc :: c_void , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifaddrs__bindgen_ty_1 { pub ifu_broadaddr : * mut sockaddr , pub ifu_dstaddr : * mut sockaddr , _bindgen_union_align : u64 , } impl Default for ifaddrs__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for ifaddrs { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn getifaddrs ( __ifap : * mut * mut ifaddrs ) -> libc :: c_int ; } extern "C" { pub fn freeifaddrs ( __ifa : * mut ifaddrs ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rpcent { pub r_name : * mut libc :: c_char , pub r_aliases : * mut * mut libc :: c_char , pub r_number : libc :: c_int , } impl Default for rpcent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn setrpcent ( __stayopen : libc :: c_int ) ; } extern "C" { pub fn endrpcent ( ) ; } extern "C" { pub fn getrpcbyname ( __name : * const libc :: c_char ) -> * mut rpcent ; } extern "C" { pub fn getrpcbynumber ( __number : libc :: c_int ) -> * mut rpcent ; } extern "C" { pub fn getrpcent ( ) -> * mut rpcent ; } extern "C" { pub fn getrpcbyname_r ( __name : * const libc :: c_char , __result_buf : * mut rpcent , __buffer : * mut libc :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> libc :: c_int ; } extern "C" { pub fn getrpcbynumber_r ( __number : libc :: c_int , __result_buf : * mut rpcent , __buffer : * mut libc :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> libc :: c_int ; } extern "C" { pub fn getrpcent_r ( __result_buf : * mut rpcent , __buffer : * mut libc :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct netent { pub n_name : * mut libc :: c_char , pub n_aliases : * mut * mut libc :: c_char , pub n_addrtype : libc :: c_int , pub n_net : u32 , } impl Default for netent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn __h_errno_location ( ) -> * mut libc :: c_int ; } extern "C" { pub fn herror ( __str : * const libc :: c_char ) ; } extern "C" { pub fn hstrerror ( __err_num : libc :: c_int ) -> * const libc :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hostent { pub h_name : * mut libc :: c_char , pub h_aliases : * mut * mut libc :: c_char , pub h_addrtype : libc :: c_int , pub h_length : libc :: c_int , pub h_addr_list : * mut * mut libc :: c_char , } impl Default for hostent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sethostent ( __stay_open : libc :: c_int ) ; } extern "C" { pub fn endhostent ( ) ; } extern "C" { pub fn gethostent ( ) -> * mut hostent ; } extern "C" { pub fn gethostbyaddr ( __addr : * const libc :: c_void , __len : __socklen_t , __type : libc :: c_int ) -> * mut hostent ; } extern "C" { pub fn gethostbyname ( __name : * const libc :: c_char ) -> * mut hostent ; } extern "C" { pub fn gethostbyname2 ( __name : * const libc :: c_char , __af : libc :: c_int ) -> * mut hostent ; } extern "C" { pub fn gethostent_r ( __result_buf : * mut hostent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn gethostbyaddr_r ( __addr : * const libc :: c_void , __len : __socklen_t , __type : libc :: c_int , __result_buf : * mut hostent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn gethostbyname_r ( __name : * const libc :: c_char , __result_buf : * mut hostent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn gethostbyname2_r ( __name : * const libc :: c_char , __af : libc :: c_int , __result_buf : * mut hostent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn setnetent ( __stay_open : libc :: c_int ) ; } extern "C" { pub fn endnetent ( ) ; } extern "C" { pub fn getnetent ( ) -> * mut netent ; } extern "C" { pub fn getnetbyaddr ( __net : u32 , __type : libc :: c_int ) -> * mut netent ; } extern "C" { pub fn getnetbyname ( __name : * const libc :: c_char ) -> * mut netent ; } extern "C" { pub fn getnetent_r ( __result_buf : * mut netent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getnetbyaddr_r ( __net : u32 , __type : libc :: c_int , __result_buf : * mut netent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getnetbyname_r ( __name : * const libc :: c_char , __result_buf : * mut netent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct servent { pub s_name : * mut libc :: c_char , pub s_aliases : * mut * mut libc :: c_char , pub s_port : libc :: c_int , pub s_proto : * mut libc :: c_char , } impl Default for servent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn setservent ( __stay_open : libc :: c_int ) ; } extern "C" { pub fn endservent ( ) ; } extern "C" { pub fn getservent ( ) -> * mut servent ; } extern "C" { pub fn getservbyname ( __name : * const libc :: c_char , __proto : * const libc :: c_char ) -> * mut servent ; } extern "C" { pub fn getservbyport ( __port : libc :: c_int , __proto : * const libc :: c_char ) -> * mut servent ; } extern "C" { pub fn getservent_r ( __result_buf : * mut servent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut servent ) -> libc :: c_int ; } extern "C" { pub fn getservbyname_r ( __name : * const libc :: c_char , __proto : * const libc :: c_char , __result_buf : * mut servent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut servent ) -> libc :: c_int ; } extern "C" { pub fn getservbyport_r ( __port : libc :: c_int , __proto : * const libc :: c_char , __result_buf : * mut servent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut servent ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct protoent { pub p_name : * mut libc :: c_char , pub p_aliases : * mut * mut libc :: c_char , pub p_proto : libc :: c_int , } impl Default for protoent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn setprotoent ( __stay_open : libc :: c_int ) ; } extern "C" { pub fn endprotoent ( ) ; } extern "C" { pub fn getprotoent ( ) -> * mut protoent ; } extern "C" { pub fn getprotobyname ( __name : * const libc :: c_char ) -> * mut protoent ; } extern "C" { pub fn getprotobynumber ( __proto : libc :: c_int ) -> * mut protoent ; } extern "C" { pub fn getprotoent_r ( __result_buf : * mut protoent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> libc :: c_int ; } extern "C" { pub fn getprotobyname_r ( __name : * const libc :: c_char , __result_buf : * mut protoent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> libc :: c_int ; } extern "C" { pub fn getprotobynumber_r ( __proto : libc :: c_int , __result_buf : * mut protoent , __buf : * mut libc :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> libc :: c_int ; } extern "C" { pub fn setnetgrent ( __netgroup : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn endnetgrent ( ) ; } extern "C" { pub fn getnetgrent ( __hostp : * mut * mut libc :: c_char , __userp : * mut * mut libc :: c_char , __domainp : * mut * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn innetgr ( __netgroup : * const libc :: c_char , __host : * const libc :: c_char , __user : * const libc :: c_char , __domain : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getnetgrent_r ( __hostp : * mut * mut libc :: c_char , __userp : * mut * mut libc :: c_char , __domainp : * mut * mut libc :: c_char , __buffer : * mut libc :: c_char , __buflen : usize ) -> libc :: c_int ; } extern "C" { pub fn rcmd ( __ahost : * mut * mut libc :: c_char , __rport : libc :: c_ushort , __locuser : * const libc :: c_char , __remuser : * const libc :: c_char , __cmd : * const libc :: c_char , __fd2p : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn rcmd_af ( __ahost : * mut * mut libc :: c_char , __rport : libc :: c_ushort , __locuser : * const libc :: c_char , __remuser : * const libc :: c_char , __cmd : * const libc :: c_char , __fd2p : * mut libc :: c_int , __af : sa_family_t ) -> libc :: c_int ; } extern "C" { pub fn rexec ( __ahost : * mut * mut libc :: c_char , __rport : libc :: c_int , __name : * const libc :: c_char , __pass : * const libc :: c_char , __cmd : * const libc :: c_char , __fd2p : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn rexec_af ( __ahost : * mut * mut libc :: c_char , __rport : libc :: c_int , __name : * const libc :: c_char , __pass : * const libc :: c_char , __cmd : * const libc :: c_char , __fd2p : * mut libc :: c_int , __af : sa_family_t ) -> libc :: c_int ; } extern "C" { pub fn ruserok ( __rhost : * const libc :: c_char , __suser : libc :: c_int , __remuser : * const libc :: c_char , __locuser : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn ruserok_af ( __rhost : * const libc :: c_char , __suser : libc :: c_int , __remuser : * const libc :: c_char , __locuser : * const libc :: c_char , __af : sa_family_t ) -> libc :: c_int ; } extern "C" { pub fn iruserok ( __raddr : u32 , __suser : libc :: c_int , __remuser : * const libc :: c_char , __locuser : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn iruserok_af ( __raddr : * const libc :: c_void , __suser : libc :: c_int , __remuser : * const libc :: c_char , __locuser : * const libc :: c_char , __af : sa_family_t ) -> libc :: c_int ; } extern "C" { pub fn rresvport ( __alport : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn rresvport_af ( __alport : * mut libc :: c_int , __af : sa_family_t ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct addrinfo { pub ai_flags : libc :: c_int , pub ai_family : libc :: c_int , pub ai_socktype : libc :: c_int , pub ai_protocol : libc :: c_int , pub ai_addrlen : socklen_t , pub ai_addr : * mut sockaddr , pub ai_canonname : * mut libc :: c_char , pub ai_next : * mut addrinfo , } impl Default for addrinfo { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn getaddrinfo ( __name : * const libc :: c_char , __service : * const libc :: c_char , __req : * const addrinfo , __pai : * mut * mut addrinfo ) -> libc :: c_int ; } extern "C" { pub fn freeaddrinfo ( __ai : * mut addrinfo ) ; } extern "C" { pub fn gai_strerror ( __ecode : libc :: c_int ) -> * const libc :: c_char ; } extern "C" { pub fn getnameinfo ( __sa : * const sockaddr , __salen : socklen_t , __host : * mut libc :: c_char , __hostlen : socklen_t , __serv : * mut libc :: c_char , __servlen : socklen_t , __flags : libc :: c_int ) -> libc :: c_int ; } pub type nfds_t = libc :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct pollfd { pub fd : libc :: c_int , pub events : libc :: c_short , pub revents : libc :: c_short , } extern "C" { pub fn poll ( __fds : * mut pollfd , __nfds : nfds_t , __timeout : libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sched_param { pub sched_priority : libc :: c_int , } pub type __cpu_mask = libc :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct cpu_set_t { pub __bits : [ __cpu_mask ; 16usize ] , } extern "C" { pub fn __sched_cpucount ( __setsize : usize , __setp : * const cpu_set_t ) -> libc :: c_int ; } extern "C" { pub fn __sched_cpualloc ( __count : usize ) -> * mut cpu_set_t ; } extern "C" { pub fn __sched_cpufree ( __set : * mut cpu_set_t ) ; } extern "C" { pub fn sched_setparam ( __pid : __pid_t , __param : * const sched_param ) -> libc :: c_int ; } extern "C" { pub fn sched_getparam ( __pid : __pid_t , __param : * mut sched_param ) -> libc :: c_int ; } extern "C" { pub fn sched_setscheduler ( __pid : __pid_t , __policy : libc :: c_int , __param : * const sched_param ) -> libc :: c_int ; } extern "C" { pub fn sched_getscheduler ( __pid : __pid_t ) -> libc :: c_int ; } extern "C" { pub fn sched_yield ( ) -> libc :: c_int ; } extern "C" { pub fn sched_get_priority_max ( __algorithm : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sched_get_priority_min ( __algorithm : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sched_rr_get_interval ( __pid : __pid_t , __t : * mut timespec ) -> libc :: c_int ; } pub type __jmp_buf = [ libc :: c_long ; 8usize ] ; pub const PTHREAD_CREATE_JOINABLE : _bindgen_ty_9 = 0 ; pub const PTHREAD_CREATE_DETACHED : _bindgen_ty_9 = 1 ; pub type _bindgen_ty_9 = u32 ; pub const PTHREAD_MUTEX_TIMED_NP : _bindgen_ty_10 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE_NP : _bindgen_ty_10 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK_NP : _bindgen_ty_10 = 2 ; pub const PTHREAD_MUTEX_ADAPTIVE_NP : _bindgen_ty_10 = 3 ; pub const PTHREAD_MUTEX_NORMAL : _bindgen_ty_10 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE : _bindgen_ty_10 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK : _bindgen_ty_10 = 2 ; pub const PTHREAD_MUTEX_DEFAULT : _bindgen_ty_10 = 0 ; pub type _bindgen_ty_10 = u32 ; pub const PTHREAD_MUTEX_STALLED : _bindgen_ty_11 = 0 ; pub const PTHREAD_MUTEX_STALLED_NP : _bindgen_ty_11 = 0 ; pub const PTHREAD_MUTEX_ROBUST : _bindgen_ty_11 = 1 ; pub const PTHREAD_MUTEX_ROBUST_NP : _bindgen_ty_11 = 1 ; pub type _bindgen_ty_11 = u32 ; pub const PTHREAD_PRIO_NONE : _bindgen_ty_12 = 0 ; pub const PTHREAD_PRIO_INHERIT : _bindgen_ty_12 = 1 ; pub const PTHREAD_PRIO_PROTECT : _bindgen_ty_12 = 2 ; pub type _bindgen_ty_12 = u32 ; pub const PTHREAD_RWLOCK_PREFER_READER_NP : _bindgen_ty_13 = 0 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NP : _bindgen_ty_13 = 1 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP : _bindgen_ty_13 = 2 ; pub const PTHREAD_RWLOCK_DEFAULT_NP : _bindgen_ty_13 = 0 ; pub type _bindgen_ty_13 = u32 ; pub const PTHREAD_INHERIT_SCHED : _bindgen_ty_14 = 0 ; pub const PTHREAD_EXPLICIT_SCHED : _bindgen_ty_14 = 1 ; pub type _bindgen_ty_14 = u32 ; pub const PTHREAD_SCOPE_SYSTEM : _bindgen_ty_15 = 0 ; pub const PTHREAD_SCOPE_PROCESS : _bindgen_ty_15 = 1 ; pub type _bindgen_ty_15 = u32 ; pub const PTHREAD_PROCESS_PRIVATE : _bindgen_ty_16 = 0 ; pub const PTHREAD_PROCESS_SHARED : _bindgen_ty_16 = 1 ; pub type _bindgen_ty_16 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _pthread_cleanup_buffer { pub __routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) > , pub __arg : * mut libc :: c_void , pub __canceltype : libc :: c_int , pub __prev : * mut _pthread_cleanup_buffer , } impl Default for _pthread_cleanup_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const PTHREAD_CANCEL_ENABLE : _bindgen_ty_17 = 0 ; pub const PTHREAD_CANCEL_DISABLE : _bindgen_ty_17 = 1 ; pub type _bindgen_ty_17 = u32 ; pub const PTHREAD_CANCEL_DEFERRED : _bindgen_ty_18 = 0 ; pub const PTHREAD_CANCEL_ASYNCHRONOUS : _bindgen_ty_18 = 1 ; pub type _bindgen_ty_18 = u32 ; extern "C" { pub fn pthread_create ( __newthread : * mut pthread_t , __attr : * const pthread_attr_t , __start_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) -> * mut libc :: c_void > , __arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_exit ( __retval : * mut libc :: c_void ) ; } extern "C" { pub fn pthread_join ( __th : pthread_t , __thread_return : * mut * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_detach ( __th : pthread_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_self ( ) -> pthread_t ; } extern "C" { pub fn pthread_equal ( __thread1 : pthread_t , __thread2 : pthread_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_init ( __attr : * mut pthread_attr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_destroy ( __attr : * mut pthread_attr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getdetachstate ( __attr : * const pthread_attr_t , __detachstate : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setdetachstate ( __attr : * mut pthread_attr_t , __detachstate : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getguardsize ( __attr : * const pthread_attr_t , __guardsize : * mut usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setguardsize ( __attr : * mut pthread_attr_t , __guardsize : usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getschedparam ( __attr : * const pthread_attr_t , __param : * mut sched_param ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setschedparam ( __attr : * mut pthread_attr_t , __param : * const sched_param ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getschedpolicy ( __attr : * const pthread_attr_t , __policy : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setschedpolicy ( __attr : * mut pthread_attr_t , __policy : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getinheritsched ( __attr : * const pthread_attr_t , __inherit : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setinheritsched ( __attr : * mut pthread_attr_t , __inherit : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getscope ( __attr : * const pthread_attr_t , __scope : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setscope ( __attr : * mut pthread_attr_t , __scope : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getstackaddr ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setstackaddr ( __attr : * mut pthread_attr_t , __stackaddr : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getstacksize ( __attr : * const pthread_attr_t , __stacksize : * mut usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setstacksize ( __attr : * mut pthread_attr_t , __stacksize : usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_getstack ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut libc :: c_void , __stacksize : * mut usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_attr_setstack ( __attr : * mut pthread_attr_t , __stackaddr : * mut libc :: c_void , __stacksize : usize ) -> libc :: c_int ; } extern "C" { pub fn pthread_setschedparam ( __target_thread : pthread_t , __policy : libc :: c_int , __param : * const sched_param ) -> libc :: c_int ; } extern "C" { pub fn pthread_getschedparam ( __target_thread : pthread_t , __policy : * mut libc :: c_int , __param : * mut sched_param ) -> libc :: c_int ; } extern "C" { pub fn pthread_setschedprio ( __target_thread : pthread_t , __prio : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_once ( __once_control : * mut pthread_once_t , __init_routine : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> libc :: c_int ; } extern "C" { pub fn pthread_setcancelstate ( __state : libc :: c_int , __oldstate : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_setcanceltype ( __type : libc :: c_int , __oldtype : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_cancel ( __th : pthread_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_testcancel ( ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_unwind_buf_t { pub __cancel_jmp_buf : [ __pthread_unwind_buf_t__bindgen_ty_1 ; 1usize ] , pub __pad : [ * mut libc :: c_void ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_unwind_buf_t__bindgen_ty_1 { pub __cancel_jmp_buf : __jmp_buf , pub __mask_was_saved : libc :: c_int , } impl Default for __pthread_unwind_buf_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cleanup_frame { pub __cancel_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) > , pub __cancel_arg : * mut libc :: c_void , pub __do_it : libc :: c_int , pub __cancel_type : libc :: c_int , } impl Default for __pthread_cleanup_frame { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn __pthread_register_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { pub fn __pthread_unregister_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { pub fn __pthread_unwind_next ( __buf : * mut __pthread_unwind_buf_t ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __jmp_buf_tag { _unused : [ u8 ; 0 ] , } extern "C" { pub fn __sigsetjmp ( __env : * mut __jmp_buf_tag , __savemask : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_init ( __mutex : * mut pthread_mutex_t , __mutexattr : * const pthread_mutexattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_destroy ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_trylock ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_lock ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_timedlock ( __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_unlock ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_getprioceiling ( __mutex : * const pthread_mutex_t , __prioceiling : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_setprioceiling ( __mutex : * mut pthread_mutex_t , __prioceiling : libc :: c_int , __old_ceiling : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutex_consistent ( __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_init ( __attr : * mut pthread_mutexattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_destroy ( __attr : * mut pthread_mutexattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_getpshared ( __attr : * const pthread_mutexattr_t , __pshared : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_setpshared ( __attr : * mut pthread_mutexattr_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_gettype ( __attr : * const pthread_mutexattr_t , __kind : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_settype ( __attr : * mut pthread_mutexattr_t , __kind : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_getprotocol ( __attr : * const pthread_mutexattr_t , __protocol : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_setprotocol ( __attr : * mut pthread_mutexattr_t , __protocol : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_getprioceiling ( __attr : * const pthread_mutexattr_t , __prioceiling : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_setprioceiling ( __attr : * mut pthread_mutexattr_t , __prioceiling : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_getrobust ( __attr : * const pthread_mutexattr_t , __robustness : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_mutexattr_setrobust ( __attr : * mut pthread_mutexattr_t , __robustness : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_init ( __rwlock : * mut pthread_rwlock_t , __attr : * const pthread_rwlockattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_destroy ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_rdlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_tryrdlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_timedrdlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_wrlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_trywrlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_timedwrlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlock_unlock ( __rwlock : * mut pthread_rwlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_init ( __attr : * mut pthread_rwlockattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_destroy ( __attr : * mut pthread_rwlockattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_getpshared ( __attr : * const pthread_rwlockattr_t , __pshared : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_setpshared ( __attr : * mut pthread_rwlockattr_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_getkind_np ( __attr : * const pthread_rwlockattr_t , __pref : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_rwlockattr_setkind_np ( __attr : * mut pthread_rwlockattr_t , __pref : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_init ( __cond : * mut pthread_cond_t , __cond_attr : * const pthread_condattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_destroy ( __cond : * mut pthread_cond_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_signal ( __cond : * mut pthread_cond_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_broadcast ( __cond : * mut pthread_cond_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_wait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_cond_timedwait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_init ( __attr : * mut pthread_condattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_destroy ( __attr : * mut pthread_condattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_getpshared ( __attr : * const pthread_condattr_t , __pshared : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_setpshared ( __attr : * mut pthread_condattr_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_getclock ( __attr : * const pthread_condattr_t , __clock_id : * mut __clockid_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_condattr_setclock ( __attr : * mut pthread_condattr_t , __clock_id : __clockid_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_init ( __lock : * mut pthread_spinlock_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_destroy ( __lock : * mut pthread_spinlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_lock ( __lock : * mut pthread_spinlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_trylock ( __lock : * mut pthread_spinlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_spin_unlock ( __lock : * mut pthread_spinlock_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrier_init ( __barrier : * mut pthread_barrier_t , __attr : * const pthread_barrierattr_t , __count : libc :: c_uint ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrier_destroy ( __barrier : * mut pthread_barrier_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrier_wait ( __barrier : * mut pthread_barrier_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrierattr_init ( __attr : * mut pthread_barrierattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrierattr_destroy ( __attr : * mut pthread_barrierattr_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrierattr_getpshared ( __attr : * const pthread_barrierattr_t , __pshared : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_barrierattr_setpshared ( __attr : * mut pthread_barrierattr_t , __pshared : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn pthread_key_create ( __key : * mut pthread_key_t , __destr_function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) > ) -> libc :: c_int ; } extern "C" { pub fn pthread_key_delete ( __key : pthread_key_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_getspecific ( __key : pthread_key_t ) -> * mut libc :: c_void ; } extern "C" { pub fn pthread_setspecific ( __key : pthread_key_t , __pointer : * const libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn pthread_getcpuclockid ( __thread_id : pthread_t , __clock_id : * mut __clockid_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_atfork ( __prepare : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __parent : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __child : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sem_t { pub __size : [ libc :: c_char ; 32usize ] , pub __align : libc :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } impl Default for sem_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sem_init ( __sem : * mut sem_t , __pshared : libc :: c_int , __value : libc :: c_uint ) -> libc :: c_int ; } extern "C" { pub fn sem_destroy ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_open ( __name : * const libc :: c_char , __oflag : libc :: c_int , ... ) -> * mut sem_t ; } extern "C" { pub fn sem_close ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_unlink ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn sem_wait ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_timedwait ( __sem : * mut sem_t , __abstime : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn sem_trywait ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_post ( __sem : * mut sem_t ) -> libc :: c_int ; } extern "C" { pub fn sem_getvalue ( __sem : * mut sem_t , __sval : * mut libc :: c_int ) -> libc :: c_int ; } pub type sig_atomic_t = __sig_atomic_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigval { pub sival_int : libc :: c_int , pub sival_ptr : * mut libc :: c_void , _bindgen_union_align : u64 , } impl Default for sigval { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __sigval_t = sigval ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t { pub si_signo : libc :: c_int , pub si_errno : libc :: c_int , pub si_code : libc :: c_int , pub __pad0 : libc :: c_int , pub _sifields : siginfo_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union siginfo_t__bindgen_ty_1 { pub _pad : [ libc :: c_int ; 28usize ] , pub _kill : siginfo_t__bindgen_ty_1__bindgen_ty_1 , pub _timer : siginfo_t__bindgen_ty_1__bindgen_ty_2 , pub _rt : siginfo_t__bindgen_ty_1__bindgen_ty_3 , pub _sigchld : siginfo_t__bindgen_ty_1__bindgen_ty_4 , pub _sigfault : siginfo_t__bindgen_ty_1__bindgen_ty_5 , pub _sigpoll : siginfo_t__bindgen_ty_1__bindgen_ty_6 , pub _sigsys : siginfo_t__bindgen_ty_1__bindgen_ty_7 , _bindgen_union_align : [ u64 ; 14usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 { pub si_pid : __pid_t , pub si_uid : __uid_t , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 { pub si_tid : libc :: c_int , pub si_overrun : libc :: c_int , pub si_sigval : __sigval_t , } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_sigval : __sigval_t , } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_status : libc :: c_int , pub si_utime : __clock_t , pub si_stime : __clock_t , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 { pub si_addr : * mut libc :: c_void , pub si_addr_lsb : libc :: c_short , pub _bounds : siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 { pub _addr_bnd : siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , pub _pkey : __uint32_t , _bindgen_union_align : [ u64 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 { pub _lower : * mut libc :: c_void , pub _upper : * mut libc :: c_void , } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 { pub si_band : libc :: c_long , pub si_fd : libc :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 { pub _call_addr : * mut libc :: c_void , pub _syscall : libc :: c_int , pub _arch : libc :: c_uint , } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for siginfo_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for siginfo_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const SI_ASYNCNL : _bindgen_ty_19 = -60 ; pub const SI_TKILL : _bindgen_ty_19 = -6 ; pub const SI_SIGIO : _bindgen_ty_19 = -5 ; pub const SI_ASYNCIO : _bindgen_ty_19 = -4 ; pub const SI_MESGQ : _bindgen_ty_19 = -3 ; pub const SI_TIMER : _bindgen_ty_19 = -2 ; pub const SI_QUEUE : _bindgen_ty_19 = -1 ; pub const SI_USER : _bindgen_ty_19 = 0 ; pub const SI_KERNEL : _bindgen_ty_19 = 128 ; pub type _bindgen_ty_19 = i32 ; pub const ILL_ILLOPC : _bindgen_ty_20 = 1 ; pub const ILL_ILLOPN : _bindgen_ty_20 = 2 ; pub const ILL_ILLADR : _bindgen_ty_20 = 3 ; pub const ILL_ILLTRP : _bindgen_ty_20 = 4 ; pub const ILL_PRVOPC : _bindgen_ty_20 = 5 ; pub const ILL_PRVREG : _bindgen_ty_20 = 6 ; pub const ILL_COPROC : _bindgen_ty_20 = 7 ; pub const ILL_BADSTK : _bindgen_ty_20 = 8 ; pub type _bindgen_ty_20 = u32 ; pub const FPE_INTDIV : _bindgen_ty_21 = 1 ; pub const FPE_INTOVF : _bindgen_ty_21 = 2 ; pub const FPE_FLTDIV : _bindgen_ty_21 = 3 ; pub const FPE_FLTOVF : _bindgen_ty_21 = 4 ; pub const FPE_FLTUND : _bindgen_ty_21 = 5 ; pub const FPE_FLTRES : _bindgen_ty_21 = 6 ; pub const FPE_FLTINV : _bindgen_ty_21 = 7 ; pub const FPE_FLTSUB : _bindgen_ty_21 = 8 ; pub type _bindgen_ty_21 = u32 ; pub const SEGV_MAPERR : _bindgen_ty_22 = 1 ; pub const SEGV_ACCERR : _bindgen_ty_22 = 2 ; pub const SEGV_BNDERR : _bindgen_ty_22 = 3 ; pub const SEGV_PKUERR : _bindgen_ty_22 = 4 ; pub type _bindgen_ty_22 = u32 ; pub const BUS_ADRALN : _bindgen_ty_23 = 1 ; pub const BUS_ADRERR : _bindgen_ty_23 = 2 ; pub const BUS_OBJERR : _bindgen_ty_23 = 3 ; pub const BUS_MCEERR_AR : _bindgen_ty_23 = 4 ; pub const BUS_MCEERR_AO : _bindgen_ty_23 = 5 ; pub type _bindgen_ty_23 = u32 ; pub const CLD_EXITED : _bindgen_ty_24 = 1 ; pub const CLD_KILLED : _bindgen_ty_24 = 2 ; pub const CLD_DUMPED : _bindgen_ty_24 = 3 ; pub const CLD_TRAPPED : _bindgen_ty_24 = 4 ; pub const CLD_STOPPED : _bindgen_ty_24 = 5 ; pub const CLD_CONTINUED : _bindgen_ty_24 = 6 ; pub type _bindgen_ty_24 = u32 ; pub const POLL_IN : _bindgen_ty_25 = 1 ; pub const POLL_OUT : _bindgen_ty_25 = 2 ; pub const POLL_MSG : _bindgen_ty_25 = 3 ; pub const POLL_ERR : _bindgen_ty_25 = 4 ; pub const POLL_PRI : _bindgen_ty_25 = 5 ; pub const POLL_HUP : _bindgen_ty_25 = 6 ; pub type _bindgen_ty_25 = u32 ; pub type sigval_t = __sigval_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigevent { pub sigev_value : __sigval_t , pub sigev_signo : libc :: c_int , pub sigev_notify : libc :: c_int , pub _sigev_un : sigevent__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigevent__bindgen_ty_1 { pub _pad : [ libc :: c_int ; 12usize ] , pub _tid : __pid_t , pub _sigev_thread : sigevent__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigevent__bindgen_ty_1__bindgen_ty_1 { pub _function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : __sigval_t ) > , pub _attribute : * mut pthread_attr_t , } impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for sigevent__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for sigevent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type sigevent_t = sigevent ; pub const SIGEV_SIGNAL : _bindgen_ty_26 = 0 ; pub const SIGEV_NONE : _bindgen_ty_26 = 1 ; pub const SIGEV_THREAD : _bindgen_ty_26 = 2 ; pub const SIGEV_THREAD_ID : _bindgen_ty_26 = 4 ; pub type _bindgen_ty_26 = u32 ; pub type __sighandler_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : libc :: c_int ) > ; extern "C" { pub fn __sysv_signal ( __sig : libc :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { pub fn signal ( __sig : libc :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { pub fn kill ( __pid : __pid_t , __sig : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn killpg ( __pgrp : __pid_t , __sig : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn raise ( __sig : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ssignal ( __sig : libc :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { pub fn gsignal ( __sig : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn psignal ( __sig : libc :: c_int , __s : * const libc :: c_char ) ; } extern "C" { pub fn psiginfo ( __pinfo : * const siginfo_t , __s : * const libc :: c_char ) ; } extern "C" { pub fn sigblock ( __mask : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sigsetmask ( __mask : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn siggetmask ( ) -> libc :: c_int ; } pub type sig_t = __sighandler_t ; extern "C" { pub fn sigemptyset ( __set : * mut sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigfillset ( __set : * mut sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigaddset ( __set : * mut sigset_t , __signo : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sigdelset ( __set : * mut sigset_t , __signo : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sigismember ( __set : * const sigset_t , __signo : libc :: c_int ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigaction { pub __sigaction_handler : sigaction__bindgen_ty_1 , pub sa_mask : __sigset_t , pub sa_flags : libc :: c_int , pub sa_restorer : :: std :: option :: Option < unsafe extern "C" fn ( ) > , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigaction__bindgen_ty_1 { pub sa_handler : __sighandler_t , pub sa_sigaction : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : libc :: c_int , arg2 : * mut siginfo_t , arg3 : * mut libc :: c_void ) > , _bindgen_union_align : u64 , } impl Default for sigaction__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for sigaction { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sigprocmask ( __how : libc :: c_int , __set : * const sigset_t , __oset : * mut sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigsuspend ( __set : * const sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigaction ( __sig : libc :: c_int , __act : * const sigaction , __oact : * mut sigaction ) -> libc :: c_int ; } extern "C" { pub fn sigpending ( __set : * mut sigset_t ) -> libc :: c_int ; } extern "C" { pub fn sigwait ( __set : * const sigset_t , __sig : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn sigwaitinfo ( __set : * const sigset_t , __info : * mut siginfo_t ) -> libc :: c_int ; } extern "C" { pub fn sigtimedwait ( __set : * const sigset_t , __info : * mut siginfo_t , __timeout : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn sigqueue ( __pid : __pid_t , __sig : libc :: c_int , __val : sigval ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpx_sw_bytes { pub magic1 : __uint32_t , pub extended_size : __uint32_t , pub xstate_bv : __uint64_t , pub xstate_size : __uint32_t , pub __glibc_reserved1 : [ __uint32_t ; 7usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpreg { pub significand : [ libc :: c_ushort ; 4usize ] , pub exponent : libc :: c_ushort , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpxreg { pub significand : [ libc :: c_ushort ; 4usize ] , pub exponent : libc :: c_ushort , pub __glibc_reserved1 : [ libc :: c_ushort ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _fpxreg ; 8usize ] , pub _xmm : [ _xmmreg ; 16usize ] , pub __glibc_reserved1 : [ __uint32_t ; 24usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigcontext { pub r8 : __uint64_t , pub r9 : __uint64_t , pub r10 : __uint64_t , pub r11 : __uint64_t , pub r12 : __uint64_t , pub r13 : __uint64_t , pub r14 : __uint64_t , pub r15 : __uint64_t , pub rdi : __uint64_t , pub rsi : __uint64_t , pub rbp : __uint64_t , pub rbx : __uint64_t , pub rdx : __uint64_t , pub rax : __uint64_t , pub rcx : __uint64_t , pub rsp : __uint64_t , pub rip : __uint64_t , pub eflags : __uint64_t , pub cs : libc :: c_ushort , pub gs : libc :: c_ushort , pub fs : libc :: c_ushort , pub __pad0 : libc :: c_ushort , pub err : __uint64_t , pub trapno : __uint64_t , pub oldmask : __uint64_t , pub cr2 : __uint64_t , pub __bindgen_anon_1 : sigcontext__bindgen_ty_1 , pub __reserved1 : [ __uint64_t ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigcontext__bindgen_ty_1 { pub fpstate : * mut _fpstate , pub __fpstate_word : __uint64_t , _bindgen_union_align : u64 , } impl Default for sigcontext__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for sigcontext { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _xsave_hdr { pub xstate_bv : __uint64_t , pub __glibc_reserved1 : [ __uint64_t ; 2usize ] , pub __glibc_reserved2 : [ __uint64_t ; 5usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _ymmh_state { pub ymmh_space : [ __uint32_t ; 64usize ] , } impl Default for _ymmh_state { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _xstate { pub fpstate : _fpstate , pub xstate_hdr : _xsave_hdr , pub ymmh : _ymmh_state , } impl Default for _xstate { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sigreturn ( __scp : * mut sigcontext ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct stack_t { pub ss_sp : * mut libc :: c_void , pub ss_flags : libc :: c_int , pub ss_size : usize , } impl Default for stack_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type greg_t = libc :: c_longlong ; pub type gregset_t = [ greg_t ; 23usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_fpxreg { pub significand : [ libc :: c_ushort ; 4usize ] , pub exponent : libc :: c_ushort , pub __glibc_reserved1 : [ libc :: c_ushort ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _libc_fpxreg ; 8usize ] , pub _xmm : [ _libc_xmmreg ; 16usize ] , pub __glibc_reserved1 : [ __uint32_t ; 24usize ] , } pub type fpregset_t = * mut _libc_fpstate ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mcontext_t { pub gregs : gregset_t , pub fpregs : fpregset_t , pub __reserved1 : [ libc :: c_ulonglong ; 8usize ] , } impl Default for mcontext_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ucontext_t { pub uc_flags : libc :: c_ulong , pub uc_link : * mut ucontext_t , pub uc_stack : stack_t , pub uc_mcontext : mcontext_t , pub uc_sigmask : sigset_t , pub __fpregs_mem : _libc_fpstate , } impl Default for ucontext_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn siginterrupt ( __sig : libc :: c_int , __interrupt : libc :: c_int ) -> libc :: c_int ; } pub const SS_ONSTACK : _bindgen_ty_27 = 1 ; pub const SS_DISABLE : _bindgen_ty_27 = 2 ; pub type _bindgen_ty_27 = u32 ; extern "C" { pub fn sigaltstack ( __ss : * const stack_t , __oss : * mut stack_t ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigstack { pub ss_sp : * mut libc :: c_void , pub ss_onstack : libc :: c_int , } impl Default for sigstack { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn sigstack ( __ss : * mut sigstack , __oss : * mut sigstack ) -> libc :: c_int ; } extern "C" { pub fn pthread_sigmask ( __how : libc :: c_int , __newmask : * const __sigset_t , __oldmask : * mut __sigset_t ) -> libc :: c_int ; } extern "C" { pub fn pthread_kill ( __threadid : pthread_t , __signo : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn __libc_current_sigrtmin ( ) -> libc :: c_int ; } extern "C" { pub fn __libc_current_sigrtmax ( ) -> libc :: c_int ; } extern "C" { pub fn closelog ( ) ; } extern "C" { pub fn openlog ( __ident : * const libc :: c_char , __option : libc :: c_int , __facility : libc :: c_int ) ; } extern "C" { pub fn setlogmask ( __mask : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn syslog ( __pri : libc :: c_int , __fmt : * const libc :: c_char , ... ) ; } extern "C" { pub fn vsyslog ( __pri : libc :: c_int , __fmt : * const libc :: c_char , __ap : * mut __va_list_tag ) ; } pub type cc_t = libc :: c_uchar ; pub type speed_t = libc :: c_uint ; pub type tcflag_t = libc :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct termios { pub c_iflag : tcflag_t , pub c_oflag : tcflag_t , pub c_cflag : tcflag_t , pub c_lflag : tcflag_t , pub c_line : cc_t , pub c_cc : [ cc_t ; 32usize ] , pub c_ispeed : speed_t , pub c_ospeed : speed_t , } extern "C" { pub fn cfgetospeed ( __termios_p : * const termios ) -> speed_t ; } extern "C" { pub fn cfgetispeed ( __termios_p : * const termios ) -> speed_t ; } extern "C" { pub fn cfsetospeed ( __termios_p : * mut termios , __speed : speed_t ) -> libc :: c_int ; } extern "C" { pub fn cfsetispeed ( __termios_p : * mut termios , __speed : speed_t ) -> libc :: c_int ; } extern "C" { pub fn cfsetspeed ( __termios_p : * mut termios , __speed : speed_t ) -> libc :: c_int ; } extern "C" { pub fn tcgetattr ( __fd : libc :: c_int , __termios_p : * mut termios ) -> libc :: c_int ; } extern "C" { pub fn tcsetattr ( __fd : libc :: c_int , __optional_actions : libc :: c_int , __termios_p : * const termios ) -> libc :: c_int ; } extern "C" { pub fn cfmakeraw ( __termios_p : * mut termios ) ; } extern "C" { pub fn tcsendbreak ( __fd : libc :: c_int , __duration : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tcdrain ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tcflush ( __fd : libc :: c_int , __queue_selector : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tcflow ( __fd : libc :: c_int , __action : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn tcgetsid ( __fd : libc :: c_int ) -> __pid_t ; } pub type useconds_t = __useconds_t ; extern "C" { pub fn access ( __name : * const libc :: c_char , __type : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn faccessat ( __fd : libc :: c_int , __file : * const libc :: c_char , __type : libc :: c_int , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn lseek ( __fd : libc :: c_int , __offset : __off_t , __whence : libc :: c_int ) -> __off_t ; } extern "C" { pub fn close ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn read ( __fd : libc :: c_int , __buf : * mut libc :: c_void , __nbytes : usize ) -> isize ; } extern "C" { pub fn write ( __fd : libc :: c_int , __buf : * const libc :: c_void , __n : usize ) -> isize ; } extern "C" { pub fn pread ( __fd : libc :: c_int , __buf : * mut libc :: c_void , __nbytes : usize , __offset : __off_t ) -> isize ; } extern "C" { pub fn pwrite ( __fd : libc :: c_int , __buf : * const libc :: c_void , __n : usize , __offset : __off_t ) -> isize ; } extern "C" { pub fn pipe ( __pipedes : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn alarm ( __seconds : libc :: c_uint ) -> libc :: c_uint ; } extern "C" { pub fn sleep ( __seconds : libc :: c_uint ) -> libc :: c_uint ; } extern "C" { pub fn ualarm ( __value : __useconds_t , __interval : __useconds_t ) -> __useconds_t ; } extern "C" { pub fn usleep ( __useconds : __useconds_t ) -> libc :: c_int ; } extern "C" { pub fn pause ( ) -> libc :: c_int ; } extern "C" { pub fn chown ( __file : * const libc :: c_char , __owner : __uid_t , __group : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn fchown ( __fd : libc :: c_int , __owner : __uid_t , __group : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn lchown ( __file : * const libc :: c_char , __owner : __uid_t , __group : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn fchownat ( __fd : libc :: c_int , __file : * const libc :: c_char , __owner : __uid_t , __group : __gid_t , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn chdir ( __path : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn fchdir ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getcwd ( __buf : * mut libc :: c_char , __size : usize ) -> * mut libc :: c_char ; } extern "C" { pub fn getwd ( __buf : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn dup ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn dup2 ( __fd : libc :: c_int , __fd2 : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn execve ( __path : * const libc :: c_char , __argv : * const * mut libc :: c_char , __envp : * const * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn fexecve ( __fd : libc :: c_int , __argv : * const * mut libc :: c_char , __envp : * const * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn execv ( __path : * const libc :: c_char , __argv : * const * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn execle ( __path : * const libc :: c_char , __arg : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn execl ( __path : * const libc :: c_char , __arg : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn execvp ( __file : * const libc :: c_char , __argv : * const * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn execlp ( __file : * const libc :: c_char , __arg : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn nice ( __inc : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn _exit ( __status : libc :: c_int ) ; } pub const _PC_LINK_MAX : _bindgen_ty_28 = 0 ; pub const _PC_MAX_CANON : _bindgen_ty_28 = 1 ; pub const _PC_MAX_INPUT : _bindgen_ty_28 = 2 ; pub const _PC_NAME_MAX : _bindgen_ty_28 = 3 ; pub const _PC_PATH_MAX : _bindgen_ty_28 = 4 ; pub const _PC_PIPE_BUF : _bindgen_ty_28 = 5 ; pub const _PC_CHOWN_RESTRICTED : _bindgen_ty_28 = 6 ; pub const _PC_NO_TRUNC : _bindgen_ty_28 = 7 ; pub const _PC_VDISABLE : _bindgen_ty_28 = 8 ; pub const _PC_SYNC_IO : _bindgen_ty_28 = 9 ; pub const _PC_ASYNC_IO : _bindgen_ty_28 = 10 ; pub const _PC_PRIO_IO : _bindgen_ty_28 = 11 ; pub const _PC_SOCK_MAXBUF : _bindgen_ty_28 = 12 ; pub const _PC_FILESIZEBITS : _bindgen_ty_28 = 13 ; pub const _PC_REC_INCR_XFER_SIZE : _bindgen_ty_28 = 14 ; pub const _PC_REC_MAX_XFER_SIZE : _bindgen_ty_28 = 15 ; pub const _PC_REC_MIN_XFER_SIZE : _bindgen_ty_28 = 16 ; pub const _PC_REC_XFER_ALIGN : _bindgen_ty_28 = 17 ; pub const _PC_ALLOC_SIZE_MIN : _bindgen_ty_28 = 18 ; pub const _PC_SYMLINK_MAX : _bindgen_ty_28 = 19 ; pub const _PC_2_SYMLINKS : _bindgen_ty_28 = 20 ; pub type _bindgen_ty_28 = u32 ; pub const _SC_ARG_MAX : _bindgen_ty_29 = 0 ; pub const _SC_CHILD_MAX : _bindgen_ty_29 = 1 ; pub const _SC_CLK_TCK : _bindgen_ty_29 = 2 ; pub const _SC_NGROUPS_MAX : _bindgen_ty_29 = 3 ; pub const _SC_OPEN_MAX : _bindgen_ty_29 = 4 ; pub const _SC_STREAM_MAX : _bindgen_ty_29 = 5 ; pub const _SC_TZNAME_MAX : _bindgen_ty_29 = 6 ; pub const _SC_JOB_CONTROL : _bindgen_ty_29 = 7 ; pub const _SC_SAVED_IDS : _bindgen_ty_29 = 8 ; pub const _SC_REALTIME_SIGNALS : _bindgen_ty_29 = 9 ; pub const _SC_PRIORITY_SCHEDULING : _bindgen_ty_29 = 10 ; pub const _SC_TIMERS : _bindgen_ty_29 = 11 ; pub const _SC_ASYNCHRONOUS_IO : _bindgen_ty_29 = 12 ; pub const _SC_PRIORITIZED_IO : _bindgen_ty_29 = 13 ; pub const _SC_SYNCHRONIZED_IO : _bindgen_ty_29 = 14 ; pub const _SC_FSYNC : _bindgen_ty_29 = 15 ; pub const _SC_MAPPED_FILES : _bindgen_ty_29 = 16 ; pub const _SC_MEMLOCK : _bindgen_ty_29 = 17 ; pub const _SC_MEMLOCK_RANGE : _bindgen_ty_29 = 18 ; pub const _SC_MEMORY_PROTECTION : _bindgen_ty_29 = 19 ; pub const _SC_MESSAGE_PASSING : _bindgen_ty_29 = 20 ; pub const _SC_SEMAPHORES : _bindgen_ty_29 = 21 ; pub const _SC_SHARED_MEMORY_OBJECTS : _bindgen_ty_29 = 22 ; pub const _SC_AIO_LISTIO_MAX : _bindgen_ty_29 = 23 ; pub const _SC_AIO_MAX : _bindgen_ty_29 = 24 ; pub const _SC_AIO_PRIO_DELTA_MAX : _bindgen_ty_29 = 25 ; pub const _SC_DELAYTIMER_MAX : _bindgen_ty_29 = 26 ; pub const _SC_MQ_OPEN_MAX : _bindgen_ty_29 = 27 ; pub const _SC_MQ_PRIO_MAX : _bindgen_ty_29 = 28 ; pub const _SC_VERSION : _bindgen_ty_29 = 29 ; pub const _SC_PAGESIZE : _bindgen_ty_29 = 30 ; pub const _SC_RTSIG_MAX : _bindgen_ty_29 = 31 ; pub const _SC_SEM_NSEMS_MAX : _bindgen_ty_29 = 32 ; pub const _SC_SEM_VALUE_MAX : _bindgen_ty_29 = 33 ; pub const _SC_SIGQUEUE_MAX : _bindgen_ty_29 = 34 ; pub const _SC_TIMER_MAX : _bindgen_ty_29 = 35 ; pub const _SC_BC_BASE_MAX : _bindgen_ty_29 = 36 ; pub const _SC_BC_DIM_MAX : _bindgen_ty_29 = 37 ; pub const _SC_BC_SCALE_MAX : _bindgen_ty_29 = 38 ; pub const _SC_BC_STRING_MAX : _bindgen_ty_29 = 39 ; pub const _SC_COLL_WEIGHTS_MAX : _bindgen_ty_29 = 40 ; pub const _SC_EQUIV_CLASS_MAX : _bindgen_ty_29 = 41 ; pub const _SC_EXPR_NEST_MAX : _bindgen_ty_29 = 42 ; pub const _SC_LINE_MAX : _bindgen_ty_29 = 43 ; pub const _SC_RE_DUP_MAX : _bindgen_ty_29 = 44 ; pub const _SC_CHARCLASS_NAME_MAX : _bindgen_ty_29 = 45 ; pub const _SC_2_VERSION : _bindgen_ty_29 = 46 ; pub const _SC_2_C_BIND : _bindgen_ty_29 = 47 ; pub const _SC_2_C_DEV : _bindgen_ty_29 = 48 ; pub const _SC_2_FORT_DEV : _bindgen_ty_29 = 49 ; pub const _SC_2_FORT_RUN : _bindgen_ty_29 = 50 ; pub const _SC_2_SW_DEV : _bindgen_ty_29 = 51 ; pub const _SC_2_LOCALEDEF : _bindgen_ty_29 = 52 ; pub const _SC_PII : _bindgen_ty_29 = 53 ; pub const _SC_PII_XTI : _bindgen_ty_29 = 54 ; pub const _SC_PII_SOCKET : _bindgen_ty_29 = 55 ; pub const _SC_PII_INTERNET : _bindgen_ty_29 = 56 ; pub const _SC_PII_OSI : _bindgen_ty_29 = 57 ; pub const _SC_POLL : _bindgen_ty_29 = 58 ; pub const _SC_SELECT : _bindgen_ty_29 = 59 ; pub const _SC_UIO_MAXIOV : _bindgen_ty_29 = 60 ; pub const _SC_IOV_MAX : _bindgen_ty_29 = 60 ; pub const _SC_PII_INTERNET_STREAM : _bindgen_ty_29 = 61 ; pub const _SC_PII_INTERNET_DGRAM : _bindgen_ty_29 = 62 ; pub const _SC_PII_OSI_COTS : _bindgen_ty_29 = 63 ; pub const _SC_PII_OSI_CLTS : _bindgen_ty_29 = 64 ; pub const _SC_PII_OSI_M : _bindgen_ty_29 = 65 ; pub const _SC_T_IOV_MAX : _bindgen_ty_29 = 66 ; pub const _SC_THREADS : _bindgen_ty_29 = 67 ; pub const _SC_THREAD_SAFE_FUNCTIONS : _bindgen_ty_29 = 68 ; pub const _SC_GETGR_R_SIZE_MAX : _bindgen_ty_29 = 69 ; pub const _SC_GETPW_R_SIZE_MAX : _bindgen_ty_29 = 70 ; pub const _SC_LOGIN_NAME_MAX : _bindgen_ty_29 = 71 ; pub const _SC_TTY_NAME_MAX : _bindgen_ty_29 = 72 ; pub const _SC_THREAD_DESTRUCTOR_ITERATIONS : _bindgen_ty_29 = 73 ; pub const _SC_THREAD_KEYS_MAX : _bindgen_ty_29 = 74 ; pub const _SC_THREAD_STACK_MIN : _bindgen_ty_29 = 75 ; pub const _SC_THREAD_THREADS_MAX : _bindgen_ty_29 = 76 ; pub const _SC_THREAD_ATTR_STACKADDR : _bindgen_ty_29 = 77 ; pub const _SC_THREAD_ATTR_STACKSIZE : _bindgen_ty_29 = 78 ; pub const _SC_THREAD_PRIORITY_SCHEDULING : _bindgen_ty_29 = 79 ; pub const _SC_THREAD_PRIO_INHERIT : _bindgen_ty_29 = 80 ; pub const _SC_THREAD_PRIO_PROTECT : _bindgen_ty_29 = 81 ; pub const _SC_THREAD_PROCESS_SHARED : _bindgen_ty_29 = 82 ; pub const _SC_NPROCESSORS_CONF : _bindgen_ty_29 = 83 ; pub const _SC_NPROCESSORS_ONLN : _bindgen_ty_29 = 84 ; pub const _SC_PHYS_PAGES : _bindgen_ty_29 = 85 ; pub const _SC_AVPHYS_PAGES : _bindgen_ty_29 = 86 ; pub const _SC_ATEXIT_MAX : _bindgen_ty_29 = 87 ; pub const _SC_PASS_MAX : _bindgen_ty_29 = 88 ; pub const _SC_XOPEN_VERSION : _bindgen_ty_29 = 89 ; pub const _SC_XOPEN_XCU_VERSION : _bindgen_ty_29 = 90 ; pub const _SC_XOPEN_UNIX : _bindgen_ty_29 = 91 ; pub const _SC_XOPEN_CRYPT : _bindgen_ty_29 = 92 ; pub const _SC_XOPEN_ENH_I18N : _bindgen_ty_29 = 93 ; pub const _SC_XOPEN_SHM : _bindgen_ty_29 = 94 ; pub const _SC_2_CHAR_TERM : _bindgen_ty_29 = 95 ; pub const _SC_2_C_VERSION : _bindgen_ty_29 = 96 ; pub const _SC_2_UPE : _bindgen_ty_29 = 97 ; pub const _SC_XOPEN_XPG2 : _bindgen_ty_29 = 98 ; pub const _SC_XOPEN_XPG3 : _bindgen_ty_29 = 99 ; pub const _SC_XOPEN_XPG4 : _bindgen_ty_29 = 100 ; pub const _SC_CHAR_BIT : _bindgen_ty_29 = 101 ; pub const _SC_CHAR_MAX : _bindgen_ty_29 = 102 ; pub const _SC_CHAR_MIN : _bindgen_ty_29 = 103 ; pub const _SC_INT_MAX : _bindgen_ty_29 = 104 ; pub const _SC_INT_MIN : _bindgen_ty_29 = 105 ; pub const _SC_LONG_BIT : _bindgen_ty_29 = 106 ; pub const _SC_WORD_BIT : _bindgen_ty_29 = 107 ; pub const _SC_MB_LEN_MAX : _bindgen_ty_29 = 108 ; pub const _SC_NZERO : _bindgen_ty_29 = 109 ; pub const _SC_SSIZE_MAX : _bindgen_ty_29 = 110 ; pub const _SC_SCHAR_MAX : _bindgen_ty_29 = 111 ; pub const _SC_SCHAR_MIN : _bindgen_ty_29 = 112 ; pub const _SC_SHRT_MAX : _bindgen_ty_29 = 113 ; pub const _SC_SHRT_MIN : _bindgen_ty_29 = 114 ; pub const _SC_UCHAR_MAX : _bindgen_ty_29 = 115 ; pub const _SC_UINT_MAX : _bindgen_ty_29 = 116 ; pub const _SC_ULONG_MAX : _bindgen_ty_29 = 117 ; pub const _SC_USHRT_MAX : _bindgen_ty_29 = 118 ; pub const _SC_NL_ARGMAX : _bindgen_ty_29 = 119 ; pub const _SC_NL_LANGMAX : _bindgen_ty_29 = 120 ; pub const _SC_NL_MSGMAX : _bindgen_ty_29 = 121 ; pub const _SC_NL_NMAX : _bindgen_ty_29 = 122 ; pub const _SC_NL_SETMAX : _bindgen_ty_29 = 123 ; pub const _SC_NL_TEXTMAX : _bindgen_ty_29 = 124 ; pub const _SC_XBS5_ILP32_OFF32 : _bindgen_ty_29 = 125 ; pub const _SC_XBS5_ILP32_OFFBIG : _bindgen_ty_29 = 126 ; pub const _SC_XBS5_LP64_OFF64 : _bindgen_ty_29 = 127 ; pub const _SC_XBS5_LPBIG_OFFBIG : _bindgen_ty_29 = 128 ; pub const _SC_XOPEN_LEGACY : _bindgen_ty_29 = 129 ; pub const _SC_XOPEN_REALTIME : _bindgen_ty_29 = 130 ; pub const _SC_XOPEN_REALTIME_THREADS : _bindgen_ty_29 = 131 ; pub const _SC_ADVISORY_INFO : _bindgen_ty_29 = 132 ; pub const _SC_BARRIERS : _bindgen_ty_29 = 133 ; pub const _SC_BASE : _bindgen_ty_29 = 134 ; pub const _SC_C_LANG_SUPPORT : _bindgen_ty_29 = 135 ; pub const _SC_C_LANG_SUPPORT_R : _bindgen_ty_29 = 136 ; pub const _SC_CLOCK_SELECTION : _bindgen_ty_29 = 137 ; pub const _SC_CPUTIME : _bindgen_ty_29 = 138 ; pub const _SC_THREAD_CPUTIME : _bindgen_ty_29 = 139 ; pub const _SC_DEVICE_IO : _bindgen_ty_29 = 140 ; pub const _SC_DEVICE_SPECIFIC : _bindgen_ty_29 = 141 ; pub const _SC_DEVICE_SPECIFIC_R : _bindgen_ty_29 = 142 ; pub const _SC_FD_MGMT : _bindgen_ty_29 = 143 ; pub const _SC_FIFO : _bindgen_ty_29 = 144 ; pub const _SC_PIPE : _bindgen_ty_29 = 145 ; pub const _SC_FILE_ATTRIBUTES : _bindgen_ty_29 = 146 ; pub const _SC_FILE_LOCKING : _bindgen_ty_29 = 147 ; pub const _SC_FILE_SYSTEM : _bindgen_ty_29 = 148 ; pub const _SC_MONOTONIC_CLOCK : _bindgen_ty_29 = 149 ; pub const _SC_MULTI_PROCESS : _bindgen_ty_29 = 150 ; pub const _SC_SINGLE_PROCESS : _bindgen_ty_29 = 151 ; pub const _SC_NETWORKING : _bindgen_ty_29 = 152 ; pub const _SC_READER_WRITER_LOCKS : _bindgen_ty_29 = 153 ; pub const _SC_SPIN_LOCKS : _bindgen_ty_29 = 154 ; pub const _SC_REGEXP : _bindgen_ty_29 = 155 ; pub const _SC_REGEX_VERSION : _bindgen_ty_29 = 156 ; pub const _SC_SHELL : _bindgen_ty_29 = 157 ; pub const _SC_SIGNALS : _bindgen_ty_29 = 158 ; pub const _SC_SPAWN : _bindgen_ty_29 = 159 ; pub const _SC_SPORADIC_SERVER : _bindgen_ty_29 = 160 ; pub const _SC_THREAD_SPORADIC_SERVER : _bindgen_ty_29 = 161 ; pub const _SC_SYSTEM_DATABASE : _bindgen_ty_29 = 162 ; pub const _SC_SYSTEM_DATABASE_R : _bindgen_ty_29 = 163 ; pub const _SC_TIMEOUTS : _bindgen_ty_29 = 164 ; pub const _SC_TYPED_MEMORY_OBJECTS : _bindgen_ty_29 = 165 ; pub const _SC_USER_GROUPS : _bindgen_ty_29 = 166 ; pub const _SC_USER_GROUPS_R : _bindgen_ty_29 = 167 ; pub const _SC_2_PBS : _bindgen_ty_29 = 168 ; pub const _SC_2_PBS_ACCOUNTING : _bindgen_ty_29 = 169 ; pub const _SC_2_PBS_LOCATE : _bindgen_ty_29 = 170 ; pub const _SC_2_PBS_MESSAGE : _bindgen_ty_29 = 171 ; pub const _SC_2_PBS_TRACK : _bindgen_ty_29 = 172 ; pub const _SC_SYMLOOP_MAX : _bindgen_ty_29 = 173 ; pub const _SC_STREAMS : _bindgen_ty_29 = 174 ; pub const _SC_2_PBS_CHECKPOINT : _bindgen_ty_29 = 175 ; pub const _SC_V6_ILP32_OFF32 : _bindgen_ty_29 = 176 ; pub const _SC_V6_ILP32_OFFBIG : _bindgen_ty_29 = 177 ; pub const _SC_V6_LP64_OFF64 : _bindgen_ty_29 = 178 ; pub const _SC_V6_LPBIG_OFFBIG : _bindgen_ty_29 = 179 ; pub const _SC_HOST_NAME_MAX : _bindgen_ty_29 = 180 ; pub const _SC_TRACE : _bindgen_ty_29 = 181 ; pub const _SC_TRACE_EVENT_FILTER : _bindgen_ty_29 = 182 ; pub const _SC_TRACE_INHERIT : _bindgen_ty_29 = 183 ; pub const _SC_TRACE_LOG : _bindgen_ty_29 = 184 ; pub const _SC_LEVEL1_ICACHE_SIZE : _bindgen_ty_29 = 185 ; pub const _SC_LEVEL1_ICACHE_ASSOC : _bindgen_ty_29 = 186 ; pub const _SC_LEVEL1_ICACHE_LINESIZE : _bindgen_ty_29 = 187 ; pub const _SC_LEVEL1_DCACHE_SIZE : _bindgen_ty_29 = 188 ; pub const _SC_LEVEL1_DCACHE_ASSOC : _bindgen_ty_29 = 189 ; pub const _SC_LEVEL1_DCACHE_LINESIZE : _bindgen_ty_29 = 190 ; pub const _SC_LEVEL2_CACHE_SIZE : _bindgen_ty_29 = 191 ; pub const _SC_LEVEL2_CACHE_ASSOC : _bindgen_ty_29 = 192 ; pub const _SC_LEVEL2_CACHE_LINESIZE : _bindgen_ty_29 = 193 ; pub const _SC_LEVEL3_CACHE_SIZE : _bindgen_ty_29 = 194 ; pub const _SC_LEVEL3_CACHE_ASSOC : _bindgen_ty_29 = 195 ; pub const _SC_LEVEL3_CACHE_LINESIZE : _bindgen_ty_29 = 196 ; pub const _SC_LEVEL4_CACHE_SIZE : _bindgen_ty_29 = 197 ; pub const _SC_LEVEL4_CACHE_ASSOC : _bindgen_ty_29 = 198 ; pub const _SC_LEVEL4_CACHE_LINESIZE : _bindgen_ty_29 = 199 ; pub const _SC_IPV6 : _bindgen_ty_29 = 235 ; pub const _SC_RAW_SOCKETS : _bindgen_ty_29 = 236 ; pub const _SC_V7_ILP32_OFF32 : _bindgen_ty_29 = 237 ; pub const _SC_V7_ILP32_OFFBIG : _bindgen_ty_29 = 238 ; pub const _SC_V7_LP64_OFF64 : _bindgen_ty_29 = 239 ; pub const _SC_V7_LPBIG_OFFBIG : _bindgen_ty_29 = 240 ; pub const _SC_SS_REPL_MAX : _bindgen_ty_29 = 241 ; pub const _SC_TRACE_EVENT_NAME_MAX : _bindgen_ty_29 = 242 ; pub const _SC_TRACE_NAME_MAX : _bindgen_ty_29 = 243 ; pub const _SC_TRACE_SYS_MAX : _bindgen_ty_29 = 244 ; pub const _SC_TRACE_USER_EVENT_MAX : _bindgen_ty_29 = 245 ; pub const _SC_XOPEN_STREAMS : _bindgen_ty_29 = 246 ; pub const _SC_THREAD_ROBUST_PRIO_INHERIT : _bindgen_ty_29 = 247 ; pub const _SC_THREAD_ROBUST_PRIO_PROTECT : _bindgen_ty_29 = 248 ; pub type _bindgen_ty_29 = u32 ; pub const _CS_PATH : _bindgen_ty_30 = 0 ; pub const _CS_V6_WIDTH_RESTRICTED_ENVS : _bindgen_ty_30 = 1 ; pub const _CS_GNU_LIBC_VERSION : _bindgen_ty_30 = 2 ; pub const _CS_GNU_LIBPTHREAD_VERSION : _bindgen_ty_30 = 3 ; pub const _CS_V5_WIDTH_RESTRICTED_ENVS : _bindgen_ty_30 = 4 ; pub const _CS_V7_WIDTH_RESTRICTED_ENVS : _bindgen_ty_30 = 5 ; pub const _CS_LFS_CFLAGS : _bindgen_ty_30 = 1000 ; pub const _CS_LFS_LDFLAGS : _bindgen_ty_30 = 1001 ; pub const _CS_LFS_LIBS : _bindgen_ty_30 = 1002 ; pub const _CS_LFS_LINTFLAGS : _bindgen_ty_30 = 1003 ; pub const _CS_LFS64_CFLAGS : _bindgen_ty_30 = 1004 ; pub const _CS_LFS64_LDFLAGS : _bindgen_ty_30 = 1005 ; pub const _CS_LFS64_LIBS : _bindgen_ty_30 = 1006 ; pub const _CS_LFS64_LINTFLAGS : _bindgen_ty_30 = 1007 ; pub const _CS_XBS5_ILP32_OFF32_CFLAGS : _bindgen_ty_30 = 1100 ; pub const _CS_XBS5_ILP32_OFF32_LDFLAGS : _bindgen_ty_30 = 1101 ; pub const _CS_XBS5_ILP32_OFF32_LIBS : _bindgen_ty_30 = 1102 ; pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS : _bindgen_ty_30 = 1103 ; pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS : _bindgen_ty_30 = 1104 ; pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1105 ; pub const _CS_XBS5_ILP32_OFFBIG_LIBS : _bindgen_ty_30 = 1106 ; pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1107 ; pub const _CS_XBS5_LP64_OFF64_CFLAGS : _bindgen_ty_30 = 1108 ; pub const _CS_XBS5_LP64_OFF64_LDFLAGS : _bindgen_ty_30 = 1109 ; pub const _CS_XBS5_LP64_OFF64_LIBS : _bindgen_ty_30 = 1110 ; pub const _CS_XBS5_LP64_OFF64_LINTFLAGS : _bindgen_ty_30 = 1111 ; pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_30 = 1112 ; pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1113 ; pub const _CS_XBS5_LPBIG_OFFBIG_LIBS : _bindgen_ty_30 = 1114 ; pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1115 ; pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS : _bindgen_ty_30 = 1116 ; pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS : _bindgen_ty_30 = 1117 ; pub const _CS_POSIX_V6_ILP32_OFF32_LIBS : _bindgen_ty_30 = 1118 ; pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS : _bindgen_ty_30 = 1119 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS : _bindgen_ty_30 = 1120 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1121 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS : _bindgen_ty_30 = 1122 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1123 ; pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS : _bindgen_ty_30 = 1124 ; pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS : _bindgen_ty_30 = 1125 ; pub const _CS_POSIX_V6_LP64_OFF64_LIBS : _bindgen_ty_30 = 1126 ; pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS : _bindgen_ty_30 = 1127 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_30 = 1128 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1129 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS : _bindgen_ty_30 = 1130 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1131 ; pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS : _bindgen_ty_30 = 1132 ; pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS : _bindgen_ty_30 = 1133 ; pub const _CS_POSIX_V7_ILP32_OFF32_LIBS : _bindgen_ty_30 = 1134 ; pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS : _bindgen_ty_30 = 1135 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS : _bindgen_ty_30 = 1136 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1137 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS : _bindgen_ty_30 = 1138 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1139 ; pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS : _bindgen_ty_30 = 1140 ; pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS : _bindgen_ty_30 = 1141 ; pub const _CS_POSIX_V7_LP64_OFF64_LIBS : _bindgen_ty_30 = 1142 ; pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS : _bindgen_ty_30 = 1143 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_30 = 1144 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_30 = 1145 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS : _bindgen_ty_30 = 1146 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_30 = 1147 ; pub const _CS_V6_ENV : _bindgen_ty_30 = 1148 ; pub const _CS_V7_ENV : _bindgen_ty_30 = 1149 ; pub type _bindgen_ty_30 = u32 ; extern "C" { pub fn pathconf ( __path : * const libc :: c_char , __name : libc :: c_int ) -> libc :: c_long ; } extern "C" { pub fn fpathconf ( __fd : libc :: c_int , __name : libc :: c_int ) -> libc :: c_long ; } extern "C" { pub fn sysconf ( __name : libc :: c_int ) -> libc :: c_long ; } extern "C" { pub fn confstr ( __name : libc :: c_int , __buf : * mut libc :: c_char , __len : usize ) -> usize ; } extern "C" { pub fn getpid ( ) -> __pid_t ; } extern "C" { pub fn getppid ( ) -> __pid_t ; } extern "C" { pub fn getpgrp ( ) -> __pid_t ; } extern "C" { pub fn __getpgid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { pub fn getpgid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { pub fn setpgid ( __pid : __pid_t , __pgid : __pid_t ) -> libc :: c_int ; } extern "C" { pub fn setpgrp ( ) -> libc :: c_int ; } extern "C" { pub fn setsid ( ) -> __pid_t ; } extern "C" { pub fn getsid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { pub fn getuid ( ) -> __uid_t ; } extern "C" { pub fn geteuid ( ) -> __uid_t ; } extern "C" { pub fn getgid ( ) -> __gid_t ; } extern "C" { pub fn getegid ( ) -> __gid_t ; } extern "C" { pub fn getgroups ( __size : libc :: c_int , __list : * mut __gid_t ) -> libc :: c_int ; } extern "C" { pub fn setuid ( __uid : __uid_t ) -> libc :: c_int ; } extern "C" { pub fn setreuid ( __ruid : __uid_t , __euid : __uid_t ) -> libc :: c_int ; } extern "C" { pub fn seteuid ( __uid : __uid_t ) -> libc :: c_int ; } extern "C" { pub fn setgid ( __gid : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn setregid ( __rgid : __gid_t , __egid : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn setegid ( __gid : __gid_t ) -> libc :: c_int ; } extern "C" { pub fn fork ( ) -> __pid_t ; } extern "C" { pub fn vfork ( ) -> libc :: c_int ; } extern "C" { pub fn ttyname ( __fd : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { pub fn ttyname_r ( __fd : libc :: c_int , __buf : * mut libc :: c_char , __buflen : usize ) -> libc :: c_int ; } extern "C" { pub fn isatty ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn ttyslot ( ) -> libc :: c_int ; } extern "C" { pub fn link ( __from : * const libc :: c_char , __to : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn linkat ( __fromfd : libc :: c_int , __from : * const libc :: c_char , __tofd : libc :: c_int , __to : * const libc :: c_char , __flags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn symlink ( __from : * const libc :: c_char , __to : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn readlink ( __path : * const libc :: c_char , __buf : * mut libc :: c_char , __len : usize ) -> isize ; } extern "C" { pub fn symlinkat ( __from : * const libc :: c_char , __tofd : libc :: c_int , __to : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn readlinkat ( __fd : libc :: c_int , __path : * const libc :: c_char , __buf : * mut libc :: c_char , __len : usize ) -> isize ; } extern "C" { pub fn unlink ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn unlinkat ( __fd : libc :: c_int , __name : * const libc :: c_char , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn rmdir ( __path : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn tcgetpgrp ( __fd : libc :: c_int ) -> __pid_t ; } extern "C" { pub fn tcsetpgrp ( __fd : libc :: c_int , __pgrp_id : __pid_t ) -> libc :: c_int ; } extern "C" { pub fn getlogin ( ) -> * mut libc :: c_char ; } extern "C" { pub fn getlogin_r ( __name : * mut libc :: c_char , __name_len : usize ) -> libc :: c_int ; } extern "C" { pub fn setlogin ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getopt ( ___argc : libc :: c_int , ___argv : * const * mut libc :: c_char , __shortopts : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn gethostname ( __name : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn sethostname ( __name : * const libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn sethostid ( __id : libc :: c_long ) -> libc :: c_int ; } extern "C" { pub fn getdomainname ( __name : * mut libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn setdomainname ( __name : * const libc :: c_char , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn vhangup ( ) -> libc :: c_int ; } extern "C" { pub fn revoke ( __file : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn profil ( __sample_buffer : * mut libc :: c_ushort , __size : usize , __offset : usize , __scale : libc :: c_uint ) -> libc :: c_int ; } extern "C" { pub fn acct ( __name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getusershell ( ) -> * mut libc :: c_char ; } extern "C" { pub fn endusershell ( ) ; } extern "C" { pub fn setusershell ( ) ; } extern "C" { pub fn daemon ( __nochdir : libc :: c_int , __noclose : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn chroot ( __path : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn getpass ( __prompt : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn fsync ( __fd : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn gethostid ( ) -> libc :: c_long ; } extern "C" { pub fn sync ( ) ; } extern "C" { pub fn getpagesize ( ) -> libc :: c_int ; } extern "C" { pub fn getdtablesize ( ) -> libc :: c_int ; } extern "C" { pub fn truncate ( __file : * const libc :: c_char , __length : __off_t ) -> libc :: c_int ; } extern "C" { pub fn ftruncate ( __fd : libc :: c_int , __length : __off_t ) -> libc :: c_int ; } extern "C" { pub fn brk ( __addr : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn sbrk ( __delta : isize ) -> * mut libc :: c_void ; } extern "C" { pub fn syscall ( __sysno : libc :: c_long , ... ) -> libc :: c_long ; } extern "C" { pub fn fdatasync ( __fildes : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getentropy ( __buffer : * mut libc :: c_void , __length : usize ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct if_nameindex { pub if_index : libc :: c_uint , pub if_name : * mut libc :: c_char , } impl Default for if_nameindex { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const IFF_UP : _bindgen_ty_31 = 1 ; pub const IFF_BROADCAST : _bindgen_ty_31 = 2 ; pub const IFF_DEBUG : _bindgen_ty_31 = 4 ; pub const IFF_LOOPBACK : _bindgen_ty_31 = 8 ; pub const IFF_POINTOPOINT : _bindgen_ty_31 = 16 ; pub const IFF_NOTRAILERS : _bindgen_ty_31 = 32 ; pub const IFF_RUNNING : _bindgen_ty_31 = 64 ; pub const IFF_NOARP : _bindgen_ty_31 = 128 ; pub const IFF_PROMISC : _bindgen_ty_31 = 256 ; pub const IFF_ALLMULTI : _bindgen_ty_31 = 512 ; pub const IFF_MASTER : _bindgen_ty_31 = 1024 ; pub const IFF_SLAVE : _bindgen_ty_31 = 2048 ; pub const IFF_MULTICAST : _bindgen_ty_31 = 4096 ; pub const IFF_PORTSEL : _bindgen_ty_31 = 8192 ; pub const IFF_AUTOMEDIA : _bindgen_ty_31 = 16384 ; pub const IFF_DYNAMIC : _bindgen_ty_31 = 32768 ; pub type _bindgen_ty_31 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifaddr { pub ifa_addr : sockaddr , pub ifa_ifu : ifaddr__bindgen_ty_1 , pub ifa_ifp : * mut iface , pub ifa_next : * mut ifaddr , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifaddr__bindgen_ty_1 { pub ifu_broadaddr : sockaddr , pub ifu_dstaddr : sockaddr , _bindgen_union_align : [ u16 ; 8usize ] , } impl Default for ifaddr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for ifaddr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ifmap { pub mem_start : libc :: c_ulong , pub mem_end : libc :: c_ulong , pub base_addr : libc :: c_ushort , pub irq : libc :: c_uchar , pub dma : libc :: c_uchar , pub port : libc :: c_uchar , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifreq { pub ifr_ifrn : ifreq__bindgen_ty_1 , pub ifr_ifru : ifreq__bindgen_ty_2 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifreq__bindgen_ty_1 { pub ifrn_name : [ libc :: c_char ; 16usize ] , _bindgen_union_align : [ u8 ; 16usize ] , } impl Default for ifreq__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifreq__bindgen_ty_2 { pub ifru_addr : sockaddr , pub ifru_dstaddr : sockaddr , pub ifru_broadaddr : sockaddr , pub ifru_netmask : sockaddr , pub ifru_hwaddr : sockaddr , pub ifru_flags : libc :: c_short , pub ifru_ivalue : libc :: c_int , pub ifru_mtu : libc :: c_int , pub ifru_map : ifmap , pub ifru_slave : [ libc :: c_char ; 16usize ] , pub ifru_newname : [ libc :: c_char ; 16usize ] , pub ifru_data : __caddr_t , _bindgen_union_align : [ u64 ; 3usize ] , } impl Default for ifreq__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for ifreq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifconf { pub ifc_len : libc :: c_int , pub ifc_ifcu : ifconf__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifconf__bindgen_ty_1 { pub ifcu_buf : __caddr_t , pub ifcu_req : * mut ifreq , _bindgen_union_align : u64 , } impl Default for ifconf__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for ifconf { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn if_nametoindex ( __ifname : * const libc :: c_char ) -> libc :: c_uint ; } extern "C" { pub fn if_indextoname ( __ifindex : libc :: c_uint , __ifname : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { pub fn if_nameindex ( ) -> * mut if_nameindex ; } extern "C" { pub fn if_freenameindex ( __ptr : * mut if_nameindex ) ; } pub type tcp_seq = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcphdr { pub __bindgen_anon_1 : tcphdr__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union tcphdr__bindgen_ty_1 { pub __bindgen_anon_1 : tcphdr__bindgen_ty_1__bindgen_ty_1 , pub __bindgen_anon_2 : tcphdr__bindgen_ty_1__bindgen_ty_2 , _bindgen_union_align : [ u32 ; 5usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 { pub th_sport : u16 , pub th_dport : u16 , pub th_seq : tcp_seq , pub th_ack : tcp_seq , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub th_flags : u8 , pub th_win : u16 , pub th_sum : u16 , pub th_urp : u16 , } impl tcphdr__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn th_x2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_th_x2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn th_off ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_th_off ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( th_x2 : u8 , th_off : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let th_x2 : u8 = unsafe { :: std :: mem :: transmute ( th_x2 ) } ; th_x2 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let th_off : u8 = unsafe { :: std :: mem :: transmute ( th_off ) } ; th_off as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 { pub source : u16 , pub dest : u16 , pub seq : u32 , pub ack_seq : u32 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub window : u16 , pub check : u16 , pub urg_ptr : u16 , } impl tcphdr__bindgen_ty_1__bindgen_ty_2 { # [ inline ] pub fn res1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_res1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn doff ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_doff ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn fin ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_fin ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn syn ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_syn ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rst ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_rst ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn psh ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_psh ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ack ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ack ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn urg ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_urg ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn res2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_res2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( res1 : u16 , doff : u16 , fin : u16 , syn : u16 , rst : u16 , psh : u16 , ack : u16 , urg : u16 , res2 : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let res1 : u16 = unsafe { :: std :: mem :: transmute ( res1 ) } ; res1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let doff : u16 = unsafe { :: std :: mem :: transmute ( doff ) } ; doff as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let fin : u16 = unsafe { :: std :: mem :: transmute ( fin ) } ; fin as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let syn : u16 = unsafe { :: std :: mem :: transmute ( syn ) } ; syn as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let rst : u16 = unsafe { :: std :: mem :: transmute ( rst ) } ; rst as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let psh : u16 = unsafe { :: std :: mem :: transmute ( psh ) } ; psh as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let ack : u16 = unsafe { :: std :: mem :: transmute ( ack ) } ; ack as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let urg : u16 = unsafe { :: std :: mem :: transmute ( urg ) } ; urg as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let res2 : u16 = unsafe { :: std :: mem :: transmute ( res2 ) } ; res2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for tcphdr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for tcphdr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const TCP_ESTABLISHED : _bindgen_ty_32 = 1 ; pub const TCP_SYN_SENT : _bindgen_ty_32 = 2 ; pub const TCP_SYN_RECV : _bindgen_ty_32 = 3 ; pub const TCP_FIN_WAIT1 : _bindgen_ty_32 = 4 ; pub const TCP_FIN_WAIT2 : _bindgen_ty_32 = 5 ; pub const TCP_TIME_WAIT : _bindgen_ty_32 = 6 ; pub const TCP_CLOSE : _bindgen_ty_32 = 7 ; pub const TCP_CLOSE_WAIT : _bindgen_ty_32 = 8 ; pub const TCP_LAST_ACK : _bindgen_ty_32 = 9 ; pub const TCP_LISTEN : _bindgen_ty_32 = 10 ; pub const TCP_CLOSING : _bindgen_ty_32 = 11 ; pub type _bindgen_ty_32 = u32 ; pub const tcp_ca_state_TCP_CA_Open : tcp_ca_state = 0 ; pub const tcp_ca_state_TCP_CA_Disorder : tcp_ca_state = 1 ; pub const tcp_ca_state_TCP_CA_CWR : tcp_ca_state = 2 ; pub const tcp_ca_state_TCP_CA_Recovery : tcp_ca_state = 3 ; pub const tcp_ca_state_TCP_CA_Loss : tcp_ca_state = 4 ; pub type tcp_ca_state = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_info { pub tcpi_state : u8 , pub tcpi_ca_state : u8 , pub tcpi_retransmits : u8 , pub tcpi_probes : u8 , pub tcpi_backoff : u8 , pub tcpi_options : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub tcpi_rto : u32 , pub tcpi_ato : u32 , pub tcpi_snd_mss : u32 , pub tcpi_rcv_mss : u32 , pub tcpi_unacked : u32 , pub tcpi_sacked : u32 , pub tcpi_lost : u32 , pub tcpi_retrans : u32 , pub tcpi_fackets : u32 , pub tcpi_last_data_sent : u32 , pub tcpi_last_ack_sent : u32 , pub tcpi_last_data_recv : u32 , pub tcpi_last_ack_recv : u32 , pub tcpi_pmtu : u32 , pub tcpi_rcv_ssthresh : u32 , pub tcpi_rtt : u32 , pub tcpi_rttvar : u32 , pub tcpi_snd_ssthresh : u32 , pub tcpi_snd_cwnd : u32 , pub tcpi_advmss : u32 , pub tcpi_reordering : u32 , pub tcpi_rcv_rtt : u32 , pub tcpi_rcv_space : u32 , pub tcpi_total_retrans : u32 , } impl tcp_info { # [ inline ] pub fn tcpi_snd_wscale ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_tcpi_snd_wscale ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn tcpi_rcv_wscale ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_tcpi_rcv_wscale ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tcpi_snd_wscale : u8 , tcpi_rcv_wscale : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let tcpi_snd_wscale : u8 = unsafe { :: std :: mem :: transmute ( tcpi_snd_wscale ) } ; tcpi_snd_wscale as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let tcpi_rcv_wscale : u8 = unsafe { :: std :: mem :: transmute ( tcpi_rcv_wscale ) } ; tcpi_rcv_wscale as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcp_md5sig { pub tcpm_addr : sockaddr_storage , pub tcpm_flags : u8 , pub tcpm_prefixlen : u8 , pub tcpm_keylen : u16 , pub __tcpm_pad : u32 , pub tcpm_key : [ u8 ; 80usize ] , } impl Default for tcp_md5sig { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_repair_opt { pub opt_code : u32 , pub opt_val : u32 , } pub const TCP_NO_QUEUE : _bindgen_ty_33 = 0 ; pub const TCP_RECV_QUEUE : _bindgen_ty_33 = 1 ; pub const TCP_SEND_QUEUE : _bindgen_ty_33 = 2 ; pub const TCP_QUEUES_NR : _bindgen_ty_33 = 3 ; pub type _bindgen_ty_33 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcp_cookie_transactions { pub tcpct_flags : u16 , pub __tcpct_pad1 : u8 , pub tcpct_cookie_desired : u8 , pub tcpct_s_data_desired : u16 , pub tcpct_used : u16 , pub tcpct_value : [ u8 ; 536usize ] , } impl Default for tcp_cookie_transactions { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_repair_window { pub snd_wl1 : u32 , pub snd_wnd : u32 , pub max_window : u32 , pub rcv_wnd : u32 , pub rcv_wup : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct winsize { pub ws_row : libc :: c_ushort , pub ws_col : libc :: c_ushort , pub ws_xpixel : libc :: c_ushort , pub ws_ypixel : libc :: c_ushort , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct termio { pub c_iflag : libc :: c_ushort , pub c_oflag : libc :: c_ushort , pub c_cflag : libc :: c_ushort , pub c_lflag : libc :: c_ushort , pub c_line : libc :: c_uchar , pub c_cc : [ libc :: c_uchar ; 8usize ] , } extern "C" { pub fn ioctl ( __fd : libc :: c_int , __request : libc :: c_ulong , ... ) -> libc :: c_int ; } extern "C" { pub fn mmap ( __addr : * mut libc :: c_void , __len : usize , __prot : libc :: c_int , __flags : libc :: c_int , __fd : libc :: c_int , __offset : __off_t ) -> * mut libc :: c_void ; } extern "C" { pub fn munmap ( __addr : * mut libc :: c_void , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn mprotect ( __addr : * mut libc :: c_void , __len : usize , __prot : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn msync ( __addr : * mut libc :: c_void , __len : usize , __flags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn madvise ( __addr : * mut libc :: c_void , __len : usize , __advice : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn posix_madvise ( __addr : * mut libc :: c_void , __len : usize , __advice : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn mlock ( __addr : * const libc :: c_void , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn munlock ( __addr : * const libc :: c_void , __len : usize ) -> libc :: c_int ; } extern "C" { pub fn mlockall ( __flags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn munlockall ( ) -> libc :: c_int ; } extern "C" { pub fn mincore ( __start : * mut libc :: c_void , __len : usize , __vec : * mut libc :: c_uchar ) -> libc :: c_int ; } extern "C" { pub fn shm_open ( __name : * const libc :: c_char , __oflag : libc :: c_int , __mode : mode_t ) -> libc :: c_int ; } extern "C" { pub fn shm_unlink ( __name : * const libc :: c_char ) -> libc :: c_int ; } pub const __rlimit_resource_RLIMIT_CPU : __rlimit_resource = 0 ; pub const __rlimit_resource_RLIMIT_FSIZE : __rlimit_resource = 1 ; pub const __rlimit_resource_RLIMIT_DATA : __rlimit_resource = 2 ; pub const __rlimit_resource_RLIMIT_STACK : __rlimit_resource = 3 ; pub const __rlimit_resource_RLIMIT_CORE : __rlimit_resource = 4 ; pub const __rlimit_resource___RLIMIT_RSS : __rlimit_resource = 5 ; pub const __rlimit_resource_RLIMIT_NOFILE : __rlimit_resource = 7 ; pub const __rlimit_resource___RLIMIT_OFILE : __rlimit_resource = 7 ; pub const __rlimit_resource_RLIMIT_AS : __rlimit_resource = 9 ; pub const __rlimit_resource___RLIMIT_NPROC : __rlimit_resource = 6 ; pub const __rlimit_resource___RLIMIT_MEMLOCK : __rlimit_resource = 8 ; pub const __rlimit_resource___RLIMIT_LOCKS : __rlimit_resource = 10 ; pub const __rlimit_resource___RLIMIT_SIGPENDING : __rlimit_resource = 11 ; pub const __rlimit_resource___RLIMIT_MSGQUEUE : __rlimit_resource = 12 ; pub const __rlimit_resource___RLIMIT_NICE : __rlimit_resource = 13 ; pub const __rlimit_resource___RLIMIT_RTPRIO : __rlimit_resource = 14 ; pub const __rlimit_resource___RLIMIT_RTTIME : __rlimit_resource = 15 ; pub const __rlimit_resource___RLIMIT_NLIMITS : __rlimit_resource = 16 ; pub const __rlimit_resource___RLIM_NLIMITS : __rlimit_resource = 16 ; pub type __rlimit_resource = u32 ; pub type rlim_t = __rlim_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct rlimit { pub rlim_cur : rlim_t , pub rlim_max : rlim_t , } pub const __rusage_who_RUSAGE_SELF : __rusage_who = 0 ; pub const __rusage_who_RUSAGE_CHILDREN : __rusage_who = -1 ; pub type __rusage_who = i32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct rusage { pub ru_utime : timeval , pub ru_stime : timeval , pub __bindgen_anon_1 : rusage__bindgen_ty_1 , pub __bindgen_anon_2 : rusage__bindgen_ty_2 , pub __bindgen_anon_3 : rusage__bindgen_ty_3 , pub __bindgen_anon_4 : rusage__bindgen_ty_4 , pub __bindgen_anon_5 : rusage__bindgen_ty_5 , pub __bindgen_anon_6 : rusage__bindgen_ty_6 , pub __bindgen_anon_7 : rusage__bindgen_ty_7 , pub __bindgen_anon_8 : rusage__bindgen_ty_8 , pub __bindgen_anon_9 : rusage__bindgen_ty_9 , pub __bindgen_anon_10 : rusage__bindgen_ty_10 , pub __bindgen_anon_11 : rusage__bindgen_ty_11 , pub __bindgen_anon_12 : rusage__bindgen_ty_12 , pub __bindgen_anon_13 : rusage__bindgen_ty_13 , pub __bindgen_anon_14 : rusage__bindgen_ty_14 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_1 { pub ru_maxrss : libc :: c_long , pub __ru_maxrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_2 { pub ru_ixrss : libc :: c_long , pub __ru_ixrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_3 { pub ru_idrss : libc :: c_long , pub __ru_idrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_4 { pub ru_isrss : libc :: c_long , pub __ru_isrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_4 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_5 { pub ru_minflt : libc :: c_long , pub __ru_minflt_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_5 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_6 { pub ru_majflt : libc :: c_long , pub __ru_majflt_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_6 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_7 { pub ru_nswap : libc :: c_long , pub __ru_nswap_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_8 { pub ru_inblock : libc :: c_long , pub __ru_inblock_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_8 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_9 { pub ru_oublock : libc :: c_long , pub __ru_oublock_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_9 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_10 { pub ru_msgsnd : libc :: c_long , pub __ru_msgsnd_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_10 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_11 { pub ru_msgrcv : libc :: c_long , pub __ru_msgrcv_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_11 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_12 { pub ru_nsignals : libc :: c_long , pub __ru_nsignals_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_12 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_13 { pub ru_nvcsw : libc :: c_long , pub __ru_nvcsw_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_13 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_14 { pub ru_nivcsw : libc :: c_long , pub __ru_nivcsw_word : __syscall_slong_t , _bindgen_union_align : u64 , } impl Default for rusage__bindgen_ty_14 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for rusage { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const __priority_which_PRIO_PROCESS : __priority_which = 0 ; pub const __priority_which_PRIO_PGRP : __priority_which = 1 ; pub const __priority_which_PRIO_USER : __priority_which = 2 ; pub type __priority_which = u32 ; pub type __rlimit_resource_t = libc :: c_int ; pub type __rusage_who_t = libc :: c_int ; pub type __priority_which_t = libc :: c_int ; extern "C" { pub fn getrlimit ( __resource : __rlimit_resource_t , __rlimits : * mut rlimit ) -> libc :: c_int ; } extern "C" { pub fn setrlimit ( __resource : __rlimit_resource_t , __rlimits : * const rlimit ) -> libc :: c_int ; } extern "C" { pub fn getrusage ( __who : __rusage_who_t , __usage : * mut rusage ) -> libc :: c_int ; } extern "C" { pub fn getpriority ( __which : __priority_which_t , __who : id_t ) -> libc :: c_int ; } extern "C" { pub fn setpriority ( __which : __priority_which_t , __who : id_t , __prio : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn stat ( __file : * const libc :: c_char , __buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn fstat ( __fd : libc :: c_int , __buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn fstatat ( __fd : libc :: c_int , __file : * const libc :: c_char , __buf : * mut stat , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn lstat ( __file : * const libc :: c_char , __buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn chmod ( __file : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn lchmod ( __file : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn fchmod ( __fd : libc :: c_int , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn fchmodat ( __fd : libc :: c_int , __file : * const libc :: c_char , __mode : __mode_t , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn umask ( __mask : __mode_t ) -> __mode_t ; } extern "C" { pub fn mkdir ( __path : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn mkdirat ( __fd : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn mknod ( __path : * const libc :: c_char , __mode : __mode_t , __dev : __dev_t ) -> libc :: c_int ; } extern "C" { pub fn mknodat ( __fd : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t , __dev : __dev_t ) -> libc :: c_int ; } extern "C" { pub fn mkfifo ( __path : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn mkfifoat ( __fd : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t ) -> libc :: c_int ; } extern "C" { pub fn utimensat ( __fd : libc :: c_int , __path : * const libc :: c_char , __times : * const timespec , __flags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn futimens ( __fd : libc :: c_int , __times : * const timespec ) -> libc :: c_int ; } extern "C" { pub fn __fxstat ( __ver : libc :: c_int , __fildes : libc :: c_int , __stat_buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn __xstat ( __ver : libc :: c_int , __filename : * const libc :: c_char , __stat_buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn __lxstat ( __ver : libc :: c_int , __filename : * const libc :: c_char , __stat_buf : * mut stat ) -> libc :: c_int ; } extern "C" { pub fn __fxstatat ( __ver : libc :: c_int , __fildes : libc :: c_int , __filename : * const libc :: c_char , __stat_buf : * mut stat , __flag : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn __xmknod ( __ver : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t , __dev : * mut __dev_t ) -> libc :: c_int ; } extern "C" { pub fn __xmknodat ( __ver : libc :: c_int , __fd : libc :: c_int , __path : * const libc :: c_char , __mode : __mode_t , __dev : * mut __dev_t ) -> libc :: c_int ; } extern "C" { pub fn readv ( __fd : libc :: c_int , __iovec : * const iovec , __count : libc :: c_int ) -> isize ; } extern "C" { pub fn writev ( __fd : libc :: c_int , __iovec : * const iovec , __count : libc :: c_int ) -> isize ; } extern "C" { pub fn preadv ( __fd : libc :: c_int , __iovec : * const iovec , __count : libc :: c_int , __offset : __off_t ) -> isize ; } extern "C" { pub fn pwritev ( __fd : libc :: c_int , __iovec : * const iovec , __count : libc :: c_int , __offset : __off_t ) -> isize ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_un { pub sun_family : sa_family_t , pub sun_path : [ libc :: c_char ; 108usize ] , } impl Default for sockaddr_un { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct user_fpregs_struct { pub cwd : libc :: c_ushort , pub swd : libc :: c_ushort , pub ftw : libc :: c_ushort , pub fop : libc :: c_ushort , pub rip : libc :: c_ulonglong , pub rdp : libc :: c_ulonglong , pub mxcsr : libc :: c_uint , pub mxcr_mask : libc :: c_uint , pub st_space : [ libc :: c_uint ; 32usize ] , pub xmm_space : [ libc :: c_uint ; 64usize ] , pub padding : [ libc :: c_uint ; 24usize ] , } impl Default for user_fpregs_struct { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct user_regs_struct { pub r15 : libc :: c_ulonglong , pub r14 : libc :: c_ulonglong , pub r13 : libc :: c_ulonglong , pub r12 : libc :: c_ulonglong , pub rbp : libc :: c_ulonglong , pub rbx : libc :: c_ulonglong , pub r11 : libc :: c_ulonglong , pub r10 : libc :: c_ulonglong , pub r9 : libc :: c_ulonglong , pub r8 : libc :: c_ulonglong , pub rax : libc :: c_ulonglong , pub rcx : libc :: c_ulonglong , pub rdx : libc :: c_ulonglong , pub rsi : libc :: c_ulonglong , pub rdi : libc :: c_ulonglong , pub orig_rax : libc :: c_ulonglong , pub rip : libc :: c_ulonglong , pub cs : libc :: c_ulonglong , pub eflags : libc :: c_ulonglong , pub rsp : libc :: c_ulonglong , pub ss : libc :: c_ulonglong , pub fs_base : libc :: c_ulonglong , pub gs_base : libc :: c_ulonglong , pub ds : libc :: c_ulonglong , pub es : libc :: c_ulonglong , pub fs : libc :: c_ulonglong , pub gs : libc :: c_ulonglong , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct user { pub regs : user_regs_struct , pub u_fpvalid : libc :: c_int , pub i387 : user_fpregs_struct , pub u_tsize : libc :: c_ulonglong , pub u_dsize : libc :: c_ulonglong , pub u_ssize : libc :: c_ulonglong , pub start_code : libc :: c_ulonglong , pub start_stack : libc :: c_ulonglong , pub signal : libc :: c_longlong , pub reserved : libc :: c_int , pub __bindgen_anon_1 : user__bindgen_ty_1 , pub __bindgen_anon_2 : user__bindgen_ty_2 , pub magic : libc :: c_ulonglong , pub u_comm : [ libc :: c_char ; 32usize ] , pub u_debugreg : [ libc :: c_ulonglong ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union user__bindgen_ty_1 { pub u_ar0 : * mut user_regs_struct , pub __u_ar0_word : libc :: c_ulonglong , _bindgen_union_align : u64 , } impl Default for user__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union user__bindgen_ty_2 { pub u_fpstate : * mut user_fpregs_struct , pub __u_fpstate_word : libc :: c_ulonglong , _bindgen_union_align : u64 , } impl Default for user__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for user { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn wait ( __stat_loc : * mut libc :: c_int ) -> __pid_t ; } extern "C" { pub fn waitpid ( __pid : __pid_t , __stat_loc : * mut libc :: c_int , __options : libc :: c_int ) -> __pid_t ; } extern "C" { pub fn waitid ( __idtype : idtype_t , __id : __id_t , __infop : * mut siginfo_t , __options : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn wait3 ( __stat_loc : * mut libc :: c_int , __options : libc :: c_int , __usage : * mut rusage ) -> __pid_t ; } extern "C" { pub fn wait4 ( __pid : __pid_t , __stat_loc : * mut libc :: c_int , __options : libc :: c_int , __usage : * mut rusage ) -> __pid_t ; } pub type s_reg_t = libc :: c_long ; pub type active_reg_t = libc :: c_ulong ; pub type reg_syntax_t = libc :: c_ulong ; pub const reg_errcode_t_REG_ENOSYS : reg_errcode_t = -1 ; pub const reg_errcode_t_REG_NOERROR : reg_errcode_t = 0 ; pub const reg_errcode_t_REG_NOMATCH : reg_errcode_t = 1 ; pub const reg_errcode_t_REG_BADPAT : reg_errcode_t = 2 ; pub const reg_errcode_t_REG_ECOLLATE : reg_errcode_t = 3 ; pub const reg_errcode_t_REG_ECTYPE : reg_errcode_t = 4 ; pub const reg_errcode_t_REG_EESCAPE : reg_errcode_t = 5 ; pub const reg_errcode_t_REG_ESUBREG : reg_errcode_t = 6 ; pub const reg_errcode_t_REG_EBRACK : reg_errcode_t = 7 ; pub const reg_errcode_t_REG_EPAREN : reg_errcode_t = 8 ; pub const reg_errcode_t_REG_EBRACE : reg_errcode_t = 9 ; pub const reg_errcode_t_REG_BADBR : reg_errcode_t = 10 ; pub const reg_errcode_t_REG_ERANGE : reg_errcode_t = 11 ; pub const reg_errcode_t_REG_ESPACE : reg_errcode_t = 12 ; pub const reg_errcode_t_REG_BADRPT : reg_errcode_t = 13 ; pub const reg_errcode_t_REG_EEND : reg_errcode_t = 14 ; pub const reg_errcode_t_REG_ESIZE : reg_errcode_t = 15 ; pub const reg_errcode_t_REG_ERPAREN : reg_errcode_t = 16 ; pub type reg_errcode_t = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct re_pattern_buffer { pub __buffer : * mut libc :: c_uchar , pub __allocated : libc :: c_ulong , pub __used : libc :: c_ulong , pub __syntax : reg_syntax_t , pub __fastmap : * mut libc :: c_char , pub __translate : * mut libc :: c_uchar , pub re_nsub : usize , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub __bindgen_padding_0 : [ u8 ; 7usize ] , } impl Default for re_pattern_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl re_pattern_buffer { # [ inline ] pub fn __can_be_null ( & self ) -> libc :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___can_be_null ( & mut self , val : libc :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn __regs_allocated ( & self ) -> libc :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set___regs_allocated ( & mut self , val : libc :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 2u8 , val as u64 ) } } # [ inline ] pub fn __fastmap_accurate ( & self ) -> libc :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___fastmap_accurate ( & mut self , val : libc :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn __no_sub ( & self ) -> libc :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___no_sub ( & mut self , val : libc :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn __not_bol ( & self ) -> libc :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___not_bol ( & mut self , val : libc :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn __not_eol ( & self ) -> libc :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___not_eol ( & mut self , val : libc :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn __newline_anchor ( & self ) -> libc :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___newline_anchor ( & mut self , val : libc :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( __can_be_null : libc :: c_uint , __regs_allocated : libc :: c_uint , __fastmap_accurate : libc :: c_uint , __no_sub : libc :: c_uint , __not_bol : libc :: c_uint , __not_eol : libc :: c_uint , __newline_anchor : libc :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let __can_be_null : u32 = unsafe { :: std :: mem :: transmute ( __can_be_null ) } ; __can_be_null as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 2u8 , { let __regs_allocated : u32 = unsafe { :: std :: mem :: transmute ( __regs_allocated ) } ; __regs_allocated as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let __fastmap_accurate : u32 = unsafe { :: std :: mem :: transmute ( __fastmap_accurate ) } ; __fastmap_accurate as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let __no_sub : u32 = unsafe { :: std :: mem :: transmute ( __no_sub ) } ; __no_sub as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let __not_bol : u32 = unsafe { :: std :: mem :: transmute ( __not_bol ) } ; __not_bol as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let __not_eol : u32 = unsafe { :: std :: mem :: transmute ( __not_eol ) } ; __not_eol as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let __newline_anchor : u32 = unsafe { :: std :: mem :: transmute ( __newline_anchor ) } ; __newline_anchor as u64 } ) ; __bindgen_bitfield_unit } } pub type regex_t = re_pattern_buffer ; pub type regoff_t = libc :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct regmatch_t { pub rm_so : regoff_t , pub rm_eo : regoff_t , } extern "C" { pub fn regcomp ( __preg : * mut regex_t , __pattern : * const libc :: c_char , __cflags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn regexec ( __preg : * const regex_t , __string : * const libc :: c_char , __nmatch : usize , __pmatch : * mut regmatch_t , __eflags : libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn regerror ( __errcode : libc :: c_int , __preg : * const regex_t , __errbuf : * mut libc :: c_char , __errbuf_size : usize ) -> usize ; } extern "C" { pub fn regfree ( __preg : * mut regex_t ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct option { pub name : * const libc :: c_char , pub has_arg : libc :: c_int , pub flag : * mut libc :: c_int , pub val : libc :: c_int , } impl Default for option { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn getopt_long ( ___argc : libc :: c_int , ___argv : * const * mut libc :: c_char , __shortopts : * const libc :: c_char , __longopts : * const option , __longind : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { pub fn getopt_long_only ( ___argc : libc :: c_int , ___argv : * const * mut libc :: c_char , __shortopts : * const libc :: c_char , __longopts : * const option , __longind : * mut libc :: c_int ) -> libc :: c_int ; } extern "C" { 
 /// Base 64 Encoding with Standard Base64 Alphabet defined in RFC4684.
///
/// \param dst Buffer address of encoded Base64 string. Its length should be enough
/// to contain Base64 string and the terminating null byte ('\0'), so it needs to be at
/// least as long as 1 + spdk_base64_get_encoded_strlen(src_len).
/// \param src Raw data buffer to be encoded.
/// \param src_len Length of raw data buffer.
///
/// \return 0 on success.
/// \return -EINVAL if dst or src is NULL, or binary_len <= 0. 
 pub fn spdk_base64_encode ( dst : * mut libc :: c_char , src : * const libc :: c_void , src_len : usize ) -> libc :: c_int ; } extern "C" { 
 /// Base 64 Encoding with URL and Filename Safe Alphabet.
///
/// \param dst Buffer address of encoded Base64 string. Its length should be enough
/// to contain Base64 string and the terminating null byte ('\0'), so it needs to be at
/// least as long as 1 + spdk_base64_get_encoded_strlen(src_len).
/// \param src Raw data buffer to be encoded.
/// \param src_len Length of raw data buffer.
///
/// \return 0 on success.
/// \return -EINVAL if dst or src is NULL, or binary_len <= 0. 
 pub fn spdk_base64_urlsafe_encode ( dst : * mut libc :: c_char , src : * const libc :: c_void , src_len : usize ) -> libc :: c_int ; } extern "C" { 
 /// Base 64 Decoding with Standard Base64 Alphabet defined in RFC4684.
///
/// \param dst Buffer address of decoded raw data. Its length should be enough
/// to contain decoded raw data, so it needs to be at least as long as
/// spdk_base64_get_decoded_len(encoded_strlen).
/// \param dst_len Output parameter for the length of actual decoded raw data.
/// If NULL, the actual decoded length won't be returned.
/// \param src Data buffer for base64 string to be decoded.
///
/// \return 0 on success.
/// \return -EINVAL if dst or src is NULL, or content of src is illegal. 
 pub fn spdk_base64_decode ( dst : * mut libc :: c_void , dst_len : * mut usize , src : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Base 64 Decoding with URL and Filename Safe Alphabet.
///
/// \param dst Buffer address of decoded raw data. Its length should be enough
/// to contain decoded raw data, so it needs to be at least as long as
/// spdk_base64_get_decoded_len(encoded_strlen).
/// \param dst_len Output parameter for the length of actual decoded raw data.
/// If NULL, the actual decoded length won't be returned.
/// \param src Data buffer for base64 string to be decoded.
///
/// \return 0 on success.
/// \return -EINVAL if dst or src is NULL, or content of src is illegal. 
 pub fn spdk_base64_urlsafe_decode ( dst : * mut libc :: c_void , dst_len : * mut usize , src : * const libc :: c_char ) -> libc :: c_int ; } pub const spdk_scsi_group_code_SPDK_SCSI_6BYTE_CMD : spdk_scsi_group_code = 0 ; pub const spdk_scsi_group_code_SPDK_SCSI_10BYTE_CMD : spdk_scsi_group_code = 32 ; pub const spdk_scsi_group_code_SPDK_SCSI_10BYTE_CMD2 : spdk_scsi_group_code = 64 ; pub const spdk_scsi_group_code_SPDK_SCSI_16BYTE_CMD : spdk_scsi_group_code = 128 ; pub const spdk_scsi_group_code_SPDK_SCSI_12BYTE_CMD : spdk_scsi_group_code = 160 ; pub type spdk_scsi_group_code = u32 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_GOOD : spdk_scsi_status = 0 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_CHECK_CONDITION : spdk_scsi_status = 2 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_CONDITION_MET : spdk_scsi_status = 4 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_BUSY : spdk_scsi_status = 8 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_INTERMEDIATE : spdk_scsi_status = 16 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_INTERMEDIATE_CONDITION_MET : spdk_scsi_status = 20 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_RESERVATION_CONFLICT : spdk_scsi_status = 24 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_Obsolete : spdk_scsi_status = 34 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_TASK_SET_FULL : spdk_scsi_status = 40 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_ACA_ACTIVE : spdk_scsi_status = 48 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_TASK_ABORTED : spdk_scsi_status = 64 ; pub type spdk_scsi_status = u32 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_NO_SENSE : spdk_scsi_sense = 0 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_RECOVERED_ERROR : spdk_scsi_sense = 1 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_NOT_READY : spdk_scsi_sense = 2 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_MEDIUM_ERROR : spdk_scsi_sense = 3 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_HARDWARE_ERROR : spdk_scsi_sense = 4 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_ILLEGAL_REQUEST : spdk_scsi_sense = 5 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_UNIT_ATTENTION : spdk_scsi_sense = 6 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_DATA_PROTECT : spdk_scsi_sense = 7 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_BLANK_CHECK : spdk_scsi_sense = 8 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_VENDOR_SPECIFIC : spdk_scsi_sense = 9 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_COPY_ABORTED : spdk_scsi_sense = 10 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_ABORTED_COMMAND : spdk_scsi_sense = 11 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_VOLUME_OVERFLOW : spdk_scsi_sense = 13 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_MISCOMPARE : spdk_scsi_sense = 14 ; pub type spdk_scsi_sense = u32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_NO_ADDITIONAL_SENSE : spdk_scsi_asc = 0 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_PERIPHERAL_DEVICE_WRITE_FAULT : spdk_scsi_asc = 3 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_UNIT_NOT_READY : spdk_scsi_asc = 4 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_WARNING : spdk_scsi_asc = 11 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_GUARD_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_UNRECOVERED_READ_ERROR : spdk_scsi_asc = 17 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_MISCOMPARE_DURING_VERIFY_OPERATION : spdk_scsi_asc = 29 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INVALID_COMMAND_OPERATION_CODE : spdk_scsi_asc = 32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_ACCESS_DENIED : spdk_scsi_asc = 32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE : spdk_scsi_asc = 33 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INVALID_FIELD_IN_CDB : spdk_scsi_asc = 36 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED : spdk_scsi_asc = 37 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_WRITE_PROTECTED : spdk_scsi_asc = 39 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_FORMAT_COMMAND_FAILED : spdk_scsi_asc = 49 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_SAVING_PARAMETERS_NOT_SUPPORTED : spdk_scsi_asc = 57 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INTERNAL_TARGET_FAILURE : spdk_scsi_asc = 68 ; pub type spdk_scsi_asc = u32 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_CAUSE_NOT_REPORTABLE : spdk_scsi_ascq = 0 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_BECOMING_READY : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_FORMAT_COMMAND_FAILED : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_GUARD_CHECK_FAILED : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED : spdk_scsi_ascq = 2 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_NO_ACCESS_RIGHTS : spdk_scsi_ascq = 2 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED : spdk_scsi_ascq = 3 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_POWER_LOSS_EXPECTED : spdk_scsi_ascq = 8 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_INVALID_LU_IDENTIFIER : spdk_scsi_ascq = 9 ; pub type spdk_scsi_ascq = u32 ; pub const spdk_spc_opcode_SPDK_SPC_ACCESS_CONTROL_IN : spdk_spc_opcode = 134 ; pub const spdk_spc_opcode_SPDK_SPC_ACCESS_CONTROL_OUT : spdk_spc_opcode = 135 ; pub const spdk_spc_opcode_SPDK_SPC_EXTENDED_COPY : spdk_spc_opcode = 131 ; pub const spdk_spc_opcode_SPDK_SPC_INQUIRY : spdk_spc_opcode = 18 ; pub const spdk_spc_opcode_SPDK_SPC_LOG_SELECT : spdk_spc_opcode = 76 ; pub const spdk_spc_opcode_SPDK_SPC_LOG_SENSE : spdk_spc_opcode = 77 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SELECT_6 : spdk_spc_opcode = 21 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SELECT_10 : spdk_spc_opcode = 85 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SENSE_6 : spdk_spc_opcode = 26 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SENSE_10 : spdk_spc_opcode = 90 ; pub const spdk_spc_opcode_SPDK_SPC_PERSISTENT_RESERVE_IN : spdk_spc_opcode = 94 ; pub const spdk_spc_opcode_SPDK_SPC_PERSISTENT_RESERVE_OUT : spdk_spc_opcode = 95 ; pub const spdk_spc_opcode_SPDK_SPC_PREVENT_ALLOW_MEDIUM_REMOVAL : spdk_spc_opcode = 30 ; pub const spdk_spc_opcode_SPDK_SPC_READ_ATTRIBUTE : spdk_spc_opcode = 140 ; pub const spdk_spc_opcode_SPDK_SPC_READ_BUFFER : spdk_spc_opcode = 60 ; pub const spdk_spc_opcode_SPDK_SPC_RECEIVE_COPY_RESULTS : spdk_spc_opcode = 132 ; pub const spdk_spc_opcode_SPDK_SPC_RECEIVE_DIAGNOSTIC_RESULTS : spdk_spc_opcode = 28 ; pub const spdk_spc_opcode_SPDK_SPC_REPORT_LUNS : spdk_spc_opcode = 160 ; pub const spdk_spc_opcode_SPDK_SPC_REQUEST_SENSE : spdk_spc_opcode = 3 ; pub const spdk_spc_opcode_SPDK_SPC_SEND_DIAGNOSTIC : spdk_spc_opcode = 29 ; pub const spdk_spc_opcode_SPDK_SPC_TEST_UNIT_READY : spdk_spc_opcode = 0 ; pub const spdk_spc_opcode_SPDK_SPC_WRITE_ATTRIBUTE : spdk_spc_opcode = 141 ; pub const spdk_spc_opcode_SPDK_SPC_WRITE_BUFFER : spdk_spc_opcode = 59 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_IN_12 : spdk_spc_opcode = 171 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_OUT_12 : spdk_spc_opcode = 169 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_IN_16 : spdk_spc_opcode = 158 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_OUT_16 : spdk_spc_opcode = 159 ; pub const spdk_spc_opcode_SPDK_SPC_VARIABLE_LENGTH : spdk_spc_opcode = 127 ; pub const spdk_spc_opcode_SPDK_SPC_MO_CHANGE_ALIASES : spdk_spc_opcode = 11 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_DEVICE_IDENTIFIER : spdk_spc_opcode = 6 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_PRIORITY : spdk_spc_opcode = 14 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_TARGET_PORT_GROUPS : spdk_spc_opcode = 10 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_TIMESTAMP : spdk_spc_opcode = 15 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_ALIASES : spdk_spc_opcode = 11 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_DEVICE_IDENTIFIER : spdk_spc_opcode = 5 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_PRIORITY : spdk_spc_opcode = 14 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_SUPPORTED_OPERATION_CODES : spdk_spc_opcode = 12 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_SUPPORTED_TASK_MANAGEMENT_FUNCTIONS : spdk_spc_opcode = 13 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_TARGET_PORT_GROUPS : spdk_spc_opcode = 10 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_TIMESTAMP : spdk_spc_opcode = 15 ; pub const spdk_spc_opcode_SPDK_SPC2_RELEASE_6 : spdk_spc_opcode = 23 ; pub const spdk_spc_opcode_SPDK_SPC2_RELEASE_10 : spdk_spc_opcode = 87 ; pub const spdk_spc_opcode_SPDK_SPC2_RESERVE_6 : spdk_spc_opcode = 22 ; pub const spdk_spc_opcode_SPDK_SPC2_RESERVE_10 : spdk_spc_opcode = 86 ; pub type spdk_spc_opcode = u32 ; pub const spdk_scc_opcode_SPDK_SCC_MAINTENANCE_IN : spdk_scc_opcode = 163 ; pub const spdk_scc_opcode_SPDK_SCC_MAINTENANCE_OUT : spdk_scc_opcode = 164 ; pub type spdk_scc_opcode = u32 ; pub const spdk_sbc_opcode_SPDK_SBC_COMPARE_AND_WRITE : spdk_sbc_opcode = 137 ; pub const spdk_sbc_opcode_SPDK_SBC_FORMAT_UNIT : spdk_sbc_opcode = 4 ; pub const spdk_sbc_opcode_SPDK_SBC_GET_LBA_STATUS : spdk_sbc_opcode = 1179806 ; pub const spdk_sbc_opcode_SPDK_SBC_ORWRITE_16 : spdk_sbc_opcode = 139 ; pub const spdk_sbc_opcode_SPDK_SBC_PRE_FETCH_10 : spdk_sbc_opcode = 52 ; pub const spdk_sbc_opcode_SPDK_SBC_PRE_FETCH_16 : spdk_sbc_opcode = 144 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_6 : spdk_sbc_opcode = 8 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_10 : spdk_sbc_opcode = 40 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_12 : spdk_sbc_opcode = 168 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_16 : spdk_sbc_opcode = 136 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_ATTRIBUTE : spdk_sbc_opcode = 140 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_BUFFER : spdk_sbc_opcode = 60 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_CAPACITY_10 : spdk_sbc_opcode = 37 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_DEFECT_DATA_10 : spdk_sbc_opcode = 55 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_DEFECT_DATA_12 : spdk_sbc_opcode = 183 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_LONG_10 : spdk_sbc_opcode = 62 ; pub const spdk_sbc_opcode_SPDK_SBC_REASSIGN_BLOCKS : spdk_sbc_opcode = 7 ; pub const spdk_sbc_opcode_SPDK_SBC_SANITIZE : spdk_sbc_opcode = 72 ; pub const spdk_sbc_opcode_SPDK_SBC_START_STOP_UNIT : spdk_sbc_opcode = 27 ; pub const spdk_sbc_opcode_SPDK_SBC_SYNCHRONIZE_CACHE_10 : spdk_sbc_opcode = 53 ; pub const spdk_sbc_opcode_SPDK_SBC_SYNCHRONIZE_CACHE_16 : spdk_sbc_opcode = 145 ; pub const spdk_sbc_opcode_SPDK_SBC_UNMAP : spdk_sbc_opcode = 66 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_10 : spdk_sbc_opcode = 47 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_12 : spdk_sbc_opcode = 175 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_16 : spdk_sbc_opcode = 143 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_6 : spdk_sbc_opcode = 10 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_10 : spdk_sbc_opcode = 42 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_12 : spdk_sbc_opcode = 170 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_16 : spdk_sbc_opcode = 138 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_10 : spdk_sbc_opcode = 46 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_12 : spdk_sbc_opcode = 174 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_16 : spdk_sbc_opcode = 142 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_LONG_10 : spdk_sbc_opcode = 63 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_SAME_10 : spdk_sbc_opcode = 65 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_SAME_16 : spdk_sbc_opcode = 147 ; pub const spdk_sbc_opcode_SPDK_SBC_XDREAD_10 : spdk_sbc_opcode = 82 ; pub const spdk_sbc_opcode_SPDK_SBC_XDWRITE_10 : spdk_sbc_opcode = 80 ; pub const spdk_sbc_opcode_SPDK_SBC_XDWRITEREAD_10 : spdk_sbc_opcode = 83 ; pub const spdk_sbc_opcode_SPDK_SBC_XPWRITE_10 : spdk_sbc_opcode = 81 ; pub const spdk_sbc_opcode_SPDK_SBC_SAI_READ_CAPACITY_16 : spdk_sbc_opcode = 16 ; pub const spdk_sbc_opcode_SPDK_SBC_SAI_READ_LONG_16 : spdk_sbc_opcode = 17 ; pub const spdk_sbc_opcode_SPDK_SBC_SAO_WRITE_LONG_16 : spdk_sbc_opcode = 17 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_READ_32 : spdk_sbc_opcode = 9 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_VERIFY_32 : spdk_sbc_opcode = 10 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_32 : spdk_sbc_opcode = 11 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_AND_VERIFY_32 : spdk_sbc_opcode = 12 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_SAME_32 : spdk_sbc_opcode = 13 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDREAD_32 : spdk_sbc_opcode = 3 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDWRITE_32 : spdk_sbc_opcode = 4 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDWRITEREAD_32 : spdk_sbc_opcode = 7 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XPWRITE_32 : spdk_sbc_opcode = 6 ; pub type spdk_sbc_opcode = u32 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DISC_STRUCTURE : spdk_mmc_opcode = 173 ; pub const spdk_mmc_opcode_SPDK_MMC_BLANK : spdk_mmc_opcode = 161 ; pub const spdk_mmc_opcode_SPDK_MMC_CLOSE_TRACK_SESSION : spdk_mmc_opcode = 91 ; pub const spdk_mmc_opcode_SPDK_MMC_ERASE_10 : spdk_mmc_opcode = 44 ; pub const spdk_mmc_opcode_SPDK_MMC_FORMAT_UNIT : spdk_mmc_opcode = 4 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_CONFIGURATION : spdk_mmc_opcode = 70 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_EVENT_STATUS_NOTIFICATION : spdk_mmc_opcode = 74 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_PERFORMANCE : spdk_mmc_opcode = 172 ; pub const spdk_mmc_opcode_SPDK_MMC_INQUIRY : spdk_mmc_opcode = 18 ; pub const spdk_mmc_opcode_SPDK_MMC_LOAD_UNLOAD_MEDIUM : spdk_mmc_opcode = 166 ; pub const spdk_mmc_opcode_SPDK_MMC_MECHANISM_STATUS : spdk_mmc_opcode = 189 ; pub const spdk_mmc_opcode_SPDK_MMC_MODE_SELECT_10 : spdk_mmc_opcode = 85 ; pub const spdk_mmc_opcode_SPDK_MMC_MODE_SENSE_10 : spdk_mmc_opcode = 90 ; pub const spdk_mmc_opcode_SPDK_MMC_PAUSE_RESUME : spdk_mmc_opcode = 75 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_10 : spdk_mmc_opcode = 69 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_12 : spdk_mmc_opcode = 165 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_MSF : spdk_mmc_opcode = 71 ; pub const spdk_mmc_opcode_SPDK_MMC_PREVENT_ALLOW_MEDIUM_REMOVAL : spdk_mmc_opcode = 30 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_10 : spdk_mmc_opcode = 40 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_12 : spdk_mmc_opcode = 168 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_BUFFER : spdk_mmc_opcode = 60 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_BUFFER_CAPACITY : spdk_mmc_opcode = 92 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CAPACITY : spdk_mmc_opcode = 37 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CD : spdk_mmc_opcode = 190 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CD_MSF : spdk_mmc_opcode = 185 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DISC_INFORMATION : spdk_mmc_opcode = 81 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DVD_STRUCTURE : spdk_mmc_opcode = 173 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_FORMAT_CAPACITIES : spdk_mmc_opcode = 35 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_SUB_CHANNEL : spdk_mmc_opcode = 66 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_TOC_PMA_ATIP : spdk_mmc_opcode = 67 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_TRACK_INFORMATION : spdk_mmc_opcode = 82 ; pub const spdk_mmc_opcode_SPDK_MMC_REPAIR_TRACK : spdk_mmc_opcode = 88 ; pub const spdk_mmc_opcode_SPDK_MMC_REPORT_KEY : spdk_mmc_opcode = 164 ; pub const spdk_mmc_opcode_SPDK_MMC_REQUEST_SENSE : spdk_mmc_opcode = 3 ; pub const spdk_mmc_opcode_SPDK_MMC_RESERVE_TRACK : spdk_mmc_opcode = 83 ; pub const spdk_mmc_opcode_SPDK_MMC_SCAN : spdk_mmc_opcode = 186 ; pub const spdk_mmc_opcode_SPDK_MMC_SEEK_10 : spdk_mmc_opcode = 43 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_CUE_SHEET : spdk_mmc_opcode = 93 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_DVD_STRUCTURE : spdk_mmc_opcode = 191 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_KEY : spdk_mmc_opcode = 163 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_OPC_INFORMATION : spdk_mmc_opcode = 84 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_CD_SPEED : spdk_mmc_opcode = 187 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_READ_AHEAD : spdk_mmc_opcode = 167 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_STREAMING : spdk_mmc_opcode = 182 ; pub const spdk_mmc_opcode_SPDK_MMC_START_STOP_UNIT : spdk_mmc_opcode = 27 ; pub const spdk_mmc_opcode_SPDK_MMC_STOP_PLAY_SCAN : spdk_mmc_opcode = 78 ; pub const spdk_mmc_opcode_SPDK_MMC_SYNCHRONIZE_CACHE : spdk_mmc_opcode = 53 ; pub const spdk_mmc_opcode_SPDK_MMC_TEST_UNIT_READY : spdk_mmc_opcode = 0 ; pub const spdk_mmc_opcode_SPDK_MMC_VERIFY_10 : spdk_mmc_opcode = 47 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_10 : spdk_mmc_opcode = 162 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_12 : spdk_mmc_opcode = 170 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_AND_VERIFY_10 : spdk_mmc_opcode = 46 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_BUFFER : spdk_mmc_opcode = 59 ; pub type spdk_mmc_opcode = u32 ; pub const spdk_ssc_opcode_SPDK_SSC_ERASE_6 : spdk_ssc_opcode = 25 ; pub const spdk_ssc_opcode_SPDK_SSC_FORMAT_MEDIUM : spdk_ssc_opcode = 4 ; pub const spdk_ssc_opcode_SPDK_SSC_LOAD_UNLOAD : spdk_ssc_opcode = 27 ; pub const spdk_ssc_opcode_SPDK_SSC_LOCATE_10 : spdk_ssc_opcode = 43 ; pub const spdk_ssc_opcode_SPDK_SSC_LOCATE_16 : spdk_ssc_opcode = 146 ; pub const spdk_ssc_opcode_SPDK_SSC_MOVE_MEDIUM_ATTACHED : spdk_ssc_opcode = 167 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_6 : spdk_ssc_opcode = 8 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_BLOCK_LIMITS : spdk_ssc_opcode = 5 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_ELEMENT_STATUS_ATTACHED : spdk_ssc_opcode = 180 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_POSITION : spdk_ssc_opcode = 52 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_REVERSE_6 : spdk_ssc_opcode = 15 ; pub const spdk_ssc_opcode_SPDK_SSC_RECOVER_BUFFERED_DATA : spdk_ssc_opcode = 20 ; pub const spdk_ssc_opcode_SPDK_SSC_REPORT_DENSITY_SUPPORT : spdk_ssc_opcode = 68 ; pub const spdk_ssc_opcode_SPDK_SSC_REWIND : spdk_ssc_opcode = 1 ; pub const spdk_ssc_opcode_SPDK_SSC_SET_CAPACITY : spdk_ssc_opcode = 11 ; pub const spdk_ssc_opcode_SPDK_SSC_SPACE_6 : spdk_ssc_opcode = 17 ; pub const spdk_ssc_opcode_SPDK_SSC_SPACE_16 : spdk_ssc_opcode = 145 ; pub const spdk_ssc_opcode_SPDK_SSC_VERIFY_6 : spdk_ssc_opcode = 19 ; pub const spdk_ssc_opcode_SPDK_SSC_WRITE_6 : spdk_ssc_opcode = 10 ; pub const spdk_ssc_opcode_SPDK_SSC_WRITE_FILEMARKS_6 : spdk_ssc_opcode = 16 ; pub type spdk_ssc_opcode = u32 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_DEVICE_IDENTIFICATION : spdk_spc_vpd = 131 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_EXTENDED_INQUIRY_DATA : spdk_spc_vpd = 134 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_MANAGEMENT_NETWORK_ADDRESSES : spdk_spc_vpd = 133 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_MODE_PAGE_POLICY : spdk_spc_vpd = 135 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SCSI_PORTS : spdk_spc_vpd = 136 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SOFTWARE_INTERFACE_IDENTIFICATION : spdk_spc_vpd = 132 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SUPPORTED_VPD_PAGES : spdk_spc_vpd = 0 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_UNIT_SERIAL_NUMBER : spdk_spc_vpd = 128 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_LIMITS : spdk_spc_vpd = 176 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_DEV_CHARS : spdk_spc_vpd = 177 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_THIN_PROVISION : spdk_spc_vpd = 178 ; pub type spdk_spc_vpd = u32 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_CONNECTED : spdk_spc_peripheral_qualifier = 0 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_NOT_CONNECTED : spdk_spc_peripheral_qualifier = 1 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_NOT_CAPABLE : spdk_spc_peripheral_qualifier = 3 ; pub type spdk_spc_peripheral_qualifier = u32 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_DISK : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_TAPE : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_DVD : _bindgen_ty_34 = 5 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_CHANGER : _bindgen_ty_34 = 8 ; pub const SPDK_SPC_VERSION_NONE : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_VERSION_SPC : _bindgen_ty_34 = 3 ; pub const SPDK_SPC_VERSION_SPC2 : _bindgen_ty_34 = 4 ; pub const SPDK_SPC_VERSION_SPC3 : _bindgen_ty_34 = 5 ; pub const SPDK_SPC_VERSION_SPC4 : _bindgen_ty_34 = 6 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_FC : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_PSCSI : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_SSA : _bindgen_ty_34 = 2 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_IEEE1394 : _bindgen_ty_34 = 3 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_RDMA : _bindgen_ty_34 = 4 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ISCSI : _bindgen_ty_34 = 5 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_SAS : _bindgen_ty_34 = 6 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ADT : _bindgen_ty_34 = 7 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ATA : _bindgen_ty_34 = 8 ; pub const SPDK_SPC_VPD_CODE_SET_BINARY : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_VPD_CODE_SET_ASCII : _bindgen_ty_34 = 2 ; pub const SPDK_SPC_VPD_CODE_SET_UTF8 : _bindgen_ty_34 = 3 ; pub const SPDK_SPC_VPD_ASSOCIATION_LOGICAL_UNIT : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_VPD_ASSOCIATION_TARGET_PORT : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_VPD_ASSOCIATION_TARGET_DEVICE : _bindgen_ty_34 = 2 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_VENDOR_SPECIFIC : _bindgen_ty_34 = 0 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_T10_VENDOR_ID : _bindgen_ty_34 = 1 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_EUI64 : _bindgen_ty_34 = 2 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_NAA : _bindgen_ty_34 = 3 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_RELATIVE_TARGET_PORT : _bindgen_ty_34 = 4 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_TARGET_PORT_GROUP : _bindgen_ty_34 = 5 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_LOGICAL_UNIT_GROUP : _bindgen_ty_34 = 6 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_MD5_LOGICAL_UNIT : _bindgen_ty_34 = 7 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_SCSI_NAME : _bindgen_ty_34 = 8 ; pub type _bindgen_ty_34 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_cdb_inquiry { pub opcode : u8 , pub evpd : u8 , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub control : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_cdb_inquiry_data { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub rmb : u8 , pub version : u8 , pub response : u8 , pub add_len : u8 , pub flags : u8 , pub flags2 : u8 , pub flags3 : u8 , pub t10_vendor_id : [ u8 ; 8usize ] , pub product_id : [ u8 ; 16usize ] , pub product_rev : [ u8 ; 4usize ] , pub vendor : [ u8 ; 20usize ] , pub ius : u8 , pub reserved : u8 , pub desc : __IncompleteArrayField < u8 > , } impl spdk_scsi_cdb_inquiry_data { # [ inline ] pub fn peripheral_device_type ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_device_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn peripheral_qualifier ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_qualifier ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( peripheral_device_type : u8 , peripheral_qualifier : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let peripheral_device_type : u8 = unsafe { :: std :: mem :: transmute ( peripheral_device_type ) } ; peripheral_device_type as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let peripheral_qualifier : u8 = unsafe { :: std :: mem :: transmute ( peripheral_qualifier ) } ; peripheral_qualifier as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_vpd_page { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub params : __IncompleteArrayField < u8 > , } impl spdk_scsi_vpd_page { # [ inline ] pub fn peripheral_device_type ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_device_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn peripheral_qualifier ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_qualifier ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( peripheral_device_type : u8 , peripheral_qualifier : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let peripheral_device_type : u8 = unsafe { :: std :: mem :: transmute ( peripheral_device_type ) } ; peripheral_device_type as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let peripheral_qualifier : u8 = unsafe { :: std :: mem :: transmute ( peripheral_qualifier ) } ; peripheral_qualifier as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_scsi_vpd_ext_inquiry { pub peripheral : u8 , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub check : u8 , pub sup : u8 , pub sup2 : u8 , pub luiclr : u8 , pub cbcs : u8 , pub micro_dl : u8 , pub reserved : [ u8 ; 54usize ] , } impl Default for spdk_scsi_vpd_ext_inquiry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_desig_desc { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub reserved1 : u8 , pub len : u8 , pub desig : __IncompleteArrayField < u8 > , } impl spdk_scsi_desig_desc { # [ inline ] pub fn code_set ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_code_set ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn protocol_id ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_protocol_id ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn association ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_association ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved0 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved0 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn piv ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_piv ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( code_set : u8 , protocol_id : u8 , type_ : u8 , association : u8 , reserved0 : u8 , piv : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let code_set : u8 = unsafe { :: std :: mem :: transmute ( code_set ) } ; code_set as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let protocol_id : u8 = unsafe { :: std :: mem :: transmute ( protocol_id ) } ; protocol_id as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let association : u8 = unsafe { :: std :: mem :: transmute ( association ) } ; association as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let reserved0 : u8 = unsafe { :: std :: mem :: transmute ( reserved0 ) } ; reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let piv : u8 = unsafe { :: std :: mem :: transmute ( piv ) } ; piv as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_mpage_policy_desc { pub page_code : u8 , pub sub_page_code : u8 , pub policy : u8 , pub reserved : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_tgt_port_desc { pub code_set : u8 , pub desig_type : u8 , pub reserved : u8 , pub len : u8 , pub designator : __IncompleteArrayField < u8 > , } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_port_desc { pub reserved : u16 , pub rel_port_id : u16 , pub reserved2 : u16 , pub init_port_len : u16 , pub init_port_id : u16 , pub reserved3 : u16 , pub tgt_desc_len : u16 , pub tgt_desc : __IncompleteArrayField < u8 > , } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_iscsi_transport_id { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub reserved2 : u8 , pub additional_len : u16 , pub name : __IncompleteArrayField < u8 > , } impl spdk_scsi_iscsi_transport_id { # [ inline ] pub fn protocol_id ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_protocol_id ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 2u8 , val as u64 ) } } # [ inline ] pub fn format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( protocol_id : u8 , reserved1 : u8 , format : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let protocol_id : u8 = unsafe { :: std :: mem :: transmute ( protocol_id ) } ; protocol_id as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 2u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let format : u8 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_unmap_bdesc { pub lba : u64 , pub block_count : u32 , pub reserved : u32 , } pub const spdk_scsi_pr_in_action_code_SPDK_SCSI_PR_IN_READ_KEYS : spdk_scsi_pr_in_action_code = 0 ; pub const spdk_scsi_pr_in_action_code_SPDK_SCSI_PR_IN_READ_RESERVATION : spdk_scsi_pr_in_action_code = 1 ; pub const spdk_scsi_pr_in_action_code_SPDK_SCSI_PR_IN_REPORT_CAPABILITIES : spdk_scsi_pr_in_action_code = 2 ; pub const spdk_scsi_pr_in_action_code_SPDK_SCSI_PR_IN_READ_FULL_STATUS : spdk_scsi_pr_in_action_code = 3 ; pub type spdk_scsi_pr_in_action_code = u32 ; pub const spdk_scsi_pr_scope_code_SPDK_SCSI_PR_LU_SCOPE : spdk_scsi_pr_scope_code = 0 ; pub type spdk_scsi_pr_scope_code = u32 ; pub const spdk_scsi_pr_type_code_SPDK_SCSI_PR_WRITE_EXCLUSIVE : spdk_scsi_pr_type_code = 1 ; pub const spdk_scsi_pr_type_code_SPDK_SCSI_PR_EXCLUSIVE_ACCESS : spdk_scsi_pr_type_code = 3 ; pub const spdk_scsi_pr_type_code_SPDK_SCSI_PR_WRITE_EXCLUSIVE_REGS_ONLY : spdk_scsi_pr_type_code = 5 ; pub const spdk_scsi_pr_type_code_SPDK_SCSI_PR_EXCLUSIVE_ACCESS_REGS_ONLY : spdk_scsi_pr_type_code = 6 ; pub const spdk_scsi_pr_type_code_SPDK_SCSI_PR_WRITE_EXCLUSIVE_ALL_REGS : spdk_scsi_pr_type_code = 7 ; pub const spdk_scsi_pr_type_code_SPDK_SCSI_PR_EXCLUSIVE_ACCESS_ALL_REGS : spdk_scsi_pr_type_code = 8 ; pub type spdk_scsi_pr_type_code = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_pr_in_read_header { pub pr_generation : u32 , pub addiontal_len : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_pr_in_read_keys_data { pub header : spdk_scsi_pr_in_read_header , pub rkeys : __IncompleteArrayField < u64 > , pub __bindgen_align : [ u64 ; 0usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_pr_in_read_reservations_data { pub header : spdk_scsi_pr_in_read_header , pub rkey : u64 , pub obsolete1 : u32 , pub reserved : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub obsolete2 : u16 , } impl spdk_scsi_pr_in_read_reservations_data { # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn scope ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_scope ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( type_ : u8 , scope : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let scope : u8 = unsafe { :: std :: mem :: transmute ( scope ) } ; scope as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_pr_in_report_capabilities_data { pub length : u16 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub reserved8 : [ u8 ; 2usize ] , } impl spdk_scsi_pr_in_report_capabilities_data { # [ inline ] pub fn ptpl_c ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ptpl_c ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn atp_c ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_atp_c ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sip_c ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_sip_c ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn crh ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_crh ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ptpl_a ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ptpl_a ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 6u8 , val as u64 ) } } # [ inline ] pub fn tmv ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_tmv ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wr_ex ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_wr_ex ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved5 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved5 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ex_ac ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ex_ac ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wr_ex_ro ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_wr_ex_ro ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ex_ac_ro ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ex_ac_ro ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wr_ex_ar ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 23usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_wr_ex_ar ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 23usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ex_ac_ar ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ex_ac_ar ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved7 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 25usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved7 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 25usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ptpl_c : u8 , reserved1 : u8 , atp_c : u8 , sip_c : u8 , crh : u8 , reserved2 : u8 , ptpl_a : u8 , reserved3 : u8 , tmv : u8 , reserved4 : u8 , wr_ex : u8 , reserved5 : u8 , ex_ac : u8 , reserved6 : u8 , wr_ex_ro : u8 , ex_ac_ro : u8 , wr_ex_ar : u8 , ex_ac_ar : u8 , reserved7 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ptpl_c : u8 = unsafe { :: std :: mem :: transmute ( ptpl_c ) } ; ptpl_c as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let atp_c : u8 = unsafe { :: std :: mem :: transmute ( atp_c ) } ; atp_c as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let sip_c : u8 = unsafe { :: std :: mem :: transmute ( sip_c ) } ; sip_c as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let crh : u8 = unsafe { :: std :: mem :: transmute ( crh ) } ; crh as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ptpl_a : u8 = unsafe { :: std :: mem :: transmute ( ptpl_a ) } ; ptpl_a as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 6u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let tmv : u8 = unsafe { :: std :: mem :: transmute ( tmv ) } ; tmv as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let wr_ex : u8 = unsafe { :: std :: mem :: transmute ( wr_ex ) } ; wr_ex as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let reserved5 : u8 = unsafe { :: std :: mem :: transmute ( reserved5 ) } ; reserved5 as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let ex_ac : u8 = unsafe { :: std :: mem :: transmute ( ex_ac ) } ; ex_ac as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let reserved6 : u8 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let wr_ex_ro : u8 = unsafe { :: std :: mem :: transmute ( wr_ex_ro ) } ; wr_ex_ro as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 1u8 , { let ex_ac_ro : u8 = unsafe { :: std :: mem :: transmute ( ex_ac_ro ) } ; ex_ac_ro as u64 } ) ; __bindgen_bitfield_unit . set ( 23usize , 1u8 , { let wr_ex_ar : u8 = unsafe { :: std :: mem :: transmute ( wr_ex_ar ) } ; wr_ex_ar as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 1u8 , { let ex_ac_ar : u8 = unsafe { :: std :: mem :: transmute ( ex_ac_ar ) } ; ex_ac_ar as u64 } ) ; __bindgen_bitfield_unit . set ( 25usize , 7u8 , { let reserved7 : u8 = unsafe { :: std :: mem :: transmute ( reserved7 ) } ; reserved7 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_pr_in_full_status_desc { pub rkey : u64 , pub reserved1 : [ u8 ; 4usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub reserved3 : [ u8 ; 4usize ] , pub relative_target_port_id : u16 , pub desc_len : u32 , pub transport_id : __IncompleteArrayField < u8 > , } impl spdk_scsi_pr_in_full_status_desc { # [ inline ] pub fn r_holder ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_r_holder ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn all_tg_pt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_all_tg_pt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn scope ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_scope ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( r_holder : u8 , all_tg_pt : u8 , reserved2 : u8 , type_ : u8 , scope : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let r_holder : u8 = unsafe { :: std :: mem :: transmute ( r_holder ) } ; r_holder as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let all_tg_pt : u8 = unsafe { :: std :: mem :: transmute ( all_tg_pt ) } ; all_tg_pt as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let scope : u8 = unsafe { :: std :: mem :: transmute ( scope ) } ; scope as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_pr_in_full_status_data { pub header : spdk_scsi_pr_in_read_header , pub desc_list : __IncompleteArrayField < spdk_scsi_pr_in_full_status_desc > , pub __bindgen_align : [ u64 ; 0usize ] , } pub const spdk_scsi_pr_out_service_action_code_SPDK_SCSI_PR_OUT_REGISTER : spdk_scsi_pr_out_service_action_code = 0 ; pub const spdk_scsi_pr_out_service_action_code_SPDK_SCSI_PR_OUT_RESERVE : spdk_scsi_pr_out_service_action_code = 1 ; pub const spdk_scsi_pr_out_service_action_code_SPDK_SCSI_PR_OUT_RELEASE : spdk_scsi_pr_out_service_action_code = 2 ; pub const spdk_scsi_pr_out_service_action_code_SPDK_SCSI_PR_OUT_CLEAR : spdk_scsi_pr_out_service_action_code = 3 ; pub const spdk_scsi_pr_out_service_action_code_SPDK_SCSI_PR_OUT_PREEMPT : spdk_scsi_pr_out_service_action_code = 4 ; pub const spdk_scsi_pr_out_service_action_code_SPDK_SCSI_PR_OUT_PREEMPT_AND_ABORT : spdk_scsi_pr_out_service_action_code = 5 ; pub const spdk_scsi_pr_out_service_action_code_SPDK_SCSI_PR_OUT_REG_AND_IGNORE_KEY : spdk_scsi_pr_out_service_action_code = 6 ; pub const spdk_scsi_pr_out_service_action_code_SPDK_SCSI_PR_OUT_REG_AND_MOVE : spdk_scsi_pr_out_service_action_code = 7 ; pub type spdk_scsi_pr_out_service_action_code = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_pr_out_param_list { pub rkey : u64 , pub sa_rkey : u64 , pub obsolete1 : [ u8 ; 4usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub reserved3 : u8 , pub obsolete2 : u16 , pub param_data : __IncompleteArrayField < u8 > , } impl spdk_scsi_pr_out_param_list { # [ inline ] pub fn aptpl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_aptpl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn all_tg_pt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_all_tg_pt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn spec_i_pt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_spec_i_pt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( aptpl : u8 , reserved1 : u8 , all_tg_pt : u8 , spec_i_pt : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let aptpl : u8 = unsafe { :: std :: mem :: transmute ( aptpl ) } ; aptpl as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let all_tg_pt : u8 = unsafe { :: std :: mem :: transmute ( all_tg_pt ) } ; all_tg_pt as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let spec_i_pt : u8 = unsafe { :: std :: mem :: transmute ( spec_i_pt ) } ; spec_i_pt as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_pr_out_reg_and_move_param_list { pub rkey : u64 , pub sa_rkey : u64 , pub reserved1 : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub relative_target_port_id : u16 , pub transport_id_len : u32 , pub transport_id : __IncompleteArrayField < u8 > , } impl spdk_scsi_pr_out_reg_and_move_param_list { # [ inline ] pub fn aptpl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_aptpl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn unreg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_unreg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( aptpl : u8 , unreg : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let aptpl : u8 = unsafe { :: std :: mem :: transmute ( aptpl ) } ; aptpl as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let unreg : u8 = unsafe { :: std :: mem :: transmute ( unreg ) } ; unreg as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cap_register { pub raw : u64 , pub bits : spdk_nvme_cap_register__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cap_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_cap_register__bindgen_ty_1 { # [ inline ] pub fn mqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_mqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn cqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ams ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_ams ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 5u8 , val as u64 ) } } # [ inline ] pub fn to ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_to ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn dstrd ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_dstrd ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 4u8 , val as u64 ) } } # [ inline ] pub fn nssrs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 36usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_nssrs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 36usize , 1u8 , val as u64 ) } } # [ inline ] pub fn css ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 37usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_css ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 37usize , 8u8 , val as u64 ) } } # [ inline ] pub fn bps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 45usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 45usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 46usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 46usize , 2u8 , val as u64 ) } } # [ inline ] pub fn mpsmin ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 48usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mpsmin ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 48usize , 4u8 , val as u64 ) } } # [ inline ] pub fn mpsmax ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 52usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mpsmax ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 52usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( mqes : u32 , cqr : u32 , ams : u32 , reserved1 : u32 , to : u32 , dstrd : u32 , nssrs : u32 , css : u32 , bps : u32 , reserved2 : u32 , mpsmin : u32 , mpsmax : u32 , reserved3 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let mqes : u32 = unsafe { :: std :: mem :: transmute ( mqes ) } ; mqes as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let cqr : u32 = unsafe { :: std :: mem :: transmute ( cqr ) } ; cqr as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 2u8 , { let ams : u32 = unsafe { :: std :: mem :: transmute ( ams ) } ; ams as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 5u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let to : u32 = unsafe { :: std :: mem :: transmute ( to ) } ; to as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 4u8 , { let dstrd : u32 = unsafe { :: std :: mem :: transmute ( dstrd ) } ; dstrd as u64 } ) ; __bindgen_bitfield_unit . set ( 36usize , 1u8 , { let nssrs : u32 = unsafe { :: std :: mem :: transmute ( nssrs ) } ; nssrs as u64 } ) ; __bindgen_bitfield_unit . set ( 37usize , 8u8 , { let css : u32 = unsafe { :: std :: mem :: transmute ( css ) } ; css as u64 } ) ; __bindgen_bitfield_unit . set ( 45usize , 1u8 , { let bps : u32 = unsafe { :: std :: mem :: transmute ( bps ) } ; bps as u64 } ) ; __bindgen_bitfield_unit . set ( 46usize , 2u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 48usize , 4u8 , { let mpsmin : u32 = unsafe { :: std :: mem :: transmute ( mpsmin ) } ; mpsmin as u64 } ) ; __bindgen_bitfield_unit . set ( 52usize , 4u8 , { let mpsmax : u32 = unsafe { :: std :: mem :: transmute ( mpsmax ) } ; mpsmax as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 8u8 , { let reserved3 : u32 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_cap_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_cc_css_SPDK_NVME_CC_CSS_NVM : spdk_nvme_cc_css = 0 ; pub type spdk_nvme_cc_css = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cc_register { pub raw : u32 , pub bits : spdk_nvme_cc_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cc_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_cc_register__bindgen_ty_1 { # [ inline ] pub fn en ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_en ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn css ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_css ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn mps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ams ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ams ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 3u8 , val as u64 ) } } # [ inline ] pub fn shn ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_shn ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn iosqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_iosqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn iocqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_iocqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( en : u32 , reserved1 : u32 , css : u32 , mps : u32 , ams : u32 , shn : u32 , iosqes : u32 , iocqes : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let en : u32 = unsafe { :: std :: mem :: transmute ( en ) } ; en as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let css : u32 = unsafe { :: std :: mem :: transmute ( css ) } ; css as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 4u8 , { let mps : u32 = unsafe { :: std :: mem :: transmute ( mps ) } ; mps as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 3u8 , { let ams : u32 = unsafe { :: std :: mem :: transmute ( ams ) } ; ams as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let shn : u32 = unsafe { :: std :: mem :: transmute ( shn ) } ; shn as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let iosqes : u32 = unsafe { :: std :: mem :: transmute ( iosqes ) } ; iosqes as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 4u8 , { let iocqes : u32 = unsafe { :: std :: mem :: transmute ( iocqes ) } ; iocqes as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_cc_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_shn_value_SPDK_NVME_SHN_NORMAL : spdk_nvme_shn_value = 1 ; pub const spdk_nvme_shn_value_SPDK_NVME_SHN_ABRUPT : spdk_nvme_shn_value = 2 ; pub type spdk_nvme_shn_value = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_csts_register { pub raw : u32 , pub bits : spdk_nvme_csts_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_csts_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_csts_register__bindgen_ty_1 { # [ inline ] pub fn rdy ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_rdy ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn cfs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cfs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn shst ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_shst ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn nssro ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_nssro ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_pp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( rdy : u32 , cfs : u32 , shst : u32 , nssro : u32 , pp : u32 , reserved1 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let rdy : u32 = unsafe { :: std :: mem :: transmute ( rdy ) } ; rdy as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let cfs : u32 = unsafe { :: std :: mem :: transmute ( cfs ) } ; cfs as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let shst : u32 = unsafe { :: std :: mem :: transmute ( shst ) } ; shst as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let nssro : u32 = unsafe { :: std :: mem :: transmute ( nssro ) } ; nssro as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let pp : u32 = unsafe { :: std :: mem :: transmute ( pp ) } ; pp as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_csts_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_shst_value_SPDK_NVME_SHST_NORMAL : spdk_nvme_shst_value = 0 ; pub const spdk_nvme_shst_value_SPDK_NVME_SHST_OCCURRING : spdk_nvme_shst_value = 1 ; pub const spdk_nvme_shst_value_SPDK_NVME_SHST_COMPLETE : spdk_nvme_shst_value = 2 ; pub type spdk_nvme_shst_value = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_aqa_register { pub raw : u32 , pub bits : spdk_nvme_aqa_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_aqa_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_aqa_register__bindgen_ty_1 { # [ inline ] pub fn asqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_asqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 12u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn acqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_acqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 12u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( asqs : u32 , reserved1 : u32 , acqs : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 12u8 , { let asqs : u32 = unsafe { :: std :: mem :: transmute ( asqs ) } ; asqs as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 12u8 , { let acqs : u32 = unsafe { :: std :: mem :: transmute ( acqs ) } ; acqs as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 4u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_aqa_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_vs_register { pub raw : u32 , pub bits : spdk_nvme_vs_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_vs_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_vs_register__bindgen_ty_1 { # [ inline ] pub fn ter ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_ter ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mnr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_mnr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mjr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_mjr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ter : u32 , mnr : u32 , mjr : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let ter : u32 = unsafe { :: std :: mem :: transmute ( ter ) } ; ter as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let mnr : u32 = unsafe { :: std :: mem :: transmute ( mnr ) } ; mnr as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let mjr : u32 = unsafe { :: std :: mem :: transmute ( mjr ) } ; mjr as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_vs_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmbloc_register { pub raw : u32 , pub bits : spdk_nvme_cmbloc_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmbloc_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_cmbloc_register__bindgen_ty_1 { # [ inline ] pub fn bir ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_bir ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 9u8 , val as u64 ) } } # [ inline ] pub fn ofst ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_ofst ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bir : u32 , reserved1 : u32 , ofst : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let bir : u32 = unsafe { :: std :: mem :: transmute ( bir ) } ; bir as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 9u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let ofst : u32 = unsafe { :: std :: mem :: transmute ( ofst ) } ; ofst as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_cmbloc_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmbsz_register { pub raw : u32 , pub bits : spdk_nvme_cmbsz_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmbsz_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_cmbsz_register__bindgen_ty_1 { # [ inline ] pub fn sqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn cqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lists ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_lists ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rds ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_rds ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wds ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wds ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn szu ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_szu ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn sz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_sz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( sqs : u32 , cqs : u32 , lists : u32 , rds : u32 , wds : u32 , reserved1 : u32 , szu : u32 , sz : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let sqs : u32 = unsafe { :: std :: mem :: transmute ( sqs ) } ; sqs as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let cqs : u32 = unsafe { :: std :: mem :: transmute ( cqs ) } ; cqs as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let lists : u32 = unsafe { :: std :: mem :: transmute ( lists ) } ; lists as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let rds : u32 = unsafe { :: std :: mem :: transmute ( rds ) } ; rds as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let wds : u32 = unsafe { :: std :: mem :: transmute ( wds ) } ; wds as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let szu : u32 = unsafe { :: std :: mem :: transmute ( szu ) } ; szu as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let sz : u32 = unsafe { :: std :: mem :: transmute ( sz ) } ; sz as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_cmbsz_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_bpinfo_register { pub raw : u32 , pub bits : spdk_nvme_bpinfo_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_bpinfo_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_bpinfo_register__bindgen_ty_1 { # [ inline ] pub fn bpsz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_bpsz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 15u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 9u8 , val as u64 ) } } # [ inline ] pub fn brs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_brs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 5u8 , val as u64 ) } } # [ inline ] pub fn abpid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_abpid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bpsz : u32 , reserved1 : u32 , brs : u32 , reserved2 : u32 , abpid : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 15u8 , { let bpsz : u32 = unsafe { :: std :: mem :: transmute ( bpsz ) } ; bpsz as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 9u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 2u8 , { let brs : u32 = unsafe { :: std :: mem :: transmute ( brs ) } ; brs as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 5u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let abpid : u32 = unsafe { :: std :: mem :: transmute ( abpid ) } ; abpid as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_bpinfo_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_bprsel_register { pub raw : u32 , pub bits : spdk_nvme_bprsel_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_bprsel_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_bprsel_register__bindgen_ty_1 { # [ inline ] pub fn bprsz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_bprsz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 10u8 , val as u64 ) } } # [ inline ] pub fn bprof ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_bprof ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 20u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn bpid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bpid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bprsz : u32 , bprof : u32 , reserved : u32 , bpid : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 10u8 , { let bprsz : u32 = unsafe { :: std :: mem :: transmute ( bprsz ) } ; bprsz as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 20u8 , { let bprof : u32 = unsafe { :: std :: mem :: transmute ( bprof ) } ; bprof as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let bpid : u32 = unsafe { :: std :: mem :: transmute ( bpid ) } ; bpid as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_bprsel_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_registers { pub cap : spdk_nvme_cap_register , pub vs : spdk_nvme_vs_register , pub intms : u32 , pub intmc : u32 , pub cc : spdk_nvme_cc_register , pub reserved1 : u32 , pub csts : spdk_nvme_csts_register , pub nssr : u32 , pub aqa : spdk_nvme_aqa_register , pub asq : u64 , pub acq : u64 , pub cmbloc : spdk_nvme_cmbloc_register , pub cmbsz : spdk_nvme_cmbsz_register , pub bpinfo : spdk_nvme_bpinfo_register , pub bprsel : spdk_nvme_bprsel_register , pub bpmbl : u64 , pub reserved3 : [ u32 ; 1004usize ] , pub doorbell : [ spdk_nvme_registers__bindgen_ty_1 ; 1usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_registers__bindgen_ty_1 { pub sq_tdbl : u32 , pub cq_hdbl : u32 , } impl Default for spdk_nvme_registers { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 0 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_BIT_BUCKET : spdk_nvme_sgl_descriptor_type = 1 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_SEGMENT : spdk_nvme_sgl_descriptor_type = 2 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_LAST_SEGMENT : spdk_nvme_sgl_descriptor_type = 3 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 4 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_TRANSPORT_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 5 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC : spdk_nvme_sgl_descriptor_type = 15 ; pub type spdk_nvme_sgl_descriptor_type = u32 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_ADDRESS : spdk_nvme_sgl_descriptor_subtype = 0 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_OFFSET : spdk_nvme_sgl_descriptor_subtype = 1 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_TRANSPORT : spdk_nvme_sgl_descriptor_subtype = 10 ; pub type spdk_nvme_sgl_descriptor_subtype = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor { pub address : u64 , pub __bindgen_anon_1 : spdk_nvme_sgl_descriptor__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_sgl_descriptor__bindgen_ty_1 { pub generic : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 , pub unkeyed : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 , pub keyed : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 { pub reserved : [ u8 ; 7usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn subtype ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( subtype : u8 , type_ : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let subtype : u8 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 { pub length : u32 , pub reserved : [ u8 ; 3usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 { # [ inline ] pub fn subtype ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( subtype : u8 , type_ : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let subtype : u8 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , pub __bindgen_align : [ u64 ; 0usize ] , } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 { # [ inline ] pub fn length ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 24u8 ) as u64 ) } } # [ inline ] pub fn set_length ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 24u8 , val as u64 ) } } # [ inline ] pub fn key ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 32u8 ) as u64 ) } } # [ inline ] pub fn set_key ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 32u8 , val as u64 ) } } # [ inline ] pub fn subtype ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 60usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_type ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 60usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( length : u64 , key : u64 , subtype : u64 , type_ : u64 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 24u8 , { let length : u64 = unsafe { :: std :: mem :: transmute ( length ) } ; length as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 32u8 , { let key : u64 = unsafe { :: std :: mem :: transmute ( key ) } ; key as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 4u8 , { let subtype : u64 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 60usize , 4u8 , { let type_ : u64 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_sgl_descriptor__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_sgl_descriptor { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_PRP : spdk_nvme_psdt_value = 0 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_CONTIG : spdk_nvme_psdt_value = 1 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_SGL : spdk_nvme_psdt_value = 2 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_RESERVED : spdk_nvme_psdt_value = 3 ; pub type spdk_nvme_psdt_value = u32 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_URGENT : spdk_nvme_qprio = 0 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_HIGH : spdk_nvme_qprio = 1 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_MEDIUM : spdk_nvme_qprio = 2 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_LOW : spdk_nvme_qprio = 3 ; pub type spdk_nvme_qprio = u32 ; pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_WRR : spdk_nvme_cap_ams = 1 ; pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_VS : spdk_nvme_cap_ams = 2 ; pub type spdk_nvme_cap_ams = u32 ; pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_RR : spdk_nvme_cc_ams = 0 ; pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_WRR : spdk_nvme_cc_ams = 1 ; pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_VS : spdk_nvme_cc_ams = 7 ; pub type spdk_nvme_cc_ams = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_cmd { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub cid : u16 , pub nsid : u32 , pub rsvd2 : u32 , pub rsvd3 : u32 , pub mptr : u64 , pub dptr : spdk_nvme_cmd__bindgen_ty_1 , pub cdw10 : u32 , pub cdw11 : u32 , pub cdw12 : u32 , pub cdw13 : u32 , pub cdw14 : u32 , pub cdw15 : u32 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmd__bindgen_ty_1 { pub prp : spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 , pub sgl1 : spdk_nvme_sgl_descriptor , _bindgen_union_align : [ u64 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 { pub prp1 : u64 , pub prp2 : u64 , } impl Default for spdk_nvme_cmd__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvme_cmd { # [ inline ] pub fn opc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_opc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn fuse ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_fuse ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn rsvd1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_rsvd1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 4u8 , val as u64 ) } } # [ inline ] pub fn psdt ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_psdt ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opc : u16 , fuse : u16 , rsvd1 : u16 , psdt : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let opc : u16 = unsafe { :: std :: mem :: transmute ( opc ) } ; opc as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let fuse : u16 = unsafe { :: std :: mem :: transmute ( fuse ) } ; fuse as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 4u8 , { let rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( rsvd1 ) } ; rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let psdt : u16 = unsafe { :: std :: mem :: transmute ( psdt ) } ; psdt as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_status { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_status { # [ inline ] pub fn p ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_p ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_sc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 8u8 , val as u64 ) } } # [ inline ] pub fn sct ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_sct ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rsvd2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_rsvd2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn m ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_m ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dnr ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_dnr ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( p : u16 , sc : u16 , sct : u16 , rsvd2 : u16 , m : u16 , dnr : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let p : u16 = unsafe { :: std :: mem :: transmute ( p ) } ; p as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 8u8 , { let sc : u16 = unsafe { :: std :: mem :: transmute ( sc ) } ; sc as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let sct : u16 = unsafe { :: std :: mem :: transmute ( sct ) } ; sct as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let rsvd2 : u16 = unsafe { :: std :: mem :: transmute ( rsvd2 ) } ; rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let m : u16 = unsafe { :: std :: mem :: transmute ( m ) } ; m as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let dnr : u16 = unsafe { :: std :: mem :: transmute ( dnr ) } ; dnr as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cpl { pub cdw0 : u32 , pub rsvd1 : u32 , pub sqhd : u16 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_dsm_range { pub attributes : spdk_nvme_dsm_range__bindgen_ty_1 , pub length : u32 , pub starting_lba : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_dsm_range__bindgen_ty_1 { pub bits : spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 , pub raw : u32 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn af ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_af ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn al ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_al ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved0 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved0 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn sr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 13u8 , val as u64 ) } } # [ inline ] pub fn access_size ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_access_size ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( af : u32 , al : u32 , reserved0 : u32 , sr : u32 , sw : u32 , wp : u32 , reserved1 : u32 , access_size : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let af : u32 = unsafe { :: std :: mem :: transmute ( af ) } ; af as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 2u8 , { let al : u32 = unsafe { :: std :: mem :: transmute ( al ) } ; al as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved0 : u32 = unsafe { :: std :: mem :: transmute ( reserved0 ) } ; reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let sr : u32 = unsafe { :: std :: mem :: transmute ( sr ) } ; sr as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let sw : u32 = unsafe { :: std :: mem :: transmute ( sw ) } ; sw as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let wp : u32 = unsafe { :: std :: mem :: transmute ( wp ) } ; wp as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 13u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let access_size : u32 = unsafe { :: std :: mem :: transmute ( access_size ) } ; access_size as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_dsm_range__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_dsm_range { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_GENERIC : spdk_nvme_status_code_type = 0 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_COMMAND_SPECIFIC : spdk_nvme_status_code_type = 1 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_MEDIA_ERROR : spdk_nvme_status_code_type = 2 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_PATH : spdk_nvme_status_code_type = 3 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_VENDOR_SPECIFIC : spdk_nvme_status_code_type = 7 ; pub type spdk_nvme_status_code_type = u32 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SUCCESS : spdk_nvme_generic_command_status_code = 0 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_OPCODE : spdk_nvme_generic_command_status_code = 1 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_FIELD : spdk_nvme_generic_command_status_code = 2 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_ID_CONFLICT : spdk_nvme_generic_command_status_code = 3 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_TRANSFER_ERROR : spdk_nvme_generic_command_status_code = 4 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_POWER_LOSS : spdk_nvme_generic_command_status_code = 5 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INTERNAL_DEVICE_ERROR : spdk_nvme_generic_command_status_code = 6 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_BY_REQUEST : spdk_nvme_generic_command_status_code = 7 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_SQ_DELETION : spdk_nvme_generic_command_status_code = 8 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_FAILED_FUSED : spdk_nvme_generic_command_status_code = 9 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_MISSING_FUSED : spdk_nvme_generic_command_status_code = 10 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT : spdk_nvme_generic_command_status_code = 11 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR : spdk_nvme_generic_command_status_code = 12 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR : spdk_nvme_generic_command_status_code = 13 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS : spdk_nvme_generic_command_status_code = 14 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID : spdk_nvme_generic_command_status_code = 15 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID : spdk_nvme_generic_command_status_code = 16 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID : spdk_nvme_generic_command_status_code = 17 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF : spdk_nvme_generic_command_status_code = 18 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_PRP_OFFSET : spdk_nvme_generic_command_status_code = 19 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED : spdk_nvme_generic_command_status_code = 20 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_OPERATION_DENIED : spdk_nvme_generic_command_status_code = 21 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_OFFSET : spdk_nvme_generic_command_status_code = 22 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT : spdk_nvme_generic_command_status_code = 24 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_EXPIRED : spdk_nvme_generic_command_status_code = 25 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_INVALID : spdk_nvme_generic_command_status_code = 26 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_PREEMPT : spdk_nvme_generic_command_status_code = 27 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_FAILED : spdk_nvme_generic_command_status_code = 28 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_IN_PROGRESS : spdk_nvme_generic_command_status_code = 29 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID : spdk_nvme_generic_command_status_code = 30 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_INVALID_IN_CMB : spdk_nvme_generic_command_status_code = 31 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_LBA_OUT_OF_RANGE : spdk_nvme_generic_command_status_code = 128 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_CAPACITY_EXCEEDED : spdk_nvme_generic_command_status_code = 129 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_NAMESPACE_NOT_READY : spdk_nvme_generic_command_status_code = 130 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_RESERVATION_CONFLICT : spdk_nvme_generic_command_status_code = 131 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_FORMAT_IN_PROGRESS : spdk_nvme_generic_command_status_code = 132 ; pub type spdk_nvme_generic_command_status_code = u32 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_COMPLETION_QUEUE_INVALID : spdk_nvme_command_specific_status_code = 0 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER : spdk_nvme_command_specific_status_code = 1 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED : spdk_nvme_command_specific_status_code = 2 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED : spdk_nvme_command_specific_status_code = 3 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED : spdk_nvme_command_specific_status_code = 5 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_SLOT : spdk_nvme_command_specific_status_code = 6 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE : spdk_nvme_command_specific_status_code = 7 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR : spdk_nvme_command_specific_status_code = 8 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_LOG_PAGE : spdk_nvme_command_specific_status_code = 9 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FORMAT : spdk_nvme_command_specific_status_code = 10 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET : spdk_nvme_command_specific_status_code = 11 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_DELETION : spdk_nvme_command_specific_status_code = 12 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE : spdk_nvme_command_specific_status_code = 13 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE : spdk_nvme_command_specific_status_code = 14 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC : spdk_nvme_command_specific_status_code = 15 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET : spdk_nvme_command_specific_status_code = 16 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_RESET : spdk_nvme_command_specific_status_code = 17 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION : spdk_nvme_command_specific_status_code = 18 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED : spdk_nvme_command_specific_status_code = 19 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_OVERLAPPING_RANGE : spdk_nvme_command_specific_status_code = 20 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY : spdk_nvme_command_specific_status_code = 21 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE : spdk_nvme_command_specific_status_code = 22 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED : spdk_nvme_command_specific_status_code = 24 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_IS_PRIVATE : spdk_nvme_command_specific_status_code = 25 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED : spdk_nvme_command_specific_status_code = 26 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED : spdk_nvme_command_specific_status_code = 27 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONTROLLER_LIST_INVALID : spdk_nvme_command_specific_status_code = 28 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_DEVICE_SELF_TEST_IN_PROGRESS : spdk_nvme_command_specific_status_code = 29 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_BOOT_PARTITION_WRITE_PROHIBITED : spdk_nvme_command_specific_status_code = 30 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_CTRLR_ID : spdk_nvme_command_specific_status_code = 31 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_SECONDARY_CTRLR_STATE : spdk_nvme_command_specific_status_code = 32 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_NUM_CTRLR_RESOURCES : spdk_nvme_command_specific_status_code = 33 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_RESOURCE_ID : spdk_nvme_command_specific_status_code = 34 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONFLICTING_ATTRIBUTES : spdk_nvme_command_specific_status_code = 128 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_PROTECTION_INFO : spdk_nvme_command_specific_status_code = 129 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE : spdk_nvme_command_specific_status_code = 130 ; pub type spdk_nvme_command_specific_status_code = u32 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_WRITE_FAULTS : spdk_nvme_media_error_status_code = 128 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_UNRECOVERED_READ_ERROR : spdk_nvme_media_error_status_code = 129 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_GUARD_CHECK_ERROR : spdk_nvme_media_error_status_code = 130 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR : spdk_nvme_media_error_status_code = 131 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR : spdk_nvme_media_error_status_code = 132 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_COMPARE_FAILURE : spdk_nvme_media_error_status_code = 133 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_ACCESS_DENIED : spdk_nvme_media_error_status_code = 134 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK : spdk_nvme_media_error_status_code = 135 ; pub type spdk_nvme_media_error_status_code = u32 ; pub const spdk_nvme_path_status_code_SPDK_NVME_SC_INTERNAL_PATH_ERROR : spdk_nvme_path_status_code = 0 ; pub const spdk_nvme_path_status_code_SPDK_NVME_SC_CONTROLLER_PATH_ERROR : spdk_nvme_path_status_code = 96 ; pub const spdk_nvme_path_status_code_SPDK_NVME_SC_HOST_PATH_ERROR : spdk_nvme_path_status_code = 112 ; pub const spdk_nvme_path_status_code_SPDK_NVME_SC_ABORTED_BY_HOST : spdk_nvme_path_status_code = 113 ; pub type spdk_nvme_path_status_code = u32 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_SQ : spdk_nvme_admin_opcode = 0 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_SQ : spdk_nvme_admin_opcode = 1 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_LOG_PAGE : spdk_nvme_admin_opcode = 2 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_CQ : spdk_nvme_admin_opcode = 4 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_CQ : spdk_nvme_admin_opcode = 5 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_IDENTIFY : spdk_nvme_admin_opcode = 6 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ABORT : spdk_nvme_admin_opcode = 8 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SET_FEATURES : spdk_nvme_admin_opcode = 9 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_FEATURES : spdk_nvme_admin_opcode = 10 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ASYNC_EVENT_REQUEST : spdk_nvme_admin_opcode = 12 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_MANAGEMENT : spdk_nvme_admin_opcode = 13 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_COMMIT : spdk_nvme_admin_opcode = 16 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD : spdk_nvme_admin_opcode = 17 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DEVICE_SELF_TEST : spdk_nvme_admin_opcode = 20 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_ATTACHMENT : spdk_nvme_admin_opcode = 21 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_KEEP_ALIVE : spdk_nvme_admin_opcode = 24 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_SEND : spdk_nvme_admin_opcode = 25 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_RECEIVE : spdk_nvme_admin_opcode = 26 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT : spdk_nvme_admin_opcode = 28 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_SEND : spdk_nvme_admin_opcode = 29 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_RECEIVE : spdk_nvme_admin_opcode = 30 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG : spdk_nvme_admin_opcode = 124 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FORMAT_NVM : spdk_nvme_admin_opcode = 128 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_SEND : spdk_nvme_admin_opcode = 129 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_RECEIVE : spdk_nvme_admin_opcode = 130 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SANITIZE : spdk_nvme_admin_opcode = 132 ; pub type spdk_nvme_admin_opcode = u32 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_FLUSH : spdk_nvme_nvm_opcode = 0 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE : spdk_nvme_nvm_opcode = 1 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_READ : spdk_nvme_nvm_opcode = 2 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_UNCORRECTABLE : spdk_nvme_nvm_opcode = 4 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_COMPARE : spdk_nvme_nvm_opcode = 5 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_ZEROES : spdk_nvme_nvm_opcode = 8 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_DATASET_MANAGEMENT : spdk_nvme_nvm_opcode = 9 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REGISTER : spdk_nvme_nvm_opcode = 13 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REPORT : spdk_nvme_nvm_opcode = 14 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_ACQUIRE : spdk_nvme_nvm_opcode = 17 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_RELEASE : spdk_nvme_nvm_opcode = 21 ; pub type spdk_nvme_nvm_opcode = u32 ; pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_NONE : spdk_nvme_data_transfer = 0 ; pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_HOST_TO_CONTROLLER : spdk_nvme_data_transfer = 1 ; pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_CONTROLLER_TO_HOST : spdk_nvme_data_transfer = 2 ; pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_BIDIRECTIONAL : spdk_nvme_data_transfer = 3 ; pub type spdk_nvme_data_transfer = u32 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ARBITRATION : spdk_nvme_feat = 1 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_POWER_MANAGEMENT : spdk_nvme_feat = 2 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_LBA_RANGE_TYPE : spdk_nvme_feat = 3 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD : spdk_nvme_feat = 4 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ERROR_RECOVERY : spdk_nvme_feat = 5 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE : spdk_nvme_feat = 6 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_NUMBER_OF_QUEUES : spdk_nvme_feat = 7 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_COALESCING : spdk_nvme_feat = 8 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION : spdk_nvme_feat = 9 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_WRITE_ATOMICITY : spdk_nvme_feat = 10 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION : spdk_nvme_feat = 11 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION : spdk_nvme_feat = 12 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_MEM_BUFFER : spdk_nvme_feat = 13 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_TIMESTAMP : spdk_nvme_feat = 14 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_KEEP_ALIVE_TIMER : spdk_nvme_feat = 15 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT : spdk_nvme_feat = 16 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG : spdk_nvme_feat = 17 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER : spdk_nvme_feat = 128 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_IDENTIFIER : spdk_nvme_feat = 129 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_MASK : spdk_nvme_feat = 130 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_PERSIST : spdk_nvme_feat = 131 ; pub type spdk_nvme_feat = u32 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_READ : spdk_nvme_dsm_attribute = 1 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE : spdk_nvme_dsm_attribute = 2 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_DEALLOCATE : spdk_nvme_dsm_attribute = 4 ; pub type spdk_nvme_dsm_attribute = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_power_state { pub mp : u16 , pub reserved1 : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub enlat : u32 , pub exlat : u32 , pub _bitfield_2 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub reserved7 : [ u8 ; 16usize ] , } impl spdk_nvme_power_state { # [ inline ] pub fn mps ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_mps ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nops ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_nops ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( mps : u8 , nops : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let mps : u8 = unsafe { :: std :: mem :: transmute ( mps ) } ; mps as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let nops : u8 = unsafe { :: std :: mem :: transmute ( nops ) } ; nops as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } # [ inline ] pub fn rrt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rrt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rrl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 8usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rrl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 8usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 13usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rwt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 16usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rwt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 16usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved5 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 21usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved5 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 21usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rwl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 24usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rwl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 24usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 29usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 29usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_2 ( rrt : u8 , reserved3 : u8 , rrl : u8 , reserved4 : u8 , rwt : u8 , reserved5 : u8 , rwl : u8 , reserved6 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let rrt : u8 = unsafe { :: std :: mem :: transmute ( rrt ) } ; rrt as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 5u8 , { let rrl : u8 = unsafe { :: std :: mem :: transmute ( rrl ) } ; rrl as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 5u8 , { let rwt : u8 = unsafe { :: std :: mem :: transmute ( rwt ) } ; rwt as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 3u8 , { let reserved5 : u8 = unsafe { :: std :: mem :: transmute ( reserved5 ) } ; reserved5 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 5u8 , { let rwl : u8 = unsafe { :: std :: mem :: transmute ( rwl ) } ; rwl as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 3u8 , { let reserved6 : u8 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit } } pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS : spdk_nvme_identify_cns = 0 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR : spdk_nvme_identify_cns = 1 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST : spdk_nvme_identify_cns = 2 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST : spdk_nvme_identify_cns = 3 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST : spdk_nvme_identify_cns = 16 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ALLOCATED : spdk_nvme_identify_cns = 17 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST : spdk_nvme_identify_cns = 18 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR_LIST : spdk_nvme_identify_cns = 19 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP : spdk_nvme_identify_cns = 20 ; pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST : spdk_nvme_identify_cns = 21 ; pub type spdk_nvme_identify_cns = u32 ; pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_DYNAMIC : spdk_nvmf_ctrlr_model = 0 ; pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_STATIC : spdk_nvmf_ctrlr_model = 1 ; pub type spdk_nvmf_ctrlr_model = u32 ; pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_NOT_SUPPORTED : spdk_nvme_sgls_supported = 0 ; pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED : spdk_nvme_sgls_supported = 1 ; pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED_DWORD_ALIGNED : spdk_nvme_sgls_supported = 2 ; pub type spdk_nvme_sgls_supported = u32 ; pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_NOT_INDICATED : spdk_nvme_flush_broadcast = 0 ; pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_NOT_SUPPORTED : spdk_nvme_flush_broadcast = 2 ; pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_SUPPORTED : spdk_nvme_flush_broadcast = 3 ; pub type spdk_nvme_flush_broadcast = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data { pub vid : u16 , pub ssvid : u16 , pub sn : [ i8 ; 20usize ] , pub mn : [ i8 ; 40usize ] , pub fr : [ u8 ; 8usize ] , pub rab : u8 , pub ieee : [ u8 ; 3usize ] , pub cmic : spdk_nvme_ctrlr_data__bindgen_ty_1 , pub mdts : u8 , pub cntlid : u16 , pub ver : spdk_nvme_vs_register , pub rtd3r : u32 , pub rtd3e : u32 , pub oaes : spdk_nvme_ctrlr_data__bindgen_ty_2 , pub ctratt : spdk_nvme_ctrlr_data__bindgen_ty_3 , pub reserved_100 : [ u8 ; 12usize ] , pub fguid : [ u8 ; 16usize ] , pub reserved_128 : [ u8 ; 128usize ] , pub oacs : spdk_nvme_ctrlr_data__bindgen_ty_4 , pub acl : u8 , pub aerl : u8 , pub frmw : spdk_nvme_ctrlr_data__bindgen_ty_5 , pub lpa : spdk_nvme_ctrlr_data__bindgen_ty_6 , pub elpe : u8 , pub npss : u8 , pub avscc : spdk_nvme_ctrlr_data__bindgen_ty_7 , pub apsta : spdk_nvme_ctrlr_data__bindgen_ty_8 , pub wctemp : u16 , pub cctemp : u16 , pub mtfa : u16 , pub hmpre : u32 , pub hmmin : u32 , pub tnvmcap : [ u64 ; 2usize ] , pub unvmcap : [ u64 ; 2usize ] , pub rpmbs : spdk_nvme_ctrlr_data__bindgen_ty_9 , pub edstt : u16 , pub dsto : spdk_nvme_ctrlr_data__bindgen_ty_10 , pub fwug : u8 , pub kas : u16 , pub hctma : spdk_nvme_ctrlr_data__bindgen_ty_11 , pub mntmt : u16 , pub mxtmt : u16 , pub sanicap : spdk_nvme_ctrlr_data__bindgen_ty_12 , pub reserved3 : [ u8 ; 180usize ] , pub sqes : spdk_nvme_ctrlr_data__bindgen_ty_13 , pub cqes : spdk_nvme_ctrlr_data__bindgen_ty_14 , pub maxcmd : u16 , pub nn : u32 , pub oncs : spdk_nvme_ctrlr_data__bindgen_ty_15 , pub fuses : u16 , pub fna : spdk_nvme_ctrlr_data__bindgen_ty_16 , pub vwc : spdk_nvme_ctrlr_data__bindgen_ty_17 , pub awun : u16 , pub awupf : u16 , pub nvscc : u8 , pub reserved531 : u8 , pub acwu : u16 , pub reserved534 : u16 , pub sgls : spdk_nvme_ctrlr_data__bindgen_ty_18 , pub reserved4 : [ u8 ; 228usize ] , pub subnqn : [ u8 ; 256usize ] , pub reserved5 : [ u8 ; 768usize ] , pub nvmf_specific : spdk_nvme_ctrlr_data__bindgen_ty_19 , pub psd : [ spdk_nvme_power_state ; 32usize ] , pub vs : [ u8 ; 1024usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_1 { # [ inline ] pub fn multi_port ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_multi_port ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn multi_host ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_multi_host ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sr_iov ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_sr_iov ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( multi_port : u8 , multi_host : u8 , sr_iov : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let multi_port : u8 = unsafe { :: std :: mem :: transmute ( multi_port ) } ; multi_port as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let multi_host : u8 = unsafe { :: std :: mem :: transmute ( multi_host ) } ; multi_host as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let sr_iov : u8 = unsafe { :: std :: mem :: transmute ( sr_iov ) } ; sr_iov as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_2 { # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn ns_attribute_notices ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ns_attribute_notices ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fw_activation_notices ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fw_activation_notices ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 22u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 22u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( reserved1 : u32 , ns_attribute_notices : u32 , fw_activation_notices : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ns_attribute_notices : u32 = unsafe { :: std :: mem :: transmute ( ns_attribute_notices ) } ; ns_attribute_notices as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let fw_activation_notices : u32 = unsafe { :: std :: mem :: transmute ( fw_activation_notices ) } ; fw_activation_notices as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 22u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_3 { # [ inline ] pub fn host_id_exhid_supported ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_host_id_exhid_supported ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn non_operational_power_state_permissive_mode ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_non_operational_power_state_permissive_mode ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( host_id_exhid_supported : u32 , non_operational_power_state_permissive_mode : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let host_id_exhid_supported : u32 = unsafe { :: std :: mem :: transmute ( host_id_exhid_supported ) } ; host_id_exhid_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let non_operational_power_state_permissive_mode : u32 = unsafe { :: std :: mem :: transmute ( non_operational_power_state_permissive_mode ) } ; non_operational_power_state_permissive_mode as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_4 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_4 { # [ inline ] pub fn security ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_security ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn format ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_format ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn firmware ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_firmware ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ns_manage ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ns_manage ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn device_self_test ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_device_self_test ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn directives ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_directives ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nvme_mi ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_nvme_mi ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn virtualization_management ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_virtualization_management ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn doorbell_buffer_config ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_doorbell_buffer_config ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn oacs_rsvd ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 7u8 ) as u16 ) } } # [ inline ] pub fn set_oacs_rsvd ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( security : u16 , format : u16 , firmware : u16 , ns_manage : u16 , device_self_test : u16 , directives : u16 , nvme_mi : u16 , virtualization_management : u16 , doorbell_buffer_config : u16 , oacs_rsvd : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let security : u16 = unsafe { :: std :: mem :: transmute ( security ) } ; security as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let format : u16 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let firmware : u16 = unsafe { :: std :: mem :: transmute ( firmware ) } ; firmware as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ns_manage : u16 = unsafe { :: std :: mem :: transmute ( ns_manage ) } ; ns_manage as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let device_self_test : u16 = unsafe { :: std :: mem :: transmute ( device_self_test ) } ; device_self_test as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let directives : u16 = unsafe { :: std :: mem :: transmute ( directives ) } ; directives as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let nvme_mi : u16 = unsafe { :: std :: mem :: transmute ( nvme_mi ) } ; nvme_mi as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let virtualization_management : u16 = unsafe { :: std :: mem :: transmute ( virtualization_management ) } ; virtualization_management as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let doorbell_buffer_config : u16 = unsafe { :: std :: mem :: transmute ( doorbell_buffer_config ) } ; doorbell_buffer_config as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 7u8 , { let oacs_rsvd : u16 = unsafe { :: std :: mem :: transmute ( oacs_rsvd ) } ; oacs_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_5 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_5 { # [ inline ] pub fn slot1_ro ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_slot1_ro ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn num_slots ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_num_slots ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn activation_without_reset ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_activation_without_reset ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn frmw_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_frmw_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( slot1_ro : u8 , num_slots : u8 , activation_without_reset : u8 , frmw_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let slot1_ro : u8 = unsafe { :: std :: mem :: transmute ( slot1_ro ) } ; slot1_ro as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let num_slots : u8 = unsafe { :: std :: mem :: transmute ( num_slots ) } ; num_slots as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let activation_without_reset : u8 = unsafe { :: std :: mem :: transmute ( activation_without_reset ) } ; activation_without_reset as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let frmw_rsvd : u8 = unsafe { :: std :: mem :: transmute ( frmw_rsvd ) } ; frmw_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_6 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_6 { # [ inline ] pub fn ns_smart ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ns_smart ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn celp ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_celp ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn edlp ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_edlp ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn telemetry ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_telemetry ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lpa_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_lpa_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ns_smart : u8 , celp : u8 , edlp : u8 , telemetry : u8 , lpa_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ns_smart : u8 = unsafe { :: std :: mem :: transmute ( ns_smart ) } ; ns_smart as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let celp : u8 = unsafe { :: std :: mem :: transmute ( celp ) } ; celp as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let edlp : u8 = unsafe { :: std :: mem :: transmute ( edlp ) } ; edlp as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let telemetry : u8 = unsafe { :: std :: mem :: transmute ( telemetry ) } ; telemetry as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let lpa_rsvd : u8 = unsafe { :: std :: mem :: transmute ( lpa_rsvd ) } ; lpa_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_7 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_7 { # [ inline ] pub fn spec_format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_spec_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn avscc_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_avscc_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( spec_format : u8 , avscc_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let spec_format : u8 = unsafe { :: std :: mem :: transmute ( spec_format ) } ; spec_format as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let avscc_rsvd : u8 = unsafe { :: std :: mem :: transmute ( avscc_rsvd ) } ; avscc_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_8 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_8 { # [ inline ] pub fn supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn apsta_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_apsta_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u8 , apsta_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let supported : u8 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let apsta_rsvd : u8 = unsafe { :: std :: mem :: transmute ( apsta_rsvd ) } ; apsta_rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_9 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub reserved2 : u8 , pub total_size : u8 , pub access_size : u8 , } impl spdk_nvme_ctrlr_data__bindgen_ty_9 { # [ inline ] pub fn num_rpmb_units ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_num_rpmb_units ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn auth_method ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_auth_method ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( num_rpmb_units : u8 , auth_method : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let num_rpmb_units : u8 = unsafe { :: std :: mem :: transmute ( num_rpmb_units ) } ; num_rpmb_units as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let auth_method : u8 = unsafe { :: std :: mem :: transmute ( auth_method ) } ; auth_method as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_10 { pub raw : u8 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 { # [ inline ] pub fn one_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_one_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( one_only : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let one_only : u8 = unsafe { :: std :: mem :: transmute ( one_only ) } ; one_only as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_10 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_11 { pub raw : u16 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 , _bindgen_union_align : u16 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 { # [ inline ] pub fn supported ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 15u8 ) as u16 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u16 , reserved : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let supported : u16 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 15u8 , { let reserved : u16 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_11 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_12 { pub raw : u32 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 { # [ inline ] pub fn crypto_erase ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_crypto_erase ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn block_erase ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_block_erase ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn overwrite ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_overwrite ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( crypto_erase : u32 , block_erase : u32 , overwrite : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let crypto_erase : u32 = unsafe { :: std :: mem :: transmute ( crypto_erase ) } ; crypto_erase as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let block_erase : u32 = unsafe { :: std :: mem :: transmute ( block_erase ) } ; block_erase as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let overwrite : u32 = unsafe { :: std :: mem :: transmute ( overwrite ) } ; overwrite as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_12 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_13 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_13 { # [ inline ] pub fn min ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_min ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn max ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_max ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( min : u8 , max : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let min : u8 = unsafe { :: std :: mem :: transmute ( min ) } ; min as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let max : u8 = unsafe { :: std :: mem :: transmute ( max ) } ; max as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_14 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_14 { # [ inline ] pub fn min ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_min ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn max ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_max ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( min : u8 , max : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let min : u8 = unsafe { :: std :: mem :: transmute ( min ) } ; min as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let max : u8 = unsafe { :: std :: mem :: transmute ( max ) } ; max as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_15 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_15 { # [ inline ] pub fn compare ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_compare ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_unc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_write_unc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dsm ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_dsm ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_zeroes ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_write_zeroes ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn set_features_save ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_set_features_save ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reservations ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_reservations ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn timestamp ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_timestamp ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( compare : u16 , write_unc : u16 , dsm : u16 , write_zeroes : u16 , set_features_save : u16 , reservations : u16 , timestamp : u16 , reserved : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let compare : u16 = unsafe { :: std :: mem :: transmute ( compare ) } ; compare as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let write_unc : u16 = unsafe { :: std :: mem :: transmute ( write_unc ) } ; write_unc as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dsm : u16 = unsafe { :: std :: mem :: transmute ( dsm ) } ; dsm as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_zeroes : u16 = unsafe { :: std :: mem :: transmute ( write_zeroes ) } ; write_zeroes as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let set_features_save : u16 = unsafe { :: std :: mem :: transmute ( set_features_save ) } ; set_features_save as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let reservations : u16 = unsafe { :: std :: mem :: transmute ( reservations ) } ; reservations as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let timestamp : u16 = unsafe { :: std :: mem :: transmute ( timestamp ) } ; timestamp as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let reserved : u16 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_16 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_16 { # [ inline ] pub fn format_all_ns ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_format_all_ns ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn erase_all_ns ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_erase_all_ns ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn crypto_erase_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_crypto_erase_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( format_all_ns : u8 , erase_all_ns : u8 , crypto_erase_supported : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let format_all_ns : u8 = unsafe { :: std :: mem :: transmute ( format_all_ns ) } ; format_all_ns as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let erase_all_ns : u8 = unsafe { :: std :: mem :: transmute ( erase_all_ns ) } ; erase_all_ns as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let crypto_erase_supported : u8 = unsafe { :: std :: mem :: transmute ( crypto_erase_supported ) } ; crypto_erase_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_17 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_17 { # [ inline ] pub fn present ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_present ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn flush_broadcast ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_flush_broadcast ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( present : u8 , flush_broadcast : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let present : u8 = unsafe { :: std :: mem :: transmute ( present ) } ; present as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 2u8 , { let flush_broadcast : u8 = unsafe { :: std :: mem :: transmute ( flush_broadcast ) } ; flush_broadcast as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_18 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ctrlr_data__bindgen_ty_18 { # [ inline ] pub fn supported ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn keyed_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_keyed_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 13u8 , val as u64 ) } } # [ inline ] pub fn bit_bucket_descriptor ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bit_bucket_descriptor ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn metadata_pointer ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_metadata_pointer ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn oversized_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_oversized_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn metadata_address ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_metadata_address ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sgl_offset ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sgl_offset ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn transport_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_transport_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u32 , keyed_sgl : u32 , reserved1 : u32 , bit_bucket_descriptor : u32 , metadata_pointer : u32 , oversized_sgl : u32 , metadata_address : u32 , sgl_offset : u32 , transport_sgl : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let supported : u32 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let keyed_sgl : u32 = unsafe { :: std :: mem :: transmute ( keyed_sgl ) } ; keyed_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 13u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let bit_bucket_descriptor : u32 = unsafe { :: std :: mem :: transmute ( bit_bucket_descriptor ) } ; bit_bucket_descriptor as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let metadata_pointer : u32 = unsafe { :: std :: mem :: transmute ( metadata_pointer ) } ; metadata_pointer as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let oversized_sgl : u32 = unsafe { :: std :: mem :: transmute ( oversized_sgl ) } ; oversized_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let metadata_address : u32 = unsafe { :: std :: mem :: transmute ( metadata_address ) } ; metadata_address as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let sgl_offset : u32 = unsafe { :: std :: mem :: transmute ( sgl_offset ) } ; sgl_offset as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 1u8 , { let transport_sgl : u32 = unsafe { :: std :: mem :: transmute ( transport_sgl ) } ; transport_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 10u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_19 { pub ioccsz : u32 , pub iorcsz : u32 , pub icdoff : u16 , pub ctrattr : spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 , pub msdbd : u8 , pub reserved : [ u8 ; 244usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 { # [ inline ] pub fn ctrlr_model ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ctrlr_model ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ctrlr_model : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ctrlr_model : u8 = unsafe { :: std :: mem :: transmute ( ctrlr_model ) } ; ctrlr_model as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_19 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_ctrlr_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_primary_ctrl_capabilities { pub cntlid : u16 , pub portid : u16 , pub crt : spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 , pub reserved : [ u8 ; 27usize ] , pub vqfrt : u32 , pub vqrfa : u32 , pub vqrfap : u16 , pub vqprt : u16 , pub vqfrsm : u16 , pub vqgran : u16 , pub reserved1 : [ u8 ; 16usize ] , pub vifrt : u32 , pub virfa : u32 , pub virfap : u16 , pub viprt : u16 , pub vifrsm : u16 , pub vigran : u16 , pub reserved2 : [ u8 ; 4016usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 { # [ inline ] pub fn vq_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_vq_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn vi_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_vi_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( vq_supported : u8 , vi_supported : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let vq_supported : u8 = unsafe { :: std :: mem :: transmute ( vq_supported ) } ; vq_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let vi_supported : u8 = unsafe { :: std :: mem :: transmute ( vi_supported ) } ; vi_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_primary_ctrl_capabilities { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_entry { pub scid : u16 , pub pcid : u16 , pub scs : spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 , pub reserved : [ u8 ; 3usize ] , pub vfn : u16 , pub nvq : u16 , pub nvi : u16 , pub reserved1 : [ u8 ; 18usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 { # [ inline ] pub fn is_online ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_is_online ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( is_online : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let is_online : u8 = unsafe { :: std :: mem :: transmute ( is_online ) } ; is_online as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_list { pub number : u8 , pub reserved : [ u8 ; 31usize ] , pub entries : [ spdk_nvme_secondary_ctrl_entry ; 127usize ] , } impl Default for spdk_nvme_secondary_ctrl_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ns_data { pub nsze : u64 , pub ncap : u64 , pub nuse : u64 , pub nsfeat : spdk_nvme_ns_data__bindgen_ty_1 , pub nlbaf : u8 , pub flbas : spdk_nvme_ns_data__bindgen_ty_2 , pub mc : spdk_nvme_ns_data__bindgen_ty_3 , pub dpc : spdk_nvme_ns_data__bindgen_ty_4 , pub dps : spdk_nvme_ns_data__bindgen_ty_5 , pub nmic : spdk_nvme_ns_data__bindgen_ty_6 , pub nsrescap : spdk_nvme_ns_data__bindgen_ty_7 , pub fpi : spdk_nvme_ns_data__bindgen_ty_8 , pub dlfeat : spdk_nvme_ns_data__bindgen_ty_9 , pub nawun : u16 , pub nawupf : u16 , pub nacwu : u16 , pub nabsn : u16 , pub nabo : u16 , pub nabspf : u16 , pub noiob : u16 , pub nvmcap : [ u64 ; 2usize ] , pub reserved64 : [ u8 ; 40usize ] , pub nguid : [ u8 ; 16usize ] , pub eui64 : u64 , pub lbaf : [ spdk_nvme_ns_data__bindgen_ty_10 ; 16usize ] , pub reserved6 : [ u8 ; 192usize ] , pub vendor_specific : [ u8 ; 3712usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_1 { # [ inline ] pub fn thin_prov ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_thin_prov ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ns_atomic_write_unit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ns_atomic_write_unit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dealloc_or_unwritten_error ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_dealloc_or_unwritten_error ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn guid_never_reused ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_guid_never_reused ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( thin_prov : u8 , ns_atomic_write_unit : u8 , dealloc_or_unwritten_error : u8 , guid_never_reused : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let thin_prov : u8 = unsafe { :: std :: mem :: transmute ( thin_prov ) } ; thin_prov as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ns_atomic_write_unit : u8 = unsafe { :: std :: mem :: transmute ( ns_atomic_write_unit ) } ; ns_atomic_write_unit as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dealloc_or_unwritten_error : u8 = unsafe { :: std :: mem :: transmute ( dealloc_or_unwritten_error ) } ; dealloc_or_unwritten_error as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let guid_never_reused : u8 = unsafe { :: std :: mem :: transmute ( guid_never_reused ) } ; guid_never_reused as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_2 { # [ inline ] pub fn format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn extended ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_extended ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( format : u8 , extended : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let format : u8 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let extended : u8 = unsafe { :: std :: mem :: transmute ( extended ) } ; extended as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_3 { # [ inline ] pub fn extended ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_extended ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pointer ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pointer ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( extended : u8 , pointer : u8 , reserved3 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let extended : u8 = unsafe { :: std :: mem :: transmute ( extended ) } ; extended as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let pointer : u8 = unsafe { :: std :: mem :: transmute ( pointer ) } ; pointer as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_4 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_4 { # [ inline ] pub fn pit1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pit2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pit3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn md_start ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_start ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn md_end ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_end ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pit1 : u8 , pit2 : u8 , pit3 : u8 , md_start : u8 , md_end : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let pit1 : u8 = unsafe { :: std :: mem :: transmute ( pit1 ) } ; pit1 as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let pit2 : u8 = unsafe { :: std :: mem :: transmute ( pit2 ) } ; pit2 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let pit3 : u8 = unsafe { :: std :: mem :: transmute ( pit3 ) } ; pit3 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let md_start : u8 = unsafe { :: std :: mem :: transmute ( md_start ) } ; md_start as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let md_end : u8 = unsafe { :: std :: mem :: transmute ( md_end ) } ; md_end as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_5 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_5 { # [ inline ] pub fn pit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_pit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn md_start ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_start ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pit : u8 , md_start : u8 , reserved4 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let pit : u8 = unsafe { :: std :: mem :: transmute ( pit ) } ; pit as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let md_start : u8 = unsafe { :: std :: mem :: transmute ( md_start ) } ; md_start as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_6 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_6 { # [ inline ] pub fn can_share ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_can_share ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( can_share : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let can_share : u8 = unsafe { :: std :: mem :: transmute ( can_share ) } ; can_share as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ns_data__bindgen_ty_7 { pub rescap : spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 , pub raw : u8 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 { # [ inline ] pub fn persist ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_persist ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive_reg_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive_reg_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access_reg_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access_reg_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive_all_reg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive_all_reg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access_all_reg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access_all_reg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ignore_existing_key ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ignore_existing_key ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( persist : u8 , write_exclusive : u8 , exclusive_access : u8 , write_exclusive_reg_only : u8 , exclusive_access_reg_only : u8 , write_exclusive_all_reg : u8 , exclusive_access_all_reg : u8 , ignore_existing_key : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let persist : u8 = unsafe { :: std :: mem :: transmute ( persist ) } ; persist as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let write_exclusive : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive ) } ; write_exclusive as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let exclusive_access : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access ) } ; exclusive_access as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_exclusive_reg_only : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive_reg_only ) } ; write_exclusive_reg_only as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let exclusive_access_reg_only : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access_reg_only ) } ; exclusive_access_reg_only as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let write_exclusive_all_reg : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive_all_reg ) } ; write_exclusive_all_reg as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let exclusive_access_all_reg : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access_all_reg ) } ; exclusive_access_all_reg as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ignore_existing_key : u8 = unsafe { :: std :: mem :: transmute ( ignore_existing_key ) } ; ignore_existing_key as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ns_data__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_8 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_8 { # [ inline ] pub fn percentage_remaining ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_percentage_remaining ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn fpi_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_fpi_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( percentage_remaining : u8 , fpi_supported : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let percentage_remaining : u8 = unsafe { :: std :: mem :: transmute ( percentage_remaining ) } ; percentage_remaining as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let fpi_supported : u8 = unsafe { :: std :: mem :: transmute ( fpi_supported ) } ; fpi_supported as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ns_data__bindgen_ty_9 { pub raw : u8 , pub bits : spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 { # [ inline ] pub fn read_value ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_read_value ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn write_zero_deallocate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_zero_deallocate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn guard_value ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_guard_value ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( read_value : u8 , write_zero_deallocate : u8 , guard_value : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let read_value : u8 = unsafe { :: std :: mem :: transmute ( read_value ) } ; read_value as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_zero_deallocate : u8 = unsafe { :: std :: mem :: transmute ( write_zero_deallocate ) } ; write_zero_deallocate as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let guard_value : u8 = unsafe { :: std :: mem :: transmute ( guard_value ) } ; guard_value as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ns_data__bindgen_ty_9 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_10 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_ns_data__bindgen_ty_10 { # [ inline ] pub fn ms ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ms ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn lbads ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_lbads ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn rp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_rp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ms : u32 , lbads : u32 , rp : u32 , reserved6 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let ms : u32 = unsafe { :: std :: mem :: transmute ( ms ) } ; ms as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let lbads : u32 = unsafe { :: std :: mem :: transmute ( lbads ) } ; lbads as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 2u8 , { let rp : u32 = unsafe { :: std :: mem :: transmute ( rp ) } ; rp as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 6u8 , { let reserved6 : u32 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_ns_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_NOT_REPORTED : spdk_nvme_dealloc_logical_block_read_value = 0 ; pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_00 : spdk_nvme_dealloc_logical_block_read_value = 1 ; pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_FF : spdk_nvme_dealloc_logical_block_read_value = 2 ; pub type spdk_nvme_dealloc_logical_block_read_value = u32 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE : spdk_nvme_reservation_type = 1 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS : spdk_nvme_reservation_type = 2 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY : spdk_nvme_reservation_type = 3 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY : spdk_nvme_reservation_type = 4 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS : spdk_nvme_reservation_type = 5 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS : spdk_nvme_reservation_type = 6 ; pub type spdk_nvme_reservation_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_acquire_data { pub crkey : u64 , pub prkey : u64 , } pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_ACQUIRE : spdk_nvme_reservation_acquire_action = 0 ; pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT : spdk_nvme_reservation_acquire_action = 1 ; pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT_ABORT : spdk_nvme_reservation_acquire_action = 2 ; pub type spdk_nvme_reservation_acquire_action = u32 ; # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_status_data { pub gen : u32 , pub rtype : u8 , pub regctl : u16 , pub reserved1 : u16 , pub ptpls : u8 , pub reserved : [ u8 ; 14usize ] , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_reservation_status_extended_data { pub data : spdk_nvme_reservation_status_data , pub reserved : [ u8 ; 40usize ] , } impl Default for spdk_nvme_reservation_status_extended_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_registered_ctrlr_data { pub cntlid : u16 , pub rcsts : spdk_nvme_registered_ctrlr_data__bindgen_ty_1 , pub reserved2 : [ u8 ; 5usize ] , pub hostid : u64 , pub rkey : u64 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_registered_ctrlr_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_registered_ctrlr_data__bindgen_ty_1 { # [ inline ] pub fn status ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_status ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( status : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let status : u8 = unsafe { :: std :: mem :: transmute ( status ) } ; status as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_registered_ctrlr_extended_data { pub cntlid : u16 , pub rcsts : spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1 , pub reserved2 : [ u8 ; 5usize ] , pub rkey : u64 , pub hostid : [ u8 ; 16usize ] , pub reserved3 : [ u8 ; 32usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1 { # [ inline ] pub fn status ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_status ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( status : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let status : u8 = unsafe { :: std :: mem :: transmute ( status ) } ; status as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_NO_CHANGES : spdk_nvme_reservation_register_cptpl = 0 ; pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON : spdk_nvme_reservation_register_cptpl = 2 ; pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS : spdk_nvme_reservation_register_cptpl = 3 ; pub type spdk_nvme_reservation_register_cptpl = u32 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REGISTER_KEY : spdk_nvme_reservation_register_action = 0 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_UNREGISTER_KEY : spdk_nvme_reservation_register_action = 1 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REPLACE_KEY : spdk_nvme_reservation_register_action = 2 ; pub type spdk_nvme_reservation_register_action = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_register_data { pub crkey : u64 , pub nrkey : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_key_data { pub crkey : u64 , } pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_RELEASE : spdk_nvme_reservation_release_action = 0 ; pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_CLEAR : spdk_nvme_reservation_release_action = 1 ; pub type spdk_nvme_reservation_release_action = u32 ; pub const spdk_nvme_reservation_notification_log_page_type_SPDK_NVME_RESERVATION_LOG_PAGE_EMPTY : spdk_nvme_reservation_notification_log_page_type = 0 ; pub const spdk_nvme_reservation_notification_log_page_type_SPDK_NVME_REGISTRATION_PREEMPTED : spdk_nvme_reservation_notification_log_page_type = 1 ; pub const spdk_nvme_reservation_notification_log_page_type_SPDK_NVME_RESERVATION_RELEASED : spdk_nvme_reservation_notification_log_page_type = 2 ; pub const spdk_nvme_reservation_notification_log_page_type_SPDK_NVME_RESERVATION_PREEMPTED : spdk_nvme_reservation_notification_log_page_type = 3 ; pub type spdk_nvme_reservation_notification_log_page_type = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_reservation_notification_log { pub log_page_count : u64 , pub type_ : u8 , pub num_avail_log_pages : u8 , pub reserved : [ u8 ; 2usize ] , pub nsid : u32 , pub reserved1 : [ u8 ; 48usize ] , } impl Default for spdk_nvme_reservation_notification_log { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_log_page_SPDK_NVME_LOG_ERROR : spdk_nvme_log_page = 1 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_HEALTH_INFORMATION : spdk_nvme_log_page = 2 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_FIRMWARE_SLOT : spdk_nvme_log_page = 3 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_CHANGED_NS_LIST : spdk_nvme_log_page = 4 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_COMMAND_EFFECTS_LOG : spdk_nvme_log_page = 5 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_DISCOVERY : spdk_nvme_log_page = 112 ; pub const spdk_nvme_log_page_SPDK_NVME_LOG_RESERVATION_NOTIFICATION : spdk_nvme_log_page = 128 ; pub type spdk_nvme_log_page = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_error_information_entry { pub error_count : u64 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , pub error_location : u16 , pub lba : u64 , pub nsid : u32 , pub vendor_specific : u8 , pub trtype : u8 , pub reserved30 : [ u8 ; 2usize ] , pub command_specific : u64 , pub trtype_specific : u16 , pub reserved42 : [ u8 ; 22usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_critical_warning_state { pub raw : u8 , pub bits : spdk_nvme_critical_warning_state__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_critical_warning_state__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_critical_warning_state__bindgen_ty_1 { # [ inline ] pub fn available_spare ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_available_spare ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn temperature ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_temperature ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn device_reliability ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_device_reliability ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn read_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_read_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn volatile_memory_backup ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_volatile_memory_backup ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( available_spare : u8 , temperature : u8 , device_reliability : u8 , read_only : u8 , volatile_memory_backup : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let available_spare : u8 = unsafe { :: std :: mem :: transmute ( available_spare ) } ; available_spare as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let temperature : u8 = unsafe { :: std :: mem :: transmute ( temperature ) } ; temperature as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let device_reliability : u8 = unsafe { :: std :: mem :: transmute ( device_reliability ) } ; device_reliability as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let read_only : u8 = unsafe { :: std :: mem :: transmute ( read_only ) } ; read_only as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let volatile_memory_backup : u8 = unsafe { :: std :: mem :: transmute ( volatile_memory_backup ) } ; volatile_memory_backup as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_critical_warning_state { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_health_information_page { pub critical_warning : spdk_nvme_critical_warning_state , pub temperature : u16 , pub available_spare : u8 , pub available_spare_threshold : u8 , pub percentage_used : u8 , pub reserved : [ u8 ; 26usize ] , pub data_units_read : [ u64 ; 2usize ] , pub data_units_written : [ u64 ; 2usize ] , pub host_read_commands : [ u64 ; 2usize ] , pub host_write_commands : [ u64 ; 2usize ] , pub controller_busy_time : [ u64 ; 2usize ] , pub power_cycles : [ u64 ; 2usize ] , pub power_on_hours : [ u64 ; 2usize ] , pub unsafe_shutdowns : [ u64 ; 2usize ] , pub media_errors : [ u64 ; 2usize ] , pub num_error_info_log_entries : [ u64 ; 2usize ] , pub warning_temp_time : u32 , pub critical_temp_time : u32 , pub temp_sensor : [ u16 ; 8usize ] , pub reserved2 : [ u8 ; 296usize ] , } impl Default for spdk_nvme_health_information_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmds_and_effect_entry { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } impl spdk_nvme_cmds_and_effect_entry { # [ inline ] pub fn csupp ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_csupp ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lbcc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_lbcc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ncc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ncc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nic ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_nic ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ccc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ccc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn cse ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_cse ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 13u8 ) as u16 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 13u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( csupp : u16 , lbcc : u16 , ncc : u16 , nic : u16 , ccc : u16 , reserved1 : u16 , cse : u16 , reserved2 : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let csupp : u16 = unsafe { :: std :: mem :: transmute ( csupp ) } ; csupp as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let lbcc : u16 = unsafe { :: std :: mem :: transmute ( lbcc ) } ; lbcc as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ncc : u16 = unsafe { :: std :: mem :: transmute ( ncc ) } ; ncc as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let nic : u16 = unsafe { :: std :: mem :: transmute ( nic ) } ; nic as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ccc : u16 = unsafe { :: std :: mem :: transmute ( ccc ) } ; ccc as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let reserved1 : u16 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 3u8 , { let cse : u16 = unsafe { :: std :: mem :: transmute ( cse ) } ; cse as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 13u8 , { let reserved2 : u16 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_cmds_and_effect_log_page { pub admin_cmds_supported : [ spdk_nvme_cmds_and_effect_entry ; 256usize ] , pub io_cmds_supported : [ spdk_nvme_cmds_and_effect_entry ; 256usize ] , pub reserved0 : [ u8 ; 2048usize ] , } impl Default for spdk_nvme_cmds_and_effect_log_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_ERROR : spdk_nvme_async_event_type = 0 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_SMART : spdk_nvme_async_event_type = 1 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE : spdk_nvme_async_event_type = 2 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_IO : spdk_nvme_async_event_type = 6 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_VENDOR : spdk_nvme_async_event_type = 7 ; pub type spdk_nvme_async_event_type = u32 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_WRITE_INVALID_DB : spdk_nvme_async_event_info_error = 0 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_INVALID_DB_WRITE : spdk_nvme_async_event_info_error = 1 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_DIAGNOSTIC_FAILURE : spdk_nvme_async_event_info_error = 2 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_PERSISTENT_INTERNAL : spdk_nvme_async_event_info_error = 3 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_TRANSIENT_INTERNAL : spdk_nvme_async_event_info_error = 4 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_FW_IMAGE_LOAD : spdk_nvme_async_event_info_error = 5 ; pub type spdk_nvme_async_event_info_error = u32 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SUBSYSTEM_RELIABILITY : spdk_nvme_async_event_info_smart = 0 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_TEMPERATURE_THRESHOLD : spdk_nvme_async_event_info_smart = 1 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SPARE_BELOW_THRESHOLD : spdk_nvme_async_event_info_smart = 2 ; pub type spdk_nvme_async_event_info_smart = u32 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED : spdk_nvme_async_event_info_notice = 0 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_FW_ACTIVATION_START : spdk_nvme_async_event_info_notice = 1 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_TELEMETRY_LOG_CHANGED : spdk_nvme_async_event_info_notice = 2 ; pub type spdk_nvme_async_event_info_notice = u32 ; pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_RESERVATION_LOG_AVAIL : spdk_nvme_async_event_info_nvm_command_set = 0 ; pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_SANITIZE_COMPLETED : spdk_nvme_async_event_info_nvm_command_set = 1 ; pub type spdk_nvme_async_event_info_nvm_command_set = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_async_event_completion { pub raw : u32 , pub bits : spdk_nvme_async_event_completion__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_async_event_completion__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_async_event_completion__bindgen_ty_1 { # [ inline ] pub fn async_event_type ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_async_event_type ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn async_event_info ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_async_event_info ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn log_page_identifier ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_log_page_identifier ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( async_event_type : u32 , reserved1 : u32 , async_event_info : u32 , log_page_identifier : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let async_event_type : u32 = unsafe { :: std :: mem :: transmute ( async_event_type ) } ; async_event_type as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let async_event_info : u32 = unsafe { :: std :: mem :: transmute ( async_event_info ) } ; async_event_info as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let log_page_identifier : u32 = unsafe { :: std :: mem :: transmute ( log_page_identifier ) } ; log_page_identifier as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_async_event_completion { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_arbitration { pub raw : u32 , pub bits : spdk_nvme_feat_arbitration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_arbitration__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_arbitration__bindgen_ty_1 { # [ inline ] pub fn ab ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ab ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn lpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_lpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_mpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn hpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_hpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ab : u32 , reserved : u32 , lpw : u32 , mpw : u32 , hpw : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let ab : u32 = unsafe { :: std :: mem :: transmute ( ab ) } ; ab as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let lpw : u32 = unsafe { :: std :: mem :: transmute ( lpw ) } ; lpw as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let mpw : u32 = unsafe { :: std :: mem :: transmute ( mpw ) } ; mpw as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let hpw : u32 = unsafe { :: std :: mem :: transmute ( hpw ) } ; hpw as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_arbitration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_power_management { pub raw : u32 , pub bits : spdk_nvme_feat_power_management__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_power_management__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_power_management__bindgen_ty_1 { # [ inline ] pub fn ps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_ps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn wh ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_wh ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ps : u32 , wh : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let ps : u32 = unsafe { :: std :: mem :: transmute ( ps ) } ; ps as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let wh : u32 = unsafe { :: std :: mem :: transmute ( wh ) } ; wh as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_power_management { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_lba_range_type { pub raw : u32 , pub bits : spdk_nvme_feat_lba_range_type__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_lba_range_type__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_lba_range_type__bindgen_ty_1 { # [ inline ] pub fn num ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_num ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( num : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let num : u32 = unsafe { :: std :: mem :: transmute ( num ) } ; num as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_lba_range_type { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_temperature_threshold { pub raw : u32 , pub bits : spdk_nvme_feat_temperature_threshold__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_temperature_threshold__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_temperature_threshold__bindgen_ty_1 { # [ inline ] pub fn tmpth ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmpth ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn tmpsel ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_tmpsel ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn thsel ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_thsel ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tmpth : u32 , tmpsel : u32 , thsel : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tmpth : u32 = unsafe { :: std :: mem :: transmute ( tmpth ) } ; tmpth as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let tmpsel : u32 = unsafe { :: std :: mem :: transmute ( tmpsel ) } ; tmpsel as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 2u8 , { let thsel : u32 = unsafe { :: std :: mem :: transmute ( thsel ) } ; thsel as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 10u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_temperature_threshold { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_error_recovery { pub raw : u32 , pub bits : spdk_nvme_feat_error_recovery__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_error_recovery__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_error_recovery__bindgen_ty_1 { # [ inline ] pub fn tler ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tler ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn dulbe ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dulbe ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tler : u32 , dulbe : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tler : u32 = unsafe { :: std :: mem :: transmute ( tler ) } ; tler as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let dulbe : u32 = unsafe { :: std :: mem :: transmute ( dulbe ) } ; dulbe as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_error_recovery { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_volatile_write_cache { pub raw : u32 , pub bits : spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 { # [ inline ] pub fn wce ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wce ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( wce : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let wce : u32 = unsafe { :: std :: mem :: transmute ( wce ) } ; wce as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_volatile_write_cache { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_number_of_queues { pub raw : u32 , pub bits : spdk_nvme_feat_number_of_queues__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_number_of_queues__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_number_of_queues__bindgen_ty_1 { # [ inline ] pub fn nsqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_nsqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn ncqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ncqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( nsqr : u32 , ncqr : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let nsqr : u32 = unsafe { :: std :: mem :: transmute ( nsqr ) } ; nsqr as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let ncqr : u32 = unsafe { :: std :: mem :: transmute ( ncqr ) } ; ncqr as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_number_of_queues { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_interrupt_vector_configuration { pub raw : u32 , pub bits : spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 { # [ inline ] pub fn iv ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_iv ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn cd ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cd ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( iv : u32 , cd : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let iv : u32 = unsafe { :: std :: mem :: transmute ( iv ) } ; iv as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let cd : u32 = unsafe { :: std :: mem :: transmute ( cd ) } ; cd as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_interrupt_vector_configuration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_write_atomicity { pub raw : u32 , pub bits : spdk_nvme_feat_write_atomicity__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_write_atomicity__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_write_atomicity__bindgen_ty_1 { # [ inline ] pub fn dn ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dn ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( dn : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let dn : u32 = unsafe { :: std :: mem :: transmute ( dn ) } ; dn as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_write_atomicity { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_async_event_configuration { pub raw : u32 , pub bits : spdk_nvme_feat_async_event_configuration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { pub crit_warn : spdk_nvme_critical_warning_state , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl Default for spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { # [ inline ] pub fn ns_attr_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ns_attr_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fw_activation_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fw_activation_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn telemetry_log_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_telemetry_log_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ns_attr_notice : u32 , fw_activation_notice : u32 , telemetry_log_notice : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ns_attr_notice : u32 = unsafe { :: std :: mem :: transmute ( ns_attr_notice ) } ; ns_attr_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let fw_activation_notice : u32 = unsafe { :: std :: mem :: transmute ( fw_activation_notice ) } ; fw_activation_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let telemetry_log_notice : u32 = unsafe { :: std :: mem :: transmute ( telemetry_log_notice ) } ; telemetry_log_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 21u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_async_event_configuration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_autonomous_power_state_transition { pub raw : u32 , pub bits : spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 { # [ inline ] pub fn apste ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_apste ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( apste : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let apste : u32 = unsafe { :: std :: mem :: transmute ( apste ) } ; apste as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_autonomous_power_state_transition { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_mem_buffer { pub raw : u32 , pub bits : spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 { # [ inline ] pub fn ehm ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ehm ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn mr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_mr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ehm : u32 , mr : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ehm : u32 = unsafe { :: std :: mem :: transmute ( ehm ) } ; ehm as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let mr : u32 = unsafe { :: std :: mem :: transmute ( mr ) } ; mr as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_host_mem_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_keep_alive_timer { pub raw : u32 , pub bits : spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 { # [ inline ] pub fn kato ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 32u8 ) as u32 ) } } # [ inline ] pub fn set_kato ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 32u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( kato : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 32u8 , { let kato : u32 = unsafe { :: std :: mem :: transmute ( kato ) } ; kato as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_keep_alive_timer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_controlled_thermal_management { pub raw : u32 , pub bits : spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 { # [ inline ] pub fn tmt2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmt2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn tmt1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmt1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tmt2 : u32 , tmt1 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tmt2 : u32 = unsafe { :: std :: mem :: transmute ( tmt2 ) } ; tmt2 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let tmt1 : u32 = unsafe { :: std :: mem :: transmute ( tmt1 ) } ; tmt1 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_host_controlled_thermal_management { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_non_operational_power_state_config { pub raw : u32 , pub bits : spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 { # [ inline ] pub fn noppme ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_noppme ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( noppme : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let noppme : u32 = unsafe { :: std :: mem :: transmute ( noppme ) } ; noppme as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_non_operational_power_state_config { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_software_progress_marker { pub raw : u32 , pub bits : spdk_nvme_feat_software_progress_marker__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_software_progress_marker__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_software_progress_marker__bindgen_ty_1 { # [ inline ] pub fn pbslc ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_pbslc ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pbslc : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let pbslc : u32 = unsafe { :: std :: mem :: transmute ( pbslc ) } ; pbslc as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_software_progress_marker { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_identifier { pub raw : u32 , pub bits : spdk_nvme_feat_host_identifier__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_identifier__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_feat_host_identifier__bindgen_ty_1 { # [ inline ] pub fn exhid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_exhid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( exhid : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let exhid : u32 = unsafe { :: std :: mem :: transmute ( exhid ) } ; exhid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_feat_host_identifier { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_firmware_page { pub afi : spdk_nvme_firmware_page__bindgen_ty_1 , pub reserved : [ u8 ; 7usize ] , pub revision : [ [ u8 ; 8usize ] ; 7usize ] , pub reserved2 : [ u8 ; 448usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_firmware_page__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_firmware_page__bindgen_ty_1 { # [ inline ] pub fn active_slot ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_active_slot ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn next_reset_slot ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_next_reset_slot ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved7 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved7 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( active_slot : u8 , reserved3 : u8 , next_reset_slot : u8 , reserved7 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let active_slot : u8 = unsafe { :: std :: mem :: transmute ( active_slot ) } ; active_slot as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let next_reset_slot : u8 = unsafe { :: std :: mem :: transmute ( next_reset_slot ) } ; next_reset_slot as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved7 : u8 = unsafe { :: std :: mem :: transmute ( reserved7 ) } ; reserved7 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_firmware_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_ATTACH : spdk_nvme_ns_attach_type = 0 ; pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_DETACH : spdk_nvme_ns_attach_type = 1 ; pub type spdk_nvme_ns_attach_type = u32 ; pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_CREATE : spdk_nvme_ns_management_type = 0 ; pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_DELETE : spdk_nvme_ns_management_type = 1 ; pub type spdk_nvme_ns_management_type = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ns_list { pub ns_list : [ u32 ; 1024usize ] , } impl Default for spdk_nvme_ns_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_nidt_SPDK_NVME_NIDT_EUI64 : spdk_nvme_nidt = 1 ; pub const spdk_nvme_nidt_SPDK_NVME_NIDT_NGUID : spdk_nvme_nidt = 2 ; pub const spdk_nvme_nidt_SPDK_NVME_NIDT_UUID : spdk_nvme_nidt = 3 ; pub type spdk_nvme_nidt = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_nvme_ns_id_desc { pub nidt : u8 , pub nidl : u8 , pub reserved2 : u8 , pub reserved3 : u8 , pub nid : __IncompleteArrayField < u8 > , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_list { pub ctrlr_count : u16 , pub ctrlr_list : [ u16 ; 2047usize ] , } impl Default for spdk_nvme_ctrlr_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE : spdk_nvme_secure_erase_setting = 0 ; pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE : spdk_nvme_secure_erase_setting = 1 ; pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE : spdk_nvme_secure_erase_setting = 2 ; pub type spdk_nvme_secure_erase_setting = u32 ; pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL : spdk_nvme_pi_location = 0 ; pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD : spdk_nvme_pi_location = 1 ; pub type spdk_nvme_pi_location = u32 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_DISABLE : spdk_nvme_pi_type = 0 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE1 : spdk_nvme_pi_type = 1 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE2 : spdk_nvme_pi_type = 2 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE3 : spdk_nvme_pi_type = 3 ; pub type spdk_nvme_pi_type = u32 ; pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER : spdk_nvme_metadata_setting = 0 ; pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA : spdk_nvme_metadata_setting = 1 ; pub type spdk_nvme_metadata_setting = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_format { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_format { # [ inline ] pub fn lbaf ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_lbaf ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ms ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ms ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pi ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_pi ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn pil ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_pil ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ses ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ses ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( lbaf : u32 , ms : u32 , pi : u32 , pil : u32 , ses : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let lbaf : u32 = unsafe { :: std :: mem :: transmute ( lbaf ) } ; lbaf as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ms : u32 = unsafe { :: std :: mem :: transmute ( ms ) } ; ms as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let pi : u32 = unsafe { :: std :: mem :: transmute ( pi ) } ; pi as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let pil : u32 = unsafe { :: std :: mem :: transmute ( pil ) } ; pil as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let ses : u32 = unsafe { :: std :: mem :: transmute ( ses ) } ; ses as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_protection_info { pub guard : u16 , pub app_tag : u16 , pub ref_tag : u32 , } pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_IMG : spdk_nvme_fw_commit_action = 0 ; pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG : spdk_nvme_fw_commit_action = 1 ; pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_ENABLE_IMG : spdk_nvme_fw_commit_action = 2 ; pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_RUN_IMG : spdk_nvme_fw_commit_action = 3 ; pub type spdk_nvme_fw_commit_action = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_fw_commit { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_fw_commit { # [ inline ] pub fn fs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_fs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( fs : u32 , ca : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let fs : u32 = unsafe { :: std :: mem :: transmute ( fs ) } ; fs as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let ca : u32 = unsafe { :: std :: mem :: transmute ( ca ) } ; ca as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } pub const spdk_json_val_type_SPDK_JSON_VAL_INVALID : spdk_json_val_type = 0 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NULL : spdk_json_val_type = 2 ; pub const spdk_json_val_type_SPDK_JSON_VAL_TRUE : spdk_json_val_type = 4 ; pub const spdk_json_val_type_SPDK_JSON_VAL_FALSE : spdk_json_val_type = 8 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NUMBER : spdk_json_val_type = 16 ; pub const spdk_json_val_type_SPDK_JSON_VAL_STRING : spdk_json_val_type = 32 ; pub const spdk_json_val_type_SPDK_JSON_VAL_ARRAY_BEGIN : spdk_json_val_type = 64 ; pub const spdk_json_val_type_SPDK_JSON_VAL_ARRAY_END : spdk_json_val_type = 128 ; pub const spdk_json_val_type_SPDK_JSON_VAL_OBJECT_BEGIN : spdk_json_val_type = 256 ; pub const spdk_json_val_type_SPDK_JSON_VAL_OBJECT_END : spdk_json_val_type = 512 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NAME : spdk_json_val_type = 1024 ; pub type spdk_json_val_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_val { pub start : * mut libc :: c_void , pub len : u32 , pub type_ : spdk_json_val_type , } impl Default for spdk_json_val { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_json_parse ( json : * mut libc :: c_void , size : usize , values : * mut spdk_json_val , num_values : usize , end : * mut * mut libc :: c_void , flags : u32 ) -> isize ; } pub type spdk_json_decode_fn = :: std :: option :: Option < unsafe extern "C" fn ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_object_decoder { pub name : * const libc :: c_char , pub offset : usize , pub decode_func : spdk_json_decode_fn , pub optional : bool , } impl Default for spdk_json_object_decoder { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_json_decode_object ( values : * const spdk_json_val , decoders : * const spdk_json_object_decoder , num_decoders : usize , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_array ( values : * const spdk_json_val , decode_func : spdk_json_decode_fn , out : * mut libc :: c_void , max_size : usize , out_size : * mut usize , stride : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_bool ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_uint16 ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_int32 ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_uint32 ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_uint64 ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_decode_string ( val : * const spdk_json_val , out : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_val_len ( val : * const spdk_json_val ) -> usize ; } extern "C" { pub fn spdk_json_strequal ( val : * const spdk_json_val , str : * const libc :: c_char ) -> bool ; } extern "C" { pub fn spdk_json_strdup ( val : * const spdk_json_val ) -> * mut libc :: c_char ; } extern "C" { pub fn spdk_json_number_to_uint16 ( val : * const spdk_json_val , num : * mut u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_number_to_int32 ( val : * const spdk_json_val , num : * mut i32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_number_to_uint32 ( val : * const spdk_json_val , num : * mut u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_number_to_uint64 ( val : * const spdk_json_val , num : * mut u64 ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_write_ctx { _unused : [ u8 ; 0 ] , } pub type spdk_json_write_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , data : * const libc :: c_void , size : usize ) -> libc :: c_int > ; extern "C" { pub fn spdk_json_write_begin ( write_cb : spdk_json_write_cb , cb_ctx : * mut libc :: c_void , flags : u32 ) -> * mut spdk_json_write_ctx ; } extern "C" { pub fn spdk_json_write_end ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_null ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_bool ( w : * mut spdk_json_write_ctx , val : bool ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_int32 ( w : * mut spdk_json_write_ctx , val : i32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_uint32 ( w : * mut spdk_json_write_ctx , val : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_int64 ( w : * mut spdk_json_write_ctx , val : i64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_uint64 ( w : * mut spdk_json_write_ctx , val : u64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string ( w : * mut spdk_json_write_ctx , val : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_raw ( w : * mut spdk_json_write_ctx , val : * const libc :: c_char , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_utf16le ( w : * mut spdk_json_write_ctx , val : * const u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_utf16le_raw ( w : * mut spdk_json_write_ctx , val : * const u16 , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_fmt ( w : * mut spdk_json_write_ctx , fmt : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_string_fmt_v ( w : * mut spdk_json_write_ctx , fmt : * const libc :: c_char , args : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_array_begin ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_array_end ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_object_begin ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_object_end ( w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_name ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_name_raw ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_val ( w : * mut spdk_json_write_ctx , val : * const spdk_json_val ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_val_raw ( w : * mut spdk_json_write_ctx , data : * const libc :: c_void , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_null ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_bool ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : bool ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_int32 ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : i32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_uint32 ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_uint64 ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : u64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_int64 ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : i64 ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_string ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , val : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_string_fmt ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , fmt : * const libc :: c_char , ... ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_string_fmt_v ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char , fmt : * const libc :: c_char , args : * mut __va_list_tag ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_array_begin ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_write_named_object_begin ( w : * mut spdk_json_write_ctx , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_find ( object : * mut spdk_json_val , key_name : * const libc :: c_char , key : * mut * mut spdk_json_val , val : * mut * mut spdk_json_val , type_ : spdk_json_val_type ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_find_string ( object : * mut spdk_json_val , key_name : * const libc :: c_char , key : * mut * mut spdk_json_val , val : * mut * mut spdk_json_val ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_find_array ( object : * mut spdk_json_val , key_name : * const libc :: c_char , key : * mut * mut spdk_json_val , value : * mut * mut spdk_json_val ) -> libc :: c_int ; } extern "C" { pub fn spdk_json_object_first ( object : * mut spdk_json_val ) -> * mut spdk_json_val ; } extern "C" { pub fn spdk_json_array_first ( array_begin : * mut spdk_json_val ) -> * mut spdk_json_val ; } extern "C" { pub fn spdk_json_next ( pos : * mut spdk_json_val ) -> * mut spdk_json_val ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_histogram_data { pub bucket_shift : u32 , pub bucket : * mut u64 , } impl Default for spdk_histogram_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type spdk_histogram_data_fn = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , start : u64 , end : u64 , count : u64 , total : u64 , so_far : u64 ) > ; 
 /// Block device remove callback.
///
/// \param remove_ctx Context for the removed block device. 
 pub type spdk_bdev_remove_cb_t = :: std :: option :: Option < unsafe extern "C" fn ( remove_ctx : * mut libc :: c_void ) > ; pub const spdk_bdev_status_SPDK_BDEV_STATUS_INVALID : spdk_bdev_status = 0 ; pub const spdk_bdev_status_SPDK_BDEV_STATUS_READY : spdk_bdev_status = 1 ; pub const spdk_bdev_status_SPDK_BDEV_STATUS_REMOVING : spdk_bdev_status = 2 ; 
 /// bdev status 
 pub type spdk_bdev_status = u32 ; 
 /// \brief Handle to an opened SPDK block device. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_desc { _unused : [ u8 ; 0 ] , } pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_INVALID : spdk_bdev_io_type = 0 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_READ : spdk_bdev_io_type = 1 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_WRITE : spdk_bdev_io_type = 2 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_UNMAP : spdk_bdev_io_type = 3 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_FLUSH : spdk_bdev_io_type = 4 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_RESET : spdk_bdev_io_type = 5 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_ADMIN : spdk_bdev_io_type = 6 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_IO : spdk_bdev_io_type = 7 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_IO_MD : spdk_bdev_io_type = 8 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_WRITE_ZEROES : spdk_bdev_io_type = 9 ; pub const spdk_bdev_io_type_SPDK_BDEV_NUM_IO_TYPES : spdk_bdev_io_type = 10 ; 
 /// bdev I/O type 
 pub type spdk_bdev_io_type = u32 ; 
 /// IOPS rate limit for both read and write 
 pub const spdk_bdev_qos_rate_limit_type_SPDK_BDEV_QOS_RW_IOPS_RATE_LIMIT : spdk_bdev_qos_rate_limit_type = 0 ; 
 /// Byte per second rate limit for both read and write 
 pub const spdk_bdev_qos_rate_limit_type_SPDK_BDEV_QOS_RW_BPS_RATE_LIMIT : spdk_bdev_qos_rate_limit_type = 1 ; 
 /// Byte per second rate limit for read only 
 pub const spdk_bdev_qos_rate_limit_type_SPDK_BDEV_QOS_R_BPS_RATE_LIMIT : spdk_bdev_qos_rate_limit_type = 2 ; 
 /// Byte per second rate limit for write only 
 pub const spdk_bdev_qos_rate_limit_type_SPDK_BDEV_QOS_W_BPS_RATE_LIMIT : spdk_bdev_qos_rate_limit_type = 3 ; 
 /// Keep last 
 pub const spdk_bdev_qos_rate_limit_type_SPDK_BDEV_QOS_NUM_RATE_LIMIT_TYPES : spdk_bdev_qos_rate_limit_type = 4 ; 
 /// bdev QoS rate limit type 
 pub type spdk_bdev_qos_rate_limit_type = u32 ; 
 /// Block device completion callback.
///
/// \param bdev_io Block device I/O that has completed.
/// \param success True if I/O completed successfully or false if it failed;
/// additional error information may be retrieved from bdev_io by calling
/// spdk_bdev_io_get_nvme_status() or spdk_bdev_io_get_scsi_status().
/// \param cb_arg Callback argument specified when bdev_io was submitted. 
 pub type spdk_bdev_io_completion_cb = :: std :: option :: Option < unsafe extern "C" fn ( bdev_io : * mut spdk_bdev_io , success : bool , cb_arg : * mut libc :: c_void ) > ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_io_stat { pub bytes_read : u64 , pub num_read_ops : u64 , pub bytes_written : u64 , pub num_write_ops : u64 , pub bytes_unmapped : u64 , pub num_unmap_ops : u64 , pub read_latency_ticks : u64 , pub write_latency_ticks : u64 , pub unmap_latency_ticks : u64 , pub ticks_rate : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_opts { pub bdev_io_pool_size : u32 , pub bdev_io_cache_size : u32 , } extern "C" { pub fn spdk_bdev_get_opts ( opts : * mut spdk_bdev_opts ) ; } extern "C" { pub fn spdk_bdev_set_opts ( opts : * mut spdk_bdev_opts ) -> libc :: c_int ; } 
 /// Block device initialization callback.
///
/// \param cb_arg Callback argument.
/// \param rc 0 if block device initialized successfully or negative errno if it failed. 
 pub type spdk_bdev_init_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , rc : libc :: c_int ) > ; 
 /// Block device finish callback.
///
/// \param cb_arg Callback argument. 
 pub type spdk_bdev_fini_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void ) > ; pub type spdk_bdev_get_device_stat_cb = :: std :: option :: Option < unsafe extern "C" fn ( bdev : * mut spdk_bdev , stat : * mut spdk_bdev_io_stat , cb_arg : * mut libc :: c_void , rc : libc :: c_int ) > ; extern "C" { 
 /// Initialize block device modules.
///
/// \param cb_fn Called when the initialization is complete.
/// \param cb_arg Argument passed to function cb_fn. 
 pub fn spdk_bdev_initialize ( cb_fn : spdk_bdev_init_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Perform cleanup work to remove the registered block device modules.
///
/// \param cb_fn Called when the removal is complete.
/// \param cb_arg Argument passed to function cb_fn. 
 pub fn spdk_bdev_finish ( cb_fn : spdk_bdev_fini_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Get the configuration options for the registered block device modules.
///
/// \param fp The pointer to a file that will be written to the configuration options. 
 pub fn spdk_bdev_config_text ( fp : * mut FILE ) ; } extern "C" { 
 /// Get the full configuration options for the registered block device modules and created bdevs.
///
/// \param w pointer to a JSON write context where the configuration will be written. 
 pub fn spdk_bdev_subsystem_config_json ( w : * mut spdk_json_write_ctx ) ; } extern "C" { 
 /// Get block device by the block device name.
///
/// \param bdev_name The name of the block device.
/// \return Block device associated with the name or NULL if no block device with
/// bdev_name is currently registered. 
 pub fn spdk_bdev_get_by_name ( bdev_name : * const libc :: c_char ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the first registered block device.
///
/// \return The first registered block device. 
 pub fn spdk_bdev_first ( ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the next registered block device.
///
/// \param prev The current block device.
/// \return The next registered block device. 
 pub fn spdk_bdev_next ( prev : * mut spdk_bdev ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the first block device without virtual block devices on top.
///
/// This function only traverses over block devices which have no virtual block
/// devices on top of them, then get the first one.
///
/// \return The first block device without virtual block devices on top. 
 pub fn spdk_bdev_first_leaf ( ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the next block device without virtual block devices on top.
///
/// This function only traverses over block devices which have no virtual block
/// devices on top of them, then get the next one.
///
/// \param prev The current block device.
/// \return The next block device without virtual block devices on top. 
 pub fn spdk_bdev_next_leaf ( prev : * mut spdk_bdev ) -> * mut spdk_bdev ; } extern "C" { 
 /// Open a block device for I/O operations.
///
/// \param bdev Block device to open.
/// \param write true is read/write access requested, false if read-only
/// \param remove_cb callback function for hot remove the device. Will
/// always be called on the same thread that spdk_bdev_open() was called on.
/// \param remove_ctx param for hot removal callback function.
/// \param desc output parameter for the descriptor when operation is successful
/// \return 0 if operation is successful, suitable errno value otherwise 
 pub fn spdk_bdev_open ( bdev : * mut spdk_bdev , write : bool , remove_cb : spdk_bdev_remove_cb_t , remove_ctx : * mut libc :: c_void , desc : * mut * mut spdk_bdev_desc ) -> libc :: c_int ; } extern "C" { 
 /// Close a previously opened block device.
///
/// Must be called on the same thread that the spdk_bdev_open()
/// was performed on.
///
/// \param desc Block device descriptor to close. 
 pub fn spdk_bdev_close ( desc : * mut spdk_bdev_desc ) ; } extern "C" { 
 /// Get the bdev associated with a bdev descriptor.
///
/// \param desc Open block device desciptor
/// \return bdev associated with the descriptor 
 pub fn spdk_bdev_desc_get_bdev ( desc : * mut spdk_bdev_desc ) -> * mut spdk_bdev ; } extern "C" { 
 /// Check whether the block device supports the I/O type.
///
/// \param bdev Block device to check.
/// \param io_type The specific I/O type like read, write, flush, unmap.
/// \return true if support, false otherwise. 
 pub fn spdk_bdev_io_type_supported ( bdev : * mut spdk_bdev , io_type : spdk_bdev_io_type ) -> bool ; } extern "C" { 
 /// Output driver-specific information to a JSON stream.
///
/// The JSON write context will be initialized with an open object, so the bdev
/// driver should write a name(based on the driver name) followed by a JSON value
/// (most likely another nested object).
///
/// \param bdev Block device to query.
/// \param w JSON write context. It will store the driver-specific configuration context.
/// \return 0 on success, negated errno on failure. 
 pub fn spdk_bdev_dump_info_json ( bdev : * mut spdk_bdev , w : * mut spdk_json_write_ctx ) -> libc :: c_int ; } extern "C" { 
 /// Get block device name.
///
/// \param bdev Block device to query.
/// \return Name of bdev as a null-terminated string. 
 pub fn spdk_bdev_get_name ( bdev : * const spdk_bdev ) -> * const libc :: c_char ; } extern "C" { 
 /// Get block device product name.
///
/// \param bdev Block device to query.
/// \return Product name of bdev as a null-terminated string. 
 pub fn spdk_bdev_get_product_name ( bdev : * const spdk_bdev ) -> * const libc :: c_char ; } extern "C" { 
 /// Get block device logical block size.
///
/// \param bdev Block device to query.
/// \return Size of logical block for this bdev in bytes. 
 pub fn spdk_bdev_get_block_size ( bdev : * const spdk_bdev ) -> u32 ; } extern "C" { 
 /// Get size of block device in logical blocks.
///
/// \param bdev Block device to query.
/// \return Size of bdev in logical blocks.
///
/// Logical blocks are numbered from 0 to spdk_bdev_get_num_blocks(bdev) - 1, inclusive. 
 pub fn spdk_bdev_get_num_blocks ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { 
 /// Get the string of quality of service rate limit.
///
/// \param type Type of rate limit to query.
/// \return String of QoS type. 
 pub fn spdk_bdev_get_qos_rpc_type ( type_ : spdk_bdev_qos_rate_limit_type ) -> * const libc :: c_char ; } extern "C" { 
 /// Get the quality of service rate limits on a bdev.
///
/// \param bdev Block device to query.
/// \param limits Pointer to the QoS rate limits array which holding the limits.
///
/// The limits are ordered based on the @ref spdk_bdev_qos_rate_limit_type enum. 
 pub fn spdk_bdev_get_qos_rate_limits ( bdev : * mut spdk_bdev , limits : * mut u64 ) ; } extern "C" { 
 /// Set the quality of service rate limits on a bdev.
///
/// \param bdev Block device.
/// \param limits Pointer to the QoS rate limits array which holding the limits.
/// \param cb_fn Callback function to be called when the QoS limit has been updated.
/// \param cb_arg Argument to pass to cb_fn.
///
/// The limits are ordered based on the @ref spdk_bdev_qos_rate_limit_type enum. 
 pub fn spdk_bdev_set_qos_rate_limits ( bdev : * mut spdk_bdev , limits : * mut u64 , cb_fn : :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , status : libc :: c_int ) > , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Get minimum I/O buffer address alignment for a bdev.
///
/// \param bdev Block device to query.
/// \return Required alignment of I/O buffers in bytes. 
 pub fn spdk_bdev_get_buf_align ( bdev : * const spdk_bdev ) -> usize ; } extern "C" { 
 /// Get optimal I/O boundary for a bdev.
///
/// \param bdev Block device to query.
/// \return Optimal I/O boundary in blocks that should not be crossed for best performance, or 0 if
///         no optimal boundary is reported. 
 pub fn spdk_bdev_get_optimal_io_boundary ( bdev : * const spdk_bdev ) -> u32 ; } extern "C" { 
 /// Query whether block device has an enabled write cache.
///
/// \param bdev Block device to query.
/// \return true if block device has a volatile write cache enabled.
///
/// If this function returns true, written data may not be persistent until a flush command
/// is issued. 
 pub fn spdk_bdev_has_write_cache ( bdev : * const spdk_bdev ) -> bool ; } extern "C" { 
 /// Get a bdev's UUID.
///
/// \param bdev Block device to query.
/// \return Pointer to UUID.
///
/// Not all bdevs will have a UUID; in this case, the returned UUID will be
/// the nil UUID (all bytes zero). 
 pub fn spdk_bdev_get_uuid ( bdev : * const spdk_bdev ) -> * const spdk_uuid ; } extern "C" { 
 /// Get the most recently measured queue depth from a bdev.
///
/// The reported queue depth is the aggregate of outstanding I/O
/// across all open channels associated with this bdev.
///
/// \param bdev Block device to query.
///
/// \return The most recent queue depth measurement for the bdev.
/// If tracking is not enabled, the function will return UINT64_MAX
/// It is also possible to receive UINT64_MAX after enabling tracking
/// but before the first period has expired. 
 pub fn spdk_bdev_get_qd ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { 
 /// Get the queue depth polling period.
///
/// The return value of this function is only valid if the bdev's
/// queue depth tracking status is set to true.
///
/// \param bdev Block device to query.
///
/// \return The period at which this bdev's gueue depth is being refreshed. 
 pub fn spdk_bdev_get_qd_sampling_period ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { 
 /// Enable or disable queue depth sampling for this bdev.
///
/// Enables queue depth sampling when period is greater than 0. Disables it when the period
/// is equal to zero. The resulting queue depth is stored in the spdk_bdev object as
/// measured_queue_depth.
///
/// \param bdev Block device on which to enable queue depth tracking.
/// \param period The period at which to poll this bdev's queue depth. If this is set
/// to zero, polling will be disabled. 
 pub fn spdk_bdev_set_qd_sampling_period ( bdev : * mut spdk_bdev , period : u64 ) ; } extern "C" { 
 /// Get the time spent processing IO for this device.
///
/// This value is dependent upon the queue depth sampling period and is
/// incremented at sampling time by the sampling period only if the measured
/// queue depth is greater than 0.
///
/// The disk utilization can be calculated by the following formula:
/// disk_util = (io_time_2 - io_time_1) / elapsed_time.
/// The user is responsible for tracking the elapsed time between two measurements.
///
/// \param bdev Block device to query.
///
/// \return The io time for this device in microseconds. 
 pub fn spdk_bdev_get_io_time ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { 
 /// Get the weighted IO processing time for this bdev.
///
/// This value is dependent upon the queue depth sampling period and is
/// equal to the time spent reading from or writing to a device times
/// the measured queue depth during each sampling period.
///
/// The average queue depth can be calculated by the following formula:
/// queue_depth = (weighted_io_time_2 - weighted_io_time_1) / elapsed_time.
/// The user is responsible for tracking the elapsed time between two measurements.
///
/// \param bdev Block device to query.
///
/// \return The weighted io time for this device in microseconds. 
 pub fn spdk_bdev_get_weighted_io_time ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { 
 /// Obtain an I/O channel for the block device opened by the specified
/// descriptor. I/O channels are bound to threads, so the resulting I/O
/// channel may only be used from the thread it was originally obtained
/// from.
///
/// \param desc Block device descriptor.
///
/// \return A handle to the I/O channel or NULL on failure. 
 pub fn spdk_bdev_get_io_channel ( desc : * mut spdk_bdev_desc ) -> * mut spdk_io_channel ; } extern "C" { 
 /// Submit a read request to the bdev on the given channel.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param buf Data buffer to read into.
/// \param offset The offset, in bytes, from the start of the block device.
/// \param nbytes The number of bytes to read.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset and/or nbytes are not aligned or out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated 
 pub fn spdk_bdev_read ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut libc :: c_void , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a read request to the bdev on the given channel.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param buf Data buffer to read into.
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to read.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset_blocks and/or num_blocks are out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated 
 pub fn spdk_bdev_read_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut libc :: c_void , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a read request to the bdev on the given channel. This differs from
/// spdk_bdev_read by allowing the data buffer to be described in a scatter
/// gather list. Some physical devices place memory alignment requirements on
/// data and may not be able to directly transfer into the buffers provided. In
/// this case, the request may fail.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param iov A scatter gather list of buffers to be read into.
/// \param iovcnt The number of elements in iov.
/// \param offset The offset, in bytes, from the start of the block device.
/// \param nbytes The number of bytes to read.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset and/or nbytes are not aligned or out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated 
 pub fn spdk_bdev_readv ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a read request to the bdev on the given channel. This differs from
/// spdk_bdev_read by allowing the data buffer to be described in a scatter
/// gather list. Some physical devices place memory alignment requirements on
/// data and may not be able to directly transfer into the buffers provided. In
/// this case, the request may fail.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param iov A scatter gather list of buffers to be read into.
/// \param iovcnt The number of elements in iov.
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to read.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset_blocks and/or num_blocks are out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated 
 pub fn spdk_bdev_readv_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a write request to the bdev on the given channel.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param buf Data buffer to written from.
/// \param offset The offset, in bytes, from the start of the block device.
/// \param nbytes The number of bytes to write. buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset and/or nbytes are not aligned or out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_write ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut libc :: c_void , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a write request to the bdev on the given channel.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param buf Data buffer to written from.
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to write. buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset_blocks and/or num_blocks are out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_write_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut libc :: c_void , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a write request to the bdev on the given channel. This differs from
/// spdk_bdev_write by allowing the data buffer to be described in a scatter
/// gather list. Some physical devices place memory alignment requirements on
/// data and may not be able to directly transfer out of the buffers provided. In
/// this case, the request may fail.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param iov A scatter gather list of buffers to be written from.
/// \param iovcnt The number of elements in iov.
/// \param offset The offset, in bytes, from the start of the block device.
/// \param len The size of data to write.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset and/or nbytes are not aligned or out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_writev ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , len : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a write request to the bdev on the given channel. This differs from
/// spdk_bdev_write by allowing the data buffer to be described in a scatter
/// gather list. Some physical devices place memory alignment requirements on
/// data and may not be able to directly transfer out of the buffers provided. In
/// this case, the request may fail.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param iov A scatter gather list of buffers to be written from.
/// \param iovcnt The number of elements in iov.
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to write.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset_blocks and/or num_blocks are out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_writev_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a write zeroes request to the bdev on the given channel. This command
///  ensures that all bytes in the specified range are set to 00h
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset The offset, in bytes, from the start of the block device.
/// \param len The size of data to zero.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset and/or nbytes are not aligned or out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_write_zeroes ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , len : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a write zeroes request to the bdev on the given channel. This command
///  ensures that all bytes in the specified range are set to 00h
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to zero.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset_blocks and/or num_blocks are out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_write_zeroes_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit an unmap request to the block device. Unmap is sometimes also called trim or
/// deallocate. This notifies the device that the data in the blocks described is no
/// longer valid. Reading blocks that have been unmapped results in indeterminate data.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset The offset, in bytes, from the start of the block device.
/// \param nbytes The number of bytes to unmap. Must be a multiple of the block size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset and/or nbytes are not aligned or out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_unmap ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit an unmap request to the block device. Unmap is sometimes also called trim or
/// deallocate. This notifies the device that the data in the blocks described is no
/// longer valid. Reading blocks that have been unmapped results in indeterminate data.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to unmap.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset_blocks and/or num_blocks are out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_unmap_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a flush request to the bdev on the given channel. For devices with volatile
/// caches, data is not guaranteed to be persistent until the completion of a flush
/// request. Call spdk_bdev_has_write_cache() to check if the bdev has a volatile cache.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset The offset, in bytes, from the start of the block device.
/// \param length The number of bytes.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset and/or nbytes are not aligned or out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_flush ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , length : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a flush request to the bdev on the given channel. For devices with volatile
/// caches, data is not guaranteed to be persistent until the completion of a flush
/// request. Call spdk_bdev_has_write_cache() to check if the bdev has a volatile cache.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -EINVAL - offset_blocks and/or num_blocks are out of range
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_flush_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit a reset request to the bdev on the given channel.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated 
 pub fn spdk_bdev_reset ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit an NVMe Admin command to the bdev. This passes directly through
/// the block layer to the device. Support for NVMe passthru is optional,
/// indicated by calling spdk_bdev_io_type_supported().
///
/// The SGL/PRP will be automated generated based on the given buffer,
/// so that portion of the command may be left empty.
///
/// \ingroup bdev_io_submit_functions
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param cmd The raw NVMe command. Must be an admin command.
/// \param buf Data buffer to written from.
/// \param nbytes The number of bytes to transfer. buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_nvme_admin_passthru ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut libc :: c_void , nbytes : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit an NVMe I/O command to the bdev. This passes directly through
/// the block layer to the device. Support for NVMe passthru is optional,
/// indicated by calling spdk_bdev_io_type_supported().
///
/// \ingroup bdev_io_submit_functions
///
/// The SGL/PRP will be automated generated based on the given buffer,
/// so that portion of the command may be left empty. Also, the namespace
/// id (nsid) will be populated automatically.
///
/// \param bdev_desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param cmd The raw NVMe command. Must be in the NVM command set.
/// \param buf Data buffer to written from.
/// \param nbytes The number of bytes to transfer. buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_nvme_io_passthru ( bdev_desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut libc :: c_void , nbytes : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submit an NVMe I/O command to the bdev. This passes directly through
/// the block layer to the device. Support for NVMe passthru is optional,
/// indicated by calling spdk_bdev_io_type_supported().
///
/// \ingroup bdev_io_submit_functions
///
/// The SGL/PRP will be automated generated based on the given buffer,
/// so that portion of the command may be left empty. Also, the namespace
/// id (nsid) will be populated automatically.
///
/// \param bdev_desc Block device descriptor
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param cmd The raw NVMe command. Must be in the NVM command set.
/// \param buf Data buffer to written from.
/// \param nbytes The number of bytes to transfer. buf must be greater than or equal to this size.
/// \param md_buf Meta data buffer to written from.
/// \param md_len md_buf size to transfer. md_buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called.
///   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
///   * -EBADF - desc not open for writing 
 pub fn spdk_bdev_nvme_io_passthru_md ( bdev_desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut libc :: c_void , nbytes : usize , md_buf : * mut libc :: c_void , md_len : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Free an I/O request. This should only be called after the completion callback
/// for the I/O has been called and notifies the bdev layer that memory may now
/// be released.
///
/// \param bdev_io I/O request. 
 pub fn spdk_bdev_free_io ( bdev_io : * mut spdk_bdev_io ) ; } 
 /// Block device I/O wait callback
///
/// Callback function to notify when an spdk_bdev_io structure is available
/// to satisfy a call to one of the @ref bdev_io_submit_functions. 
 pub type spdk_bdev_io_wait_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void ) > ; 
 /// Structure to register a callback when an spdk_bdev_io becomes available. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io_wait_entry { pub bdev : * mut spdk_bdev , pub cb_fn : spdk_bdev_io_wait_cb , pub cb_arg : * mut libc :: c_void , pub link : spdk_bdev_io_wait_entry__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io_wait_entry__bindgen_ty_1 { pub tqe_next : * mut spdk_bdev_io_wait_entry , pub tqe_prev : * mut * mut spdk_bdev_io_wait_entry , } impl Default for spdk_bdev_io_wait_entry__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_io_wait_entry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Add an entry into the calling thread's queue to be notified when an
/// spdk_bdev_io becomes available.
///
/// When one of the @ref bdev_io_submit_functions returns -ENOMEM, it means
/// the spdk_bdev_io buffer pool has no available buffers. This function may
/// be called to register a callback to be notified when a buffer becomes
/// available on the calling thread.
///
/// The callback function will always be called on the same thread as this
/// function was called.
///
/// This function must only be called immediately after one of the
/// @ref bdev_io_submit_functions returns -ENOMEM.
///
/// \param bdev Block device.  The block device that the caller will submit
///             an I/O to when the callback is invoked.  Must match the bdev
///             member in the entry parameter.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param entry Data structure allocated by the caller specifying the callback
///              function and argument.
///
/// \return 0 on success.
///         -EINVAL if bdev parameter does not match bdev member in entry
///         -EINVAL if an spdk_bdev_io structure was available on this thread. 
 pub fn spdk_bdev_queue_io_wait ( bdev : * mut spdk_bdev , ch : * mut spdk_io_channel , entry : * mut spdk_bdev_io_wait_entry ) -> libc :: c_int ; } extern "C" { 
 /// Return I/O statistics for this channel.
///
/// \param bdev Block device.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param stat The per-channel statistics.
/// 
 pub fn spdk_bdev_get_io_stat ( bdev : * mut spdk_bdev , ch : * mut spdk_io_channel , stat : * mut spdk_bdev_io_stat ) ; } extern "C" { 
 /// Return I/O statistics for this bdev. All the required information will be passed
/// via the callback function.
///
/// \param bdev Block device to query.
/// \param stat Structure for aggregating collected statistics.  Passed as argument to cb.
/// \param cb Called when this operation completes.
/// \param cb_arg Argument passed to callback function. 
 pub fn spdk_bdev_get_device_stat ( bdev : * mut spdk_bdev , stat : * mut spdk_bdev_io_stat , cb : spdk_bdev_get_device_stat_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Get the status of bdev_io as an NVMe status code.
///
/// \param bdev_io I/O to get the status from.
/// \param sct Status Code Type return value, as defined by the NVMe specification.
/// \param sc Status Code return value, as defined by the NVMe specification. 
 pub fn spdk_bdev_io_get_nvme_status ( bdev_io : * const spdk_bdev_io , sct : * mut libc :: c_int , sc : * mut libc :: c_int ) ; } extern "C" { 
 /// Get the status of bdev_io as a SCSI status code.
///
/// \param bdev_io I/O to get the status from.
/// \param sc SCSI Status Code.
/// \param sk SCSI Sense Key.
/// \param asc SCSI Additional Sense Code.
/// \param ascq SCSI Additional Sense Code Qualifier. 
 pub fn spdk_bdev_io_get_scsi_status ( bdev_io : * const spdk_bdev_io , sc : * mut libc :: c_int , sk : * mut libc :: c_int , asc : * mut libc :: c_int , ascq : * mut libc :: c_int ) ; } extern "C" { 
 /// Get the iovec describing the data buffer of a bdev_io.
///
/// \param bdev_io I/O to describe with iovec.
/// \param iovp Pointer to be filled with iovec.
/// \param iovcntp Pointer to be filled with number of iovec entries. 
 pub fn spdk_bdev_io_get_iovec ( bdev_io : * mut spdk_bdev_io , iovp : * mut * mut iovec , iovcntp : * mut libc :: c_int ) ; } pub type spdk_bdev_histogram_status_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , status : libc :: c_int ) > ; pub type spdk_bdev_histogram_data_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , status : libc :: c_int , histogram : * mut spdk_histogram_data ) > ; extern "C" { 
 /// Enable or disable collecting histogram data on a bdev.
///
/// \param bdev Block device.
/// \param cb_fn Callback function to be called when histograms are enabled.
/// \param cb_arg Argument to pass to cb_fn.
/// \param enable Enable/disable flag 
 pub fn spdk_bdev_histogram_enable ( bdev : * mut spdk_bdev , cb_fn : spdk_bdev_histogram_status_cb , cb_arg : * mut libc :: c_void , enable : bool ) ; } extern "C" { 
 /// Get aggregated histogram data from a bdev. Callback provides merged histogram
/// for specified bdev.
///
/// \param bdev Block device.
/// \param histogram Histogram for aggregated data
/// \param cb_fn Callback function to be called with data collected on bdev.
/// \param cb_arg Argument to pass to cb_fn. 
 pub fn spdk_bdev_histogram_get ( bdev : * mut spdk_bdev , histogram : * mut spdk_histogram_data , cb_fn : spdk_bdev_histogram_data_cb , cb_arg : * mut libc :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_thread { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_io_channel_iter { _unused : [ u8 ; 0 ] , } 
 /// \brief A poller is a function that is repeatedly called on an lcore. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_poller { _unused : [ u8 ; 0 ] , } pub type spdk_new_thread_fn = :: std :: option :: Option < unsafe extern "C" fn ( thread : * mut spdk_thread ) > ; pub type spdk_msg_fn = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void ) > ; pub type spdk_thread_pass_msg = :: std :: option :: Option < unsafe extern "C" fn ( fn_ : spdk_msg_fn , ctx : * mut libc :: c_void , thread_ctx : * mut libc :: c_void ) > ; pub type spdk_poller_fn = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void ) -> libc :: c_int > ; pub type spdk_start_poller = :: std :: option :: Option < unsafe extern "C" fn ( thread_ctx : * mut libc :: c_void , fn_ : spdk_poller_fn , arg : * mut libc :: c_void , period_microseconds : u64 ) -> * mut spdk_poller > ; pub type spdk_stop_poller = :: std :: option :: Option < unsafe extern "C" fn ( poller : * mut spdk_poller , thread_ctx : * mut libc :: c_void ) > ; pub type spdk_io_channel_create_cb = :: std :: option :: Option < unsafe extern "C" fn ( io_device : * mut libc :: c_void , ctx_buf : * mut libc :: c_void ) -> libc :: c_int > ; pub type spdk_io_channel_destroy_cb = :: std :: option :: Option < unsafe extern "C" fn ( io_device : * mut libc :: c_void , ctx_buf : * mut libc :: c_void ) > ; pub type spdk_io_device_unregister_cb = :: std :: option :: Option < unsafe extern "C" fn ( io_device : * mut libc :: c_void ) > ; pub type spdk_channel_msg = :: std :: option :: Option < unsafe extern "C" fn ( i : * mut spdk_io_channel_iter ) > ; pub type spdk_channel_for_each_cpl = :: std :: option :: Option < unsafe extern "C" fn ( i : * mut spdk_io_channel_iter , status : libc :: c_int ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_io_channel { pub thread : * mut spdk_thread , pub dev : * mut io_device , pub ref_ : u32 , pub destroy_ref : u32 , pub tailq : spdk_io_channel__bindgen_ty_1 , pub destroy_cb : spdk_io_channel_destroy_cb , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_io_channel__bindgen_ty_1 { pub tqe_next : * mut spdk_io_channel , pub tqe_prev : * mut * mut spdk_io_channel , } impl Default for spdk_io_channel__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_io_channel { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_thread_lib_init ( new_thread_fn : spdk_new_thread_fn ) -> libc :: c_int ; } extern "C" { pub fn spdk_thread_lib_fini ( ) ; } extern "C" { pub fn spdk_thread_create ( name : * const libc :: c_char ) -> * mut spdk_thread ; } extern "C" { pub fn spdk_thread_exit ( thread : * mut spdk_thread ) ; } extern "C" { pub fn spdk_thread_poll ( thread : * mut spdk_thread , max_msgs : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_thread_next_poller_expiration ( thread : * mut spdk_thread ) -> u64 ; } extern "C" { pub fn spdk_thread_has_active_pollers ( thread : * mut spdk_thread ) -> libc :: c_int ; } extern "C" { pub fn spdk_thread_get_count ( ) -> u32 ; } extern "C" { pub fn spdk_get_thread ( ) -> * mut spdk_thread ; } extern "C" { pub fn spdk_thread_get_name ( thread : * const spdk_thread ) -> * const libc :: c_char ; } extern "C" { pub fn spdk_thread_send_msg ( thread : * const spdk_thread , fn_ : spdk_msg_fn , ctx : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_for_each_thread ( fn_ : spdk_msg_fn , ctx : * mut libc :: c_void , cpl : spdk_msg_fn ) ; } extern "C" { pub fn spdk_poller_register ( fn_ : spdk_poller_fn , arg : * mut libc :: c_void , period_microseconds : u64 ) -> * mut spdk_poller ; } extern "C" { pub fn spdk_poller_unregister ( ppoller : * mut * mut spdk_poller ) ; } extern "C" { pub fn spdk_io_device_register ( io_device : * mut libc :: c_void , create_cb : spdk_io_channel_create_cb , destroy_cb : spdk_io_channel_destroy_cb , ctx_size : u32 , name : * const libc :: c_char ) ; } extern "C" { pub fn spdk_io_device_unregister ( io_device : * mut libc :: c_void , unregister_cb : spdk_io_device_unregister_cb ) ; } extern "C" { pub fn spdk_get_io_channel ( io_device : * mut libc :: c_void ) -> * mut spdk_io_channel ; } extern "C" { pub fn spdk_put_io_channel ( ch : * mut spdk_io_channel ) ; } extern "C" { pub fn spdk_io_channel_from_ctx ( ctx : * mut libc :: c_void ) -> * mut spdk_io_channel ; } extern "C" { pub fn spdk_io_channel_get_thread ( ch : * mut spdk_io_channel ) -> * mut spdk_thread ; } extern "C" { pub fn spdk_for_each_channel ( io_device : * mut libc :: c_void , fn_ : spdk_channel_msg , ctx : * mut libc :: c_void , cpl : spdk_channel_for_each_cpl ) ; } extern "C" { pub fn spdk_io_channel_iter_get_io_device ( i : * mut spdk_io_channel_iter ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_io_channel_iter_get_channel ( i : * mut spdk_io_channel_iter ) -> * mut spdk_io_channel ; } extern "C" { pub fn spdk_io_channel_iter_get_ctx ( i : * mut spdk_io_channel_iter ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_for_each_channel_continue ( i : * mut spdk_io_channel_iter , status : libc :: c_int ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_uuid { pub u : spdk_uuid__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_uuid__bindgen_ty_1 { pub raw : [ u8 ; 16usize ] , _bindgen_union_align : [ u8 ; 16usize ] , } impl Default for spdk_uuid__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_uuid { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_uuid_parse ( uuid : * mut spdk_uuid , uuid_str : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_uuid_fmt_lower ( uuid_str : * mut libc :: c_char , uuid_str_size : usize , uuid : * const spdk_uuid ) -> libc :: c_int ; } extern "C" { pub fn spdk_uuid_compare ( u1 : * const spdk_uuid , u2 : * const spdk_uuid ) -> libc :: c_int ; } extern "C" { pub fn spdk_uuid_generate ( uuid : * mut spdk_uuid ) ; } extern "C" { pub fn spdk_uuid_copy ( dst : * mut spdk_uuid , src : * const spdk_uuid ) ; } 
 /// Block device module 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_module { 
 /// Initialization function for the module.  Called by the spdk
    /// application during startup.
    ///
    /// Modules are required to define this function. 
 pub module_init : :: std :: option :: Option < unsafe extern "C" fn ( ) -> libc :: c_int > , 
 /// Optional callback for modules that require notification of when
    /// the bdev subsystem has completed initialization.
    ///
    /// Modules are not required to define this function. 
 pub init_complete : :: std :: option :: Option < unsafe extern "C" fn ( ) > , 
 /// Optional callback for modules that require notification of when
    /// the bdev subsystem is starting the fini process.
    ///
    /// Modules are not required to define this function. 
 pub fini_start : :: std :: option :: Option < unsafe extern "C" fn ( ) > , 
 /// Finish function for the module.  Called by the spdk application
    /// after all bdevs for all modules have been unregistered.  This allows
    /// the module to do any final cleanup before the SPDK application exits.
    ///
    /// Modules are not required to define this function. 
 pub module_fini : :: std :: option :: Option < unsafe extern "C" fn ( ) > , 
 /// Function called to return a text string representing the
    /// module's configuration options for inclusion in a configuration file. 
 pub config_text : :: std :: option :: Option < unsafe extern "C" fn ( fp : * mut FILE ) > , 
 /// Function called to return a text string representing the module-level
    /// JSON RPCs required to regenerate the current configuration.  This will
    /// include module-level configuration options, or methods to construct
    /// bdevs when one RPC may generate multiple bdevs (for example, an NVMe
    /// controller with multiple namespaces).
    ///
    /// Per-bdev JSON RPCs (where one "construct" RPC always creates one bdev)
    /// may be implemented here, or by the bdev's write_config_json function -
    /// but not both.  Bdev module implementers may choose which mechanism to
    /// use based on the module's design.
    ///
    /// \return 0 on success or Bdev specific negative error code. 
 pub config_json : :: std :: option :: Option < unsafe extern "C" fn ( w : * mut spdk_json_write_ctx ) -> libc :: c_int > , 
 /// Name for the modules being defined. 
 pub name : * const libc :: c_char , 
 /// Returns the allocation size required for the backend for uses such as local
    /// command structs, local SGL, iovecs, or other user context. 
 pub get_ctx_size : :: std :: option :: Option < unsafe extern "C" fn ( ) -> libc :: c_int > , 
 /// First notification that a bdev should be examined by a virtual bdev module.
    /// Virtual bdev modules may use this to examine newly-added bdevs and automatically
    /// create their own vbdevs, but no I/O to device can be send to bdev at this point.
    /// Only vbdevs based on config files can be created here. 
 pub examine_config : :: std :: option :: Option < unsafe extern "C" fn ( bdev : * mut spdk_bdev ) > , 
 /// Second notification that a bdev should be examined by a virtual bdev module.
    /// Virtual bdev modules may use this to examine newly-added bdevs and automatically
    /// create their own vbdevs. This callback may use I/O operations end finish asynchronously. 
 pub examine_disk : :: std :: option :: Option < unsafe extern "C" fn ( bdev : * mut spdk_bdev ) > , 
 /// Denotes if the module_init function may complete asynchronously. If set to true,
    /// the module initialization has to be explicitly completed by calling
    /// spdk_bdev_module_init_done(). 
 pub async_init : bool , 
 /// Denotes if the module_fini function may complete asynchronously.
    /// If set to true finishing has to be explicitly completed by calling
    /// spdk_bdev_module_fini_done(). 
 pub async_fini : bool , pub internal : spdk_bdev_module___bdev_module_internal_fields , } 
 /// Fields that are used by the internal bdev subsystem. Bdev modules
///  must not read or write to these fields. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_module___bdev_module_internal_fields { 
 /// Count of bdev inits/examinations in progress. Used by generic bdev
    /// layer and must not be modified by bdev modules.
    ///
    /// \note Used internally by bdev subsystem, don't change this value in bdev module. 
 pub action_in_progress : u32 , pub tailq : spdk_bdev_module___bdev_module_internal_fields__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_module___bdev_module_internal_fields__bindgen_ty_1 { pub tqe_next : * mut spdk_bdev_module , pub tqe_prev : * mut * mut spdk_bdev_module , } impl Default for spdk_bdev_module___bdev_module_internal_fields__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_module___bdev_module_internal_fields { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_module { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type spdk_bdev_unregister_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , rc : libc :: c_int ) > ; 
 /// Function table for a block device backend.
///
/// The backend block device function table provides a set of APIs to allow
/// communication with a backend. The main commands are read/write API
/// calls for I/O via submit_request. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_fn_table { 
 /// Destroy the backend block device object 
 pub destruct : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void ) -> libc :: c_int > , 
 /// Process the IO. 
 pub submit_request : :: std :: option :: Option < unsafe extern "C" fn ( ch : * mut spdk_io_channel , arg1 : * mut spdk_bdev_io ) > , 
 /// Check if the block device supports a specific I/O type. 
 pub io_type_supported : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , arg1 : spdk_bdev_io_type ) -> bool > , 
 /// Get an I/O channel for the specific bdev for the calling thread. 
 pub get_io_channel : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void ) -> * mut spdk_io_channel > , 
 /// Output driver-specific information to a JSON stream. Optional - may be NULL.
    ///
    /// The JSON write context will be initialized with an open object, so the bdev
    /// driver should write a name (based on the driver name) followed by a JSON value
    /// (most likely another nested object). 
 pub dump_info_json : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , w : * mut spdk_json_write_ctx ) -> libc :: c_int > , 
 /// Output bdev-specific RPC configuration to a JSON stream. Optional - may be NULL.
    ///
    /// This function should only be implemented for bdevs which can be configured
    /// independently of other bdevs.  For example, RPCs to create a bdev for an NVMe
    /// namespace may not be generated by this function, since enumerating an NVMe
    /// namespace requires attaching to an NVMe controller, and that controller may
    /// contain multiple namespaces.  The spdk_bdev_module's config_json function should
    /// be used instead for these cases.
    ///
    /// The JSON write context will be initialized with an open object, so the bdev
    /// driver should write all data necessary to recreate this bdev by invoking
    /// constructor method. No other data should be written. 
 pub write_config_json : :: std :: option :: Option < unsafe extern "C" fn ( bdev : * mut spdk_bdev , w : * mut spdk_json_write_ctx ) > , 
 /// Get spin-time per I/O channel in microseconds.
    ///  Optional - may be NULL. 
 pub get_spin_time : :: std :: option :: Option < unsafe extern "C" fn ( ch : * mut spdk_io_channel ) -> u64 > , } impl Default for spdk_bdev_fn_table { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_bdev_io_status_SPDK_BDEV_IO_STATUS_NOMEM : spdk_bdev_io_status = -4 ; pub const spdk_bdev_io_status_SPDK_BDEV_IO_STATUS_SCSI_ERROR : spdk_bdev_io_status = -3 ; pub const spdk_bdev_io_status_SPDK_BDEV_IO_STATUS_NVME_ERROR : spdk_bdev_io_status = -2 ; pub const spdk_bdev_io_status_SPDK_BDEV_IO_STATUS_FAILED : spdk_bdev_io_status = -1 ; pub const spdk_bdev_io_status_SPDK_BDEV_IO_STATUS_PENDING : spdk_bdev_io_status = 0 ; pub const spdk_bdev_io_status_SPDK_BDEV_IO_STATUS_SUCCESS : spdk_bdev_io_status = 1 ; 
 /// bdev I/O completion status 
 pub type spdk_bdev_io_status = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_alias { pub alias : * mut libc :: c_char , pub tailq : spdk_bdev_alias__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_alias__bindgen_ty_1 { pub tqe_next : * mut spdk_bdev_alias , pub tqe_prev : * mut * mut spdk_bdev_alias , } impl Default for spdk_bdev_alias__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_alias { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct bdev_io_tailq_t { pub tqh_first : * mut spdk_bdev_io , pub tqh_last : * mut * mut spdk_bdev_io , } impl Default for bdev_io_tailq_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct bdev_io_stailq_t { pub stqh_first : * mut spdk_bdev_io , pub stqh_last : * mut * mut spdk_bdev_io , } impl Default for bdev_io_stailq_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// \brief SPDK block device.
///
/// This is a virtual representation of a block device that is exported by the backend. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_bdev { 
 /// User context passed in by the backend 
 pub ctxt : * mut libc :: c_void , 
 /// Unique name for this block device. 
 pub name : * mut libc :: c_char , 
 /// Unique aliases for this block device. 
 pub aliases : spdk_bdev_spdk_bdev_aliases_list , 
 /// Unique product name for this kind of block device. 
 pub product_name : * mut libc :: c_char , 
 /// write cache enabled, not used at the moment 
 pub write_cache : libc :: c_int , 
 /// Size in bytes of a logical block for the backend 
 pub blocklen : u32 , 
 /// Number of blocks 
 pub blockcnt : u64 , 
 /// Specifies an alignment requirement for data buffers associated with an spdk_bdev_io.
    /// 0 = no alignment requirement
    /// >0 = alignment requirement is 2 ^ required_alignment.
    /// bdev layer will automatically double buffer any spdk_bdev_io that violates this
    /// alignment, before the spdk_bdev_io is submitted to the bdev module. 
 pub required_alignment : u8 , 
 /// Specifies whether the optimal_io_boundary is mandatory or
    /// only advisory.  If set to true, the bdev layer will split
    /// READ and WRITE I/O that span the optimal_io_boundary before
    /// submitting them to the bdev module.
    ///
    /// Note that this field cannot be used to force splitting of
    /// UNMAP, WRITE_ZEROES or FLUSH I/O. 
 pub split_on_optimal_io_boundary : bool , 
 /// Optimal I/O boundary in blocks, or 0 for no value reported. 
 pub optimal_io_boundary : u32 , 
 /// UUID for this bdev.
    ///
    /// Fill with zeroes if no uuid is available. 
 pub uuid : spdk_uuid , 
 /// Pointer to the bdev module that registered this bdev. 
 pub module : * mut spdk_bdev_module , 
 /// function table for all LUN ops 
 pub fn_table : * const spdk_bdev_fn_table , pub internal : spdk_bdev___bdev_internal_fields , } 
 /// Unique aliases for this block device. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_spdk_bdev_aliases_list { pub tqh_first : * mut spdk_bdev_alias , pub tqh_last : * mut * mut spdk_bdev_alias , } impl Default for spdk_bdev_spdk_bdev_aliases_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Fields that are used internally by the bdev subsystem.  Bdev modules
///  must not read or write to these fields. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_bdev___bdev_internal_fields { 
 /// Quality of service parameters 
 pub qos : * mut spdk_bdev_qos , 
 /// True if the state of the QoS is being modified 
 pub qos_mod_in_progress : bool , 
 /// Mutex protecting claimed 
 pub mutex : pthread_mutex_t , 
 /// The bdev status 
 pub status : spdk_bdev_status , 
 /// Pointer to the module that has claimed this bdev for purposes of creating virtual
    ///  bdevs on top of it.  Set to NULL if the bdev has not been claimed. 
 pub claim_module : * mut spdk_bdev_module , 
 /// Callback function that will be called after bdev destruct is completed. 
 pub unregister_cb : spdk_bdev_unregister_cb , 
 /// Unregister call context 
 pub unregister_ctx : * mut libc :: c_void , 
 /// List of open descriptors for this block device. 
 pub open_descs : spdk_bdev___bdev_internal_fields__bindgen_ty_1 , pub link : spdk_bdev___bdev_internal_fields__bindgen_ty_2 , 
 /// points to a reset bdev_io if one is in progress. 
 pub reset_in_progress : * mut spdk_bdev_io , 
 /// poller for tracking the queue_depth of a device, NULL if not tracking 
 pub qd_poller : * mut spdk_poller , 
 /// period at which we poll for queue depth information 
 pub period : u64 , 
 /// used to aggregate queue depth while iterating across the bdev's open channels 
 pub temporary_queue_depth : u64 , 
 /// queue depth as calculated the last time the telemetry poller checked. 
 pub measured_queue_depth : u64 , 
 /// most recent value of ticks spent performing I/O. Used to calculate the weighted time doing I/O 
 pub io_time : u64 , 
 /// weighted time performing I/O. Equal to measured_queue_depth * period 
 pub weighted_io_time : u64 , 
 /// accumulated I/O statistics for previously deleted channels of this bdev 
 pub stat : spdk_bdev_io_stat , 
 /// histogram enabled on this bdev 
 pub histogram_enabled : bool , pub histogram_in_progress : bool , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev___bdev_internal_fields__bindgen_ty_1 { pub tqh_first : * mut spdk_bdev_desc , pub tqh_last : * mut * mut spdk_bdev_desc , } impl Default for spdk_bdev___bdev_internal_fields__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev___bdev_internal_fields__bindgen_ty_2 { pub tqe_next : * mut spdk_bdev , pub tqe_prev : * mut * mut spdk_bdev , } impl Default for spdk_bdev___bdev_internal_fields__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev___bdev_internal_fields { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type spdk_bdev_io_get_buf_cb = :: std :: option :: Option < unsafe extern "C" fn ( ch : * mut spdk_io_channel , bdev_io : * mut spdk_bdev_io ) > ; 
 /// Block device I/O
///
/// This is an I/O that is passed to an spdk_bdev. 
 # [ repr ( C ) ] pub struct spdk_bdev_io { 
 /// The block device that this I/O belongs to. 
 pub bdev : * mut spdk_bdev , 
 /// Enumerated value representing the I/O type. 
 pub type_ : u8 , 
 /// A single iovec element for use by this bdev_io. 
 pub iov : iovec , 
 /// Array of iovecs used for I/O splitting. 
 pub child_iov : [ iovec ; 32usize ] , pub u : spdk_bdev_io__bindgen_ty_1 , 
 /// It may be used by modules to put the bdev_io into its own list. 
 pub module_link : spdk_bdev_io__bindgen_ty_2 , pub internal : spdk_bdev_io___bdev_io_internal_fields , 
 /// Per I/O context for use by the bdev module. 
 pub driver_ctx : __IncompleteArrayField < u8 > , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_bdev_io__bindgen_ty_1 { pub bdev : spdk_bdev_io__bindgen_ty_1__bindgen_ty_1 , pub reset : spdk_bdev_io__bindgen_ty_1__bindgen_ty_2 , pub nvme_passthru : spdk_bdev_io__bindgen_ty_1__bindgen_ty_3 , _bindgen_union_align : [ u64 ; 12usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io__bindgen_ty_1__bindgen_ty_1 { 
 /// For SG buffer cases, array of iovecs to transfer. 
 pub iovs : * mut iovec , 
 /// For SG buffer cases, number of iovecs in iovec array. 
 pub iovcnt : libc :: c_int , 
 /// Total size of data to be transferred. 
 pub num_blocks : u64 , 
 /// Starting offset (in blocks) of the bdev for this I/O. 
 pub offset_blocks : u64 , 
 /// stored user callback in case we split the I/O and use a temporary callback 
 pub stored_user_cb : spdk_bdev_io_completion_cb , 
 /// number of blocks remaining in a split i/o 
 pub split_remaining_num_blocks : u64 , 
 /// current offset of the split I/O in the bdev 
 pub split_current_offset_blocks : u64 , 
 /// count of outstanding batched split I/Os 
 pub split_outstanding : u32 , } impl Default for spdk_bdev_io__bindgen_ty_1__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io__bindgen_ty_1__bindgen_ty_2 { 
 /// Channel reference held while messages for this reset are in progress. 
 pub ch_ref : * mut spdk_io_channel , } impl Default for spdk_bdev_io__bindgen_ty_1__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_bdev_io__bindgen_ty_1__bindgen_ty_3 { pub cmd : spdk_nvme_cmd , pub buf : * mut libc :: c_void , pub nbytes : usize , pub md_buf : * mut libc :: c_void , pub md_len : usize , } impl Default for spdk_bdev_io__bindgen_ty_1__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_io__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io__bindgen_ty_2 { pub tqe_next : * mut spdk_bdev_io , pub tqe_prev : * mut * mut spdk_bdev_io , } impl Default for spdk_bdev_io__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 ///  Fields that are used internally by the bdev subsystem.  Bdev modules
///  must not read or write to these fields. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_bdev_io___bdev_io_internal_fields { 
 /// The bdev I/O channel that this was handled on. 
 pub ch : * mut spdk_bdev_channel , 
 /// The bdev I/O channel that this was submitted on. 
 pub io_submit_ch : * mut spdk_bdev_channel , 
 /// The bdev descriptor that was used when submitting this I/O. 
 pub desc : * mut spdk_bdev_desc , 
 /// User function that will be called when this completes 
 pub cb : spdk_bdev_io_completion_cb , 
 /// Context that will be passed to the completion callback 
 pub caller_ctx : * mut libc :: c_void , 
 /// Current tsc at submit time. Used to calculate latency at completion. 
 pub submit_tsc : u64 , pub error : spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_1 , 
 /// Set to true while the bdev module submit_request function is in progress.
    ///
    /// This is used to decide whether spdk_bdev_io_complete() can complete the I/O directly
    /// or if completion must be deferred via an event. 
 pub in_submit_request : bool , 
 /// Status for the IO 
 pub status : i8 , 
 /// bdev allocated memory associated with this request 
 pub buf : * mut libc :: c_void , 
 /// requested size of the buffer associated with this I/O 
 pub buf_len : u64 , 
 /// if the request is double buffered, store original request iovs here 
 pub bounce_iov : iovec , pub orig_iovs : * mut iovec , pub orig_iovcnt : libc :: c_int , 
 /// Callback for when buf is allocated 
 pub get_buf_cb : spdk_bdev_io_get_buf_cb , 
 /// Member used for linking child I/Os together. 
 pub link : spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_2 , 
 /// Entry to the list need_buf of struct spdk_bdev. 
 pub buf_link : spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_3 , 
 /// Enables queuing parent I/O when no bdev_ios available for split children. 
 pub waitq_entry : spdk_bdev_io_wait_entry , } 
 /// Error information from a device 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_1 { pub nvme : spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_1__bindgen_ty_1 , pub scsi : spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_1__bindgen_ty_2 , _bindgen_union_align : [ u8 ; 4usize ] , } 
 /// Only valid when status is SPDK_BDEV_IO_STATUS_NVME_ERROR 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_1__bindgen_ty_1 { 
 /// NVMe status code type 
 pub sct : u8 , 
 /// NVMe status code 
 pub sc : u8 , } 
 /// Only valid when status is SPDK_BDEV_IO_STATUS_SCSI_ERROR 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_1__bindgen_ty_2 { 
 /// SCSI status code 
 pub sc : u8 , 
 /// SCSI sense key 
 pub sk : u8 , 
 /// SCSI additional sense code 
 pub asc : u8 , 
 /// SCSI additional sense code qualifier 
 pub ascq : u8 , } impl Default for spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_2 { pub tqe_next : * mut spdk_bdev_io , pub tqe_prev : * mut * mut spdk_bdev_io , } impl Default for spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_3 { pub stqe_next : * mut spdk_bdev_io , } impl Default for spdk_bdev_io___bdev_io_internal_fields__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_io___bdev_io_internal_fields { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_io { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Register a new bdev.
///
/// \param bdev Block device to register.
///
/// \return 0 on success.
/// \return -EINVAL if the bdev name is NULL.
/// \return -EEXIST if a bdev or bdev alias with the same name already exists. 
 pub fn spdk_bdev_register ( bdev : * mut spdk_bdev ) -> libc :: c_int ; } extern "C" { 
 /// Unregister a bdev
///
/// \param bdev Block device to unregister.
/// \param cb_fn Callback function to be called when the unregister is complete.
/// \param cb_arg Argument to be supplied to cb_fn 
 pub fn spdk_bdev_unregister ( bdev : * mut spdk_bdev , cb_fn : spdk_bdev_unregister_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Invokes the unregister callback of a bdev backing a virtual bdev.
///
/// A Bdev with an asynchronous destruct path should return 1 from its
/// destruct function and call this function at the conclusion of that path.
/// Bdevs with synchronous destruct paths should return 0 from their destruct
/// path.
///
/// \param bdev Block device that was destroyed.
/// \param bdeverrno Error code returned from bdev's destruct callback. 
 pub fn spdk_bdev_destruct_done ( bdev : * mut spdk_bdev , bdeverrno : libc :: c_int ) ; } extern "C" { 
 /// Register a virtual bdev.
///
/// \param vbdev Virtual bdev to register.
/// \param base_bdevs Array of bdevs upon which this vbdev is based.
/// \param base_bdev_count Number of bdevs in base_bdevs.
///
/// \return 0 on success
/// \return -EINVAL if the bdev name is NULL.
/// \return -EEXIST if the bdev already exists.
/// \return -ENOMEM if allocation of the base_bdevs array or the base bdevs vbdevs array fails. 
 pub fn spdk_vbdev_register ( vbdev : * mut spdk_bdev , base_bdevs : * mut * mut spdk_bdev , base_bdev_count : libc :: c_int ) -> libc :: c_int ; } extern "C" { 
 /// Indicate to the bdev layer that the module is done examining a bdev.
///
/// To be called synchronously or asynchronously in response to the
/// module's examine function being called.
///
/// \param module Pointer to the module completing the examination. 
 pub fn spdk_bdev_module_examine_done ( module : * mut spdk_bdev_module ) ; } extern "C" { 
 /// Indicate to the bdev layer that the module is done initializing.
///
/// To be called synchronously or asynchronously in response to the
/// module_init function being called.
///
/// \param module Pointer to the module completing the initialization. 
 pub fn spdk_bdev_module_init_done ( module : * mut spdk_bdev_module ) ; } extern "C" { 
 /// Indicate to the bdev layer that the module is done cleaning up.
///
/// To be called either synchronously or asynchronously
/// in response to the module_fini function being called.
/// 
 pub fn spdk_bdev_module_finish_done ( ) ; } extern "C" { 
 /// Called by a bdev module to lay exclusive write claim to a bdev.
///
/// Also upgrades that bdev's descriptor to have write access.
///
/// \param bdev Block device to be claimed.
/// \param desc Descriptor for the above block device.
/// \param module Bdev module attempting to claim bdev.
///
/// \return 0 on success
/// \return -EPERM if the bdev is already claimed by another module. 
 pub fn spdk_bdev_module_claim_bdev ( bdev : * mut spdk_bdev , desc : * mut spdk_bdev_desc , module : * mut spdk_bdev_module ) -> libc :: c_int ; } extern "C" { 
 /// Called to release a write claim on a block device.
///
/// \param bdev Block device to be released. 
 pub fn spdk_bdev_module_release_bdev ( bdev : * mut spdk_bdev ) ; } extern "C" { 
 /// Add alias to block device names list.
/// Aliases can be add only to registered bdev.
///
/// \param bdev Block device to query.
/// \param alias Alias to be added to list.
///
/// \return 0 on success
/// \return -EEXIST if alias already exists as name or alias on any bdev
/// \return -ENOMEM if memory cannot be allocated to store alias
/// \return -EINVAL if passed alias is empty 
 pub fn spdk_bdev_alias_add ( bdev : * mut spdk_bdev , alias : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Removes name from block device names list.
///
/// \param bdev Block device to query.
/// \param alias Alias to be deleted from list.
/// \return 0 on success
/// \return -ENOENT if alias does not exists 
 pub fn spdk_bdev_alias_del ( bdev : * mut spdk_bdev , alias : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Removes all alias from block device alias list.
///
/// \param bdev Block device to operate. 
 pub fn spdk_bdev_alias_del_all ( bdev : * mut spdk_bdev ) ; } extern "C" { 
 /// Get pointer to block device aliases list.
///
/// \param bdev Block device to query.
/// \return Pointer to bdev aliases list. 
 pub fn spdk_bdev_get_aliases ( bdev : * const spdk_bdev ) -> * const spdk_bdev_spdk_bdev_aliases_list ; } extern "C" { 
 /// Allocate a buffer for given bdev_io.  Allocation will happen
/// only if the bdev_io has no assigned SGL yet or SGL is not
/// aligned to \c bdev->required_alignment.  If SGL is not aligned,
/// this call will cause copy from SGL to bounce buffer on write
/// path or copy from bounce buffer to SGL before completion
/// callback on read path.  The buffer will be freed automatically
/// on \c spdk_bdev_free_io() call. This call will never fail.
/// In case of lack of memory given callback \c cb will be deferred
/// until enough memory is freed.
///
/// \param bdev_io I/O to allocate buffer for.
/// \param cb callback to be called when the buffer is allocated
/// or the bdev_io has an SGL assigned already.
/// \param len size of the buffer to allocate. In case the bdev_io
/// doesn't have an SGL assigned this field must be no bigger than
/// \c SPDK_BDEV_LARGE_BUF_MAX_SIZE. 
 pub fn spdk_bdev_io_get_buf ( bdev_io : * mut spdk_bdev_io , cb : spdk_bdev_io_get_buf_cb , len : u64 ) ; } extern "C" { 
 /// Set the given buffer as the data buffer described by this bdev_io.
///
/// The portion of the buffer used may be adjusted for memory alignement
/// purposes.
///
/// \param bdev_io I/O to set the buffer on.
/// \param buf The buffer to set as the active data buffer.
/// \param len The length of the buffer.
/// 
 pub fn spdk_bdev_io_set_buf ( bdev_io : * mut spdk_bdev_io , buf : * mut libc :: c_void , len : usize ) ; } extern "C" { 
 /// Complete a bdev_io
///
/// \param bdev_io I/O to complete.
/// \param status The I/O completion status. 
 pub fn spdk_bdev_io_complete ( bdev_io : * mut spdk_bdev_io , status : spdk_bdev_io_status ) ; } extern "C" { 
 /// Complete a bdev_io with an NVMe status code.
///
/// \param bdev_io I/O to complete.
/// \param sct NVMe Status Code Type.
/// \param sc NVMe Status Code. 
 pub fn spdk_bdev_io_complete_nvme_status ( bdev_io : * mut spdk_bdev_io , sct : libc :: c_int , sc : libc :: c_int ) ; } extern "C" { 
 /// Complete a bdev_io with a SCSI status code.
///
/// \param bdev_io I/O to complete.
/// \param sc SCSI Status Code.
/// \param sk SCSI Sense Key.
/// \param asc SCSI Additional Sense Code.
/// \param ascq SCSI Additional Sense Code Qualifier. 
 pub fn spdk_bdev_io_complete_scsi_status ( bdev_io : * mut spdk_bdev_io , sc : spdk_scsi_status , sk : spdk_scsi_sense , asc : u8 , ascq : u8 ) ; } extern "C" { 
 /// Get a thread that given bdev_io was submitted on.
///
/// \param bdev_io I/O
/// \return thread that submitted the I/O 
 pub fn spdk_bdev_io_get_thread ( bdev_io : * mut spdk_bdev_io ) -> * mut spdk_thread ; } extern "C" { 
 /// Resize for a bdev.
///
/// Change number of blocks for provided block device.
/// It can only be called on a registered bdev.
///
/// \param bdev Block device to change.
/// \param size New size of bdev.
/// \return 0 on success, negated errno on failure. 
 pub fn spdk_bdev_notify_blockcnt_change ( bdev : * mut spdk_bdev , size : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Translates NVMe status codes to SCSI status information.
///
/// The codes are stored in the user supplied integers.
///
/// \param bdev_io I/O containing status codes to translate.
/// \param sc SCSI Status Code will be stored here.
/// \param sk SCSI Sense Key will be stored here.
/// \param asc SCSI Additional Sense Code will be stored here.
/// \param ascq SCSI Additional Sense Code Qualifier will be stored here. 
 pub fn spdk_scsi_nvme_translate ( bdev_io : * const spdk_bdev_io , sc : * mut libc :: c_int , sk : * mut libc :: c_int , asc : * mut libc :: c_int , ascq : * mut libc :: c_int ) ; } extern "C" { 
 /// Add the given module to the list of registered modules.
/// This function should be invoked by referencing the macro
/// SPDK_BDEV_MODULE_REGISTER in the module c file.
///
/// \param bdev_module Module to be added. 
 pub fn spdk_bdev_module_list_add ( bdev_module : * mut spdk_bdev_module ) ; } extern "C" { 
 /// Find registered module with name pointed by \c name.
///
/// \param name name of module to be searched for.
/// \return pointer to module or NULL if no module with \c name exist 
 pub fn spdk_bdev_module_list_find ( name : * const libc :: c_char ) -> * mut spdk_bdev_module ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_part_base { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Returns a pointer to the spdk_bdev associated with an spdk_bdev_part_base
///
/// \param part_base A pointer to an spdk_bdev_part_base object.
///
/// \return A pointer to the base's spdk_bdev struct. 
 pub fn spdk_bdev_part_base_get_bdev ( part_base : * mut spdk_bdev_part_base ) -> * mut spdk_bdev ; } extern "C" { 
 /// Returns a pointer to the spdk_bdev_descriptor associated with an spdk_bdev_part_base
///
/// \param part_base A pointer to an spdk_bdev_part_base object.
///
/// \return A pointer to the base's spdk_bdev_desc struct. 
 pub fn spdk_bdev_part_base_get_desc ( part_base : * mut spdk_bdev_part_base ) -> * mut spdk_bdev_desc ; } extern "C" { 
 /// Returns a pointer to the tailq associated with an spdk_bdev_part_base
///
/// \param part_base A pointer to an spdk_bdev_part_base object.
///
/// \return The head of a tailq of spdk_bdev_part structs registered to the base's module. 
 pub fn spdk_bdev_part_base_get_tailq ( part_base : * mut spdk_bdev_part_base ) -> * mut bdev_part_tailq ; } extern "C" { 
 /// Returns a pointer to the module level context associated with an spdk_bdev_part_base
///
/// \param part_base A pointer to an spdk_bdev_part_base object.
///
/// \return A pointer to the module level context registered with the base in spdk_bdev_part_base_construct. 
 pub fn spdk_bdev_part_base_get_ctx ( part_base : * mut spdk_bdev_part_base ) -> * mut libc :: c_void ; } pub type spdk_bdev_part_base_free_fn = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void ) > ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_bdev_part { pub tailq : spdk_bdev_part__bindgen_ty_1 , pub internal : spdk_bdev_part_bdev_part_internal_fields , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_part__bindgen_ty_1 { pub tqe_next : * mut spdk_bdev_part , pub tqe_prev : * mut * mut spdk_bdev_part , } impl Default for spdk_bdev_part__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Fields that are used internally by part.c These fields should only
/// be accessed from a module using any pertinent get and set methods. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_bdev_part_bdev_part_internal_fields { pub bdev : spdk_bdev , pub base : * mut spdk_bdev_part_base , pub offset_blocks : u64 , } impl Default for spdk_bdev_part_bdev_part_internal_fields { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_bdev_part { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_part_channel { pub part : * mut spdk_bdev_part , pub base_ch : * mut spdk_io_channel , } impl Default for spdk_bdev_part_channel { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct bdev_part_tailq { pub tqh_first : * mut spdk_bdev_part , pub tqh_last : * mut * mut spdk_bdev_part , } impl Default for bdev_part_tailq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type SPDK_BDEV_PART_TAILQ = bdev_part_tailq ; extern "C" { 
 /// Free the base corresponding to one or more spdk_bdev_part.
///
/// \param base The base to free. 
 pub fn spdk_bdev_part_base_free ( base : * mut spdk_bdev_part_base ) ; } extern "C" { 
 /// Free an spdk_bdev_part context.
///
/// \param part The part to free.
///
/// \return 1 always. To indicate that the operation is asynchronous. 
 pub fn spdk_bdev_part_free ( part : * mut spdk_bdev_part ) -> libc :: c_int ; } extern "C" { 
 /// Calls spdk_bdev_unregister on the bdev for each part associated with base_bdev.
///
/// \param part_base The part base object built on top of an spdk_bdev
/// \param tailq The list of spdk_bdev_part bdevs associated with this base bdev. 
 pub fn spdk_bdev_part_base_hotremove ( part_base : * mut spdk_bdev_part_base , tailq : * mut bdev_part_tailq ) ; } extern "C" { 
 /// Construct a new spdk_bdev_part_base on top of the provided bdev.
///
/// \param bdev The spdk_bdev upon which this base will be built.
/// \param remove_cb Function to be called upon hotremove of the bdev.
/// \param module The module to which this bdev base belongs.
/// \param fn_table Function table for communicating with the bdev backend.
/// \param tailq The head of the list of all spdk_bdev_part structures registered to this base's module.
/// \param free_fn User provided function to free base related context upon bdev removal or shutdown.
/// \param ctx Module specific context for this bdev part base.
/// \param channel_size Channel size in bytes.
/// \param ch_create_cb Called after a new channel is allocated.
/// \param ch_destroy_cb Called upon channel deletion.
///
/// \return 0 on success
/// \return -1 if the underlying bdev cannot be opened. 
 pub fn spdk_bdev_part_base_construct ( bdev : * mut spdk_bdev , remove_cb : spdk_bdev_remove_cb_t , module : * mut spdk_bdev_module , fn_table : * mut spdk_bdev_fn_table , tailq : * mut bdev_part_tailq , free_fn : spdk_bdev_part_base_free_fn , ctx : * mut libc :: c_void , channel_size : u32 , ch_create_cb : spdk_io_channel_create_cb , ch_destroy_cb : spdk_io_channel_destroy_cb ) -> * mut spdk_bdev_part_base ; } extern "C" { 
 /// Create a logical spdk_bdev_part on top of a base.
///
/// \param part The part object allocated by the user.
/// \param base The base from which to create the part.
/// \param name The name of the new spdk_bdev_part.
/// \param offset_blocks The offset into the base bdev at which this part begins.
/// \param num_blocks The number of blocks that this part will span.
/// \param product_name Unique name for this type of block device.
///
/// \return 0 on success.
/// \return -1 if the bases underlying bdev cannot be claimed by the current module. 
 pub fn spdk_bdev_part_construct ( part : * mut spdk_bdev_part , base : * mut spdk_bdev_part_base , name : * mut libc :: c_char , offset_blocks : u64 , num_blocks : u64 , product_name : * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Forwards I/O from an spdk_bdev_part to the underlying base bdev.
///
/// This function will apply the offset_blocks the user provided to
/// spdk_bdev_part_construct to the I/O. The user should not manually
/// apply this offset before submitting any I/O through this function.
///
/// \param ch The I/O channel associated with the spdk_bdev_part.
/// \param bdev_io The I/O to be submitted to the underlying bdev.
/// \return 0 on success or non-zero if submit request failed. 
 pub fn spdk_bdev_part_submit_request ( ch : * mut spdk_bdev_part_channel , bdev_io : * mut spdk_bdev_io ) -> libc :: c_int ; } extern "C" { 
 /// Return a pointer to this part's spdk_bdev.
///
/// \param part An spdk_bdev_part object.
///
/// \return A pointer to this part's spdk_bdev object. 
 pub fn spdk_bdev_part_get_bdev ( part : * mut spdk_bdev_part ) -> * mut spdk_bdev ; } extern "C" { 
 /// Return a pointer to this part's base.
///
/// \param part An spdk_bdev_part object.
///
/// \return A pointer to this part's spdk_bdev_part_base object. 
 pub fn spdk_bdev_part_get_base ( part : * mut spdk_bdev_part ) -> * mut spdk_bdev_part_base ; } extern "C" { 
 /// Return a pointer to this part's base bdev.
///
/// The return value of this function is equivalent to calling
/// spdk_bdev_part_base_get_bdev on this part's base.
///
/// \param part An spdk_bdev_part object.
///
/// \return A pointer to the bdev belonging to this part's base. 
 pub fn spdk_bdev_part_get_base_bdev ( part : * mut spdk_bdev_part ) -> * mut spdk_bdev ; } extern "C" { 
 /// Return this part's offset from the beginning of the base bdev.
///
/// This function should not be called in the I/O path. Any block
/// translations to I/O will be handled in spdk_bdev_part_submit_request.
///
/// \param part An spdk_bdev_part object.
///
/// \return the block offset of this part from it's underlying bdev. 
 pub fn spdk_bdev_part_get_offset_blocks ( part : * mut spdk_bdev_part ) -> u64 ; } 
 /// Variable-length bit array. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bit_array { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Return the number of bits that a bit array is currently sized to hold.
///
/// \param ba Bit array to query.
///
/// \return the number of bits. 
 pub fn spdk_bit_array_capacity ( ba : * const spdk_bit_array ) -> u32 ; } extern "C" { 
 /// Create a bit array.
///
/// \param num_bits Number of bits that the bit array is sized to hold.
///
/// All bits in the array will be cleared.
///
/// \return a pointer to the new bit array. 
 pub fn spdk_bit_array_create ( num_bits : u32 ) -> * mut spdk_bit_array ; } extern "C" { 
 /// Free a bit array and set the pointer to NULL.
///
/// \param bap Bit array to free. 
 pub fn spdk_bit_array_free ( bap : * mut * mut spdk_bit_array ) ; } extern "C" { 
 /// Create or resize a bit array.
///
/// To create a new bit array, pass a pointer to a spdk_bit_array pointer that is
/// NULL for bap.
///
/// The bit array will be sized to hold at least num_bits.
///
/// If num_bits is smaller than the previous size of the bit array,
/// any data beyond the new num_bits size will be cleared.
///
/// If num_bits is larger than the previous size of the bit array,
/// any data beyond the old num_bits size will be cleared.
///
/// \param bap Bit array to create/resize.
/// \param num_bits Number of bits that the bit array is sized to hold.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_bit_array_resize ( bap : * mut * mut spdk_bit_array , num_bits : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Get the value of a bit from the bit array.
///
/// If bit_index is beyond the end of the current size of the bit array, this
/// function will return false (i.e. bits beyond the end of the array are implicitly 0).
///
/// \param ba Bit array to query.
/// \param bit_index The index of a bit to query.
///
/// \return the value of a bit from the bit array on success, or false on failure. 
 pub fn spdk_bit_array_get ( ba : * const spdk_bit_array , bit_index : u32 ) -> bool ; } extern "C" { 
 /// Set (to 1) a bit in the bit array.
///
/// If bit_index is beyond the end of the bit array, this function will return -EINVAL.
///
/// \param ba Bit array to set a bit.
/// \param bit_index The index of a bit to set.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_bit_array_set ( ba : * mut spdk_bit_array , bit_index : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Clear (to 0) a bit in the bit array.
///
/// If bit_index is beyond the end of the bit array, no action is taken. Bits
/// beyond the end of the bit array are implicitly 0.
///
/// \param ba Bit array to clear a bit.
/// \param bit_index The index of a bit to clear. 
 pub fn spdk_bit_array_clear ( ba : * mut spdk_bit_array , bit_index : u32 ) ; } extern "C" { 
 /// Find the index of the first set bit in the array.
///
/// \param ba The bit array to search.
/// \param start_bit_index The bit index from which to start searching (0 to start
/// from the beginning of the array).
///
/// \return the index of the first set bit. If no bits are set, returns UINT32_MAX. 
 pub fn spdk_bit_array_find_first_set ( ba : * const spdk_bit_array , start_bit_index : u32 ) -> u32 ; } extern "C" { 
 /// Find the index of the first cleared bit in the array.
///
/// \param ba The bit array to search.
/// \param start_bit_index The bit index from which to start searching (0 to start
/// from the beginning of the array).
///
/// \return the index of the first cleared bit. If no bits are cleared, returns UINT32_MAX. 
 pub fn spdk_bit_array_find_first_clear ( ba : * const spdk_bit_array , start_bit_index : u32 ) -> u32 ; } extern "C" { 
 /// Count the number of set bits in the array.
///
/// \param ba The bit array to search.
///
/// \return the number of bits set in the array. 
 pub fn spdk_bit_array_count_set ( ba : * const spdk_bit_array ) -> u32 ; } extern "C" { 
 /// Count the number of cleared bits in the array.
///
/// \param ba The bit array to search.
///
/// \return the number of bits cleared in the array. 
 pub fn spdk_bit_array_count_clear ( ba : * const spdk_bit_array ) -> u32 ; } extern "C" { 
 /// Store bitmask from bit array.
///
/// \param ba Bit array.
/// \param mask Destination mask. Mask and bit array capacity must be equal. 
 pub fn spdk_bit_array_store_mask ( ba : * const spdk_bit_array , mask : * mut libc :: c_void ) ; } extern "C" { 
 /// Load bitmask to bit array.
///
/// \param ba Bit array.
/// \param mask Source mask. Mask and bit array capacity must be equal. 
 pub fn spdk_bit_array_load_mask ( ba : * mut spdk_bit_array , mask : * const libc :: c_void ) ; } extern "C" { 
 /// Clear (to 0) bit array bitmask.
///
/// \param ba Bit array. 
 pub fn spdk_bit_array_clear_mask ( ba : * mut spdk_bit_array ) ; } extern "C" { 
 /// Create a blobstore block device from a bdev.
///
/// \param bdev Bdev to use.
/// \param remove_cb Called when the block device is removed.
/// \param remove_ctx Argument passed to function remove_cb.
///
/// \return a pointer to the blobstore block device on success or NULL otherwise. 
 pub fn spdk_bdev_create_bs_dev ( bdev : * mut spdk_bdev , remove_cb : spdk_bdev_remove_cb_t , remove_ctx : * mut libc :: c_void ) -> * mut spdk_bs_dev ; } extern "C" { 
 /// Claim the bdev module for the given blobstore.
///
/// \param bs_dev Blobstore block device.
/// \param module Bdev module to claim.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_bs_bdev_claim ( bs_dev : * mut spdk_bs_dev , module : * mut spdk_bdev_module ) -> libc :: c_int ; } pub type spdk_blob_id = u64 ; pub const blob_clear_method_BLOB_CLEAR_WITH_DEFAULT : blob_clear_method = 0 ; pub const blob_clear_method_BLOB_CLEAR_WITH_NONE : blob_clear_method = 1 ; pub const blob_clear_method_BLOB_CLEAR_WITH_UNMAP : blob_clear_method = 2 ; pub const blob_clear_method_BLOB_CLEAR_WITH_WRITE_ZEROES : blob_clear_method = 3 ; pub type blob_clear_method = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob_store { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_xattr_names { _unused : [ u8 ; 0 ] , } pub type spdk_bs_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , bserrno : libc :: c_int ) > ; pub type spdk_bs_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , bs : * mut spdk_blob_store , bserrno : libc :: c_int ) > ; pub type spdk_blob_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , bserrno : libc :: c_int ) > ; pub type spdk_blob_op_with_id_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , blobid : spdk_blob_id , bserrno : libc :: c_int ) > ; pub type spdk_blob_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , blb : * mut spdk_blob , bserrno : libc :: c_int ) > ; pub type spdk_bs_dev_cpl = :: std :: option :: Option < unsafe extern "C" fn ( channel : * mut spdk_io_channel , cb_arg : * mut libc :: c_void , bserrno : libc :: c_int ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bs_dev_cb_args { pub cb_fn : spdk_bs_dev_cpl , pub channel : * mut spdk_io_channel , pub cb_arg : * mut libc :: c_void , } impl Default for spdk_bs_dev_cb_args { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bs_dev { pub create_channel : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev ) -> * mut spdk_io_channel > , pub destroy_channel : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel ) > , pub destroy : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev ) > , pub read : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub write : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub readv : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub writev : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub flush : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , cb_args : * mut spdk_bs_dev_cb_args ) > , pub write_zeroes : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub unmap : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_bs_dev , channel : * mut spdk_io_channel , lba : u64 , lba_count : u32 , cb_args : * mut spdk_bs_dev_cb_args ) > , pub blockcnt : u64 , pub blocklen : u32 , } impl Default for spdk_bs_dev { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bs_type { pub bstype : [ libc :: c_char ; 16usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bs_opts { pub cluster_sz : u32 , pub num_md_pages : u32 , pub max_md_ops : u32 , pub max_channel_ops : u32 , pub bstype : spdk_bs_type , pub iter_cb_fn : spdk_blob_op_with_handle_complete , pub iter_cb_arg : * mut libc :: c_void , } impl Default for spdk_bs_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_bs_opts_init ( opts : * mut spdk_bs_opts ) ; } extern "C" { pub fn spdk_bs_load ( dev : * mut spdk_bs_dev , opts : * mut spdk_bs_opts , cb_fn : spdk_bs_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_init ( dev : * mut spdk_bs_dev , opts : * mut spdk_bs_opts , cb_fn : spdk_bs_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } pub type spdk_bs_dump_print_xattr = :: std :: option :: Option < unsafe extern "C" fn ( fp : * mut FILE , bstype : * const libc :: c_char , name : * const libc :: c_char , value : * const libc :: c_void , value_length : usize ) > ; extern "C" { pub fn spdk_bs_dump ( dev : * mut spdk_bs_dev , fp : * mut FILE , print_xattr_fn : spdk_bs_dump_print_xattr , cb_fn : spdk_bs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_destroy ( bs : * mut spdk_blob_store , cb_fn : spdk_bs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_unload ( bs : * mut spdk_blob_store , cb_fn : spdk_bs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_set_super ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , cb_fn : spdk_bs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_get_super ( bs : * mut spdk_blob_store , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_get_cluster_size ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { pub fn spdk_bs_get_page_size ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { pub fn spdk_bs_get_io_unit_size ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { pub fn spdk_bs_free_cluster_count ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { pub fn spdk_bs_total_data_cluster_count ( bs : * mut spdk_blob_store ) -> u64 ; } extern "C" { pub fn spdk_blob_get_id ( blob : * mut spdk_blob ) -> spdk_blob_id ; } extern "C" { pub fn spdk_blob_get_num_pages ( blob : * mut spdk_blob ) -> u64 ; } extern "C" { pub fn spdk_blob_get_num_io_units ( blob : * mut spdk_blob ) -> u64 ; } extern "C" { pub fn spdk_blob_get_num_clusters ( blob : * mut spdk_blob ) -> u64 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob_xattr_opts { pub count : usize , pub names : * mut * mut libc :: c_char , pub ctx : * mut libc :: c_void , pub get_value : :: std :: option :: Option < unsafe extern "C" fn ( xattr_ctx : * mut libc :: c_void , name : * const libc :: c_char , value : * mut * const libc :: c_void , value_len : * mut usize ) > , } impl Default for spdk_blob_xattr_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob_opts { pub num_clusters : u64 , pub thin_provision : bool , pub xattrs : spdk_blob_xattr_opts , } impl Default for spdk_blob_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_blob_opts_init ( opts : * mut spdk_blob_opts ) ; } extern "C" { pub fn spdk_bs_create_blob_ext ( bs : * mut spdk_blob_store , opts : * const spdk_blob_opts , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_create_blob ( bs : * mut spdk_blob_store , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_create_snapshot ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , snapshot_xattrs : * const spdk_blob_xattr_opts , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_create_clone ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , clone_xattrs : * const spdk_blob_xattr_opts , cb_fn : spdk_blob_op_with_id_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_get_clones ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , ids : * mut spdk_blob_id , count : * mut usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_blob_get_parent_snapshot ( bs : * mut spdk_blob_store , blobid : spdk_blob_id ) -> spdk_blob_id ; } extern "C" { pub fn spdk_blob_is_read_only ( blob : * mut spdk_blob ) -> bool ; } extern "C" { pub fn spdk_blob_is_snapshot ( blob : * mut spdk_blob ) -> bool ; } extern "C" { pub fn spdk_blob_is_clone ( blob : * mut spdk_blob ) -> bool ; } extern "C" { pub fn spdk_blob_is_thin_provisioned ( blob : * mut spdk_blob ) -> bool ; } extern "C" { pub fn spdk_bs_delete_blob ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_inflate_blob ( bs : * mut spdk_blob_store , channel : * mut spdk_io_channel , blobid : spdk_blob_id , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_blob_decouple_parent ( bs : * mut spdk_blob_store , channel : * mut spdk_io_channel , blobid : spdk_blob_id , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_blob_open_opts { pub clear_method : blob_clear_method , } impl Default for spdk_blob_open_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_blob_open_opts_init ( opts : * mut spdk_blob_open_opts ) ; } extern "C" { pub fn spdk_bs_open_blob ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , cb_fn : spdk_blob_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_open_blob_ext ( bs : * mut spdk_blob_store , blobid : spdk_blob_id , opts : * mut spdk_blob_open_opts , cb_fn : spdk_blob_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_resize ( blob : * mut spdk_blob , sz : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_set_read_only ( blob : * mut spdk_blob ) -> libc :: c_int ; } extern "C" { pub fn spdk_blob_sync_md ( blob : * mut spdk_blob , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_close ( blob : * mut spdk_blob , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_alloc_io_channel ( bs : * mut spdk_blob_store ) -> * mut spdk_io_channel ; } extern "C" { pub fn spdk_bs_free_io_channel ( channel : * mut spdk_io_channel ) ; } extern "C" { pub fn spdk_blob_io_write ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_io_read ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_io_writev ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_io_readv ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_io_unmap ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_io_write_zeroes ( blob : * mut spdk_blob , channel : * mut spdk_io_channel , offset : u64 , length : u64 , cb_fn : spdk_blob_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_iter_first ( bs : * mut spdk_blob_store , cb_fn : spdk_blob_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_bs_iter_next ( bs : * mut spdk_blob_store , blob : * mut spdk_blob , cb_fn : spdk_blob_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_blob_set_xattr ( blob : * mut spdk_blob , name : * const libc :: c_char , value : * const libc :: c_void , value_len : u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_blob_remove_xattr ( blob : * mut spdk_blob , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_blob_get_xattr_value ( blob : * mut spdk_blob , name : * const libc :: c_char , value : * mut * const libc :: c_void , value_len : * mut usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_blob_get_xattr_names ( blob : * mut spdk_blob , names : * mut * mut spdk_xattr_names ) -> libc :: c_int ; } extern "C" { pub fn spdk_xattr_names_get_count ( names : * mut spdk_xattr_names ) -> u32 ; } extern "C" { pub fn spdk_xattr_names_get_name ( names : * mut spdk_xattr_names , index : u32 ) -> * const libc :: c_char ; } extern "C" { pub fn spdk_xattr_names_free ( names : * mut spdk_xattr_names ) ; } extern "C" { pub fn spdk_bs_get_bstype ( bs : * mut spdk_blob_store ) -> spdk_bs_type ; } extern "C" { pub fn spdk_bs_set_bstype ( bs : * mut spdk_blob_store , bstype : spdk_bs_type ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_file { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_filesystem { _unused : [ u8 ; 0 ] , } pub type spdk_fs_iter = * mut spdk_file ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_blobfs_opts { pub cluster_sz : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_file_stat { pub blobid : spdk_blob_id , pub size : u64 , } 
 /// Filesystem operation completion callback with handle.
///
/// \param ctx Context for the operation.
/// \param fs Handle to a blobfs.
/// \param fserrno 0 if it completed successfully, or negative errno if it failed. 
 pub type spdk_fs_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , fs : * mut spdk_filesystem , fserrno : libc :: c_int ) > ; 
 /// File operation completion callback with handle.
///
/// \param ctx Context for the operation.
/// \param f Handle to a file.
/// \param fserrno 0 if it completed successfully, or negative errno if it failed. 
 pub type spdk_file_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , f : * mut spdk_file , fserrno : libc :: c_int ) > ; pub type spdk_fs_op_complete = spdk_bs_op_complete ; 
 /// File operation completion callback.
///
/// \param ctx Context for the operation.
/// \param fserrno 0 if it completed successfully, or negative errno if it failed. 
 pub type spdk_file_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , fserrno : libc :: c_int ) > ; 
 /// File stat operation completion callback.
///
/// \param ctx Context for the operation.
/// \param stat Handle to the stat about the file.
/// \param fserrno 0 if it completed successfully, or negative errno if it failed. 
 pub type spdk_file_stat_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , stat : * mut spdk_file_stat , fserrno : libc :: c_int ) > ; 
 /// Function for a request of file system.
///
/// \param arg Argument to the request function. 
 pub type fs_request_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg : * mut libc :: c_void ) > ; 
 /// Function for sending request.
///
/// This function will be invoked any time when the filesystem wants to pass a
/// message to the main dispatch thread.
///
/// \param fs_request_fn A pointer to the request function.
/// \param arg Argument to the request function. 
 pub type fs_send_request_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : fs_request_fn , arg : * mut libc :: c_void ) > ; extern "C" { 
 /// Initialize a spdk_blobfs_opts structure to the default option values.
///
/// \param opts spdk_blobf_opts struture to intialize. 
 pub fn spdk_fs_opts_init ( opts : * mut spdk_blobfs_opts ) ; } extern "C" { 
 /// Initialize blobstore filesystem.
///
/// Initialize the blobstore filesystem on the blobstore block device which has
/// been created by the function spdk_bdev_create_bs_dev() in the blob_bdev.h.
/// The obtained blobstore filesystem will be passed to the callback function.
///
/// \param dev Blobstore block device used by this blobstore filesystem.
/// \param opt Initialization options used for this blobstore filesystem.
/// \param send_request_fn The function for sending request. This function will
/// be invoked any time when the blobstore filesystem wants to pass a message to
/// the main dispatch thread.
/// \param cb_fn Called when the initialization is complete.
/// \param cb_arg Argument passed to function cb_fn. 
 pub fn spdk_fs_init ( dev : * mut spdk_bs_dev , opt : * mut spdk_blobfs_opts , send_request_fn : fs_send_request_fn , cb_fn : spdk_fs_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Load blobstore filesystem from the given blobstore block device.
///
/// The obtained blobstore filesystem will be passed to the callback function.
///
/// \param dev Blobstore block device used by this blobstore filesystem.
/// \param send_request_fn The function for sending request. This function will
/// be invoked any time when the blobstore filesystem wants to pass a message to
/// the main dispatch thread.
/// \param cb_fn Called when the loading is complete.
/// \param cb_arg Argument passed to function cb_fn. 
 pub fn spdk_fs_load ( dev : * mut spdk_bs_dev , send_request_fn : fs_send_request_fn , cb_fn : spdk_fs_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Unload blobstore filesystem.
///
/// \param fs Blobstore filesystem to unload.
/// \param cb_fn Called when the unloading is complete.
/// \param cb_arg Argument passed to function cb_fn. 
 pub fn spdk_fs_unload ( fs : * mut spdk_filesystem , cb_fn : spdk_fs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Allocate an I/O channel for asynchronous operations.
///
/// \param fs Blobstore filesystem to allocate I/O channel.
///
/// \return a pointer to the I/O channel on success or NULL otherwise. 
 pub fn spdk_fs_alloc_io_channel ( fs : * mut spdk_filesystem ) -> * mut spdk_io_channel ; } extern "C" { 
 /// Allocate an I/O channel for synchronous operations.
///
/// \param fs Blobstore filesystem to allocate I/O channel.
///
/// \return a pointer to the I/O channel on success or NULL otherwise. 
 pub fn spdk_fs_alloc_io_channel_sync ( fs : * mut spdk_filesystem ) -> * mut spdk_io_channel ; } extern "C" { 
 /// Free I/O channel.
///
/// This function will decrease the references of this I/O channel. If the reference
/// is reduced to 0, the I/O channel will be freed.
///
/// \param channel I/O channel to free. 
 pub fn spdk_fs_free_io_channel ( channel : * mut spdk_io_channel ) ; } extern "C" { 
 /// Get statistics about the file including the underlying blob id and the file size.
///
/// \param fs Blobstore filesystem.
/// \param channel The I/O channel used to allocate file request.
/// \param name The file name used to look up the matched file in the blobstore filesystem.
/// \param stat Caller allocated structure to store the obtained information about
/// this file.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_fs_file_stat ( fs : * mut spdk_filesystem , channel : * mut spdk_io_channel , name : * const libc :: c_char , stat : * mut spdk_file_stat ) -> libc :: c_int ; } extern "C" { 
 /// Create a new file on the given blobstore filesystem.
///
/// \param fs Blobstore filesystem.
/// \param channel The I/O channel used to allocate file request.
/// \param name The file name for this new file.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_fs_create_file ( fs : * mut spdk_filesystem , channel : * mut spdk_io_channel , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Open the file.
///
/// \param fs Blobstore filesystem.
/// \param channel The I/O channel used to allocate file request.
/// \param name The file name used to look up the matched file in the blobstore filesystem.
/// \param flags This flags will be used to control the open mode.
/// \param file It will point to the open file if sccessful or NULL otherwirse.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_fs_open_file ( fs : * mut spdk_filesystem , channel : * mut spdk_io_channel , name : * const libc :: c_char , flags : u32 , file : * mut * mut spdk_file ) -> libc :: c_int ; } extern "C" { 
 /// Close the file.
///
/// \param file File to close.
/// \param channel The I/O channel used to allocate file request.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_file_close ( file : * mut spdk_file , channel : * mut spdk_io_channel ) -> libc :: c_int ; } extern "C" { 
 /// Change the file name.
///
/// This operation will overwrite an existing file if there is a file with the
/// same name.
///
/// \param fs Blobstore filesystem.
/// \param channel The I/O channel used to allocate file request.
/// \param old_name Old name of the file.
/// \param new_name New name of the file.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_fs_rename_file ( fs : * mut spdk_filesystem , channel : * mut spdk_io_channel , old_name : * const libc :: c_char , new_name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Delete the file.
///
/// \param fs Blobstore filesystem.
/// \param channel The I/O channel used to allocate file request.
/// \param name The name of the file to be deleted.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_fs_delete_file ( fs : * mut spdk_filesystem , channel : * mut spdk_io_channel , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Get the first file in the blobstore filesystem.
///
/// \param fs Blobstore filesystem to traverse.
///
/// \return an iterator which points to the first file in the blobstore filesystem. 
 pub fn spdk_fs_iter_first ( fs : * mut spdk_filesystem ) -> spdk_fs_iter ; } extern "C" { 
 /// Get the next file in the blobstore filesystem by using the input iterator.
///
/// \param iter The iterator which points to the current file struct.
///
/// \return an iterator which points to the next file in the blobstore filesystem. 
 pub fn spdk_fs_iter_next ( iter : spdk_fs_iter ) -> spdk_fs_iter ; } extern "C" { 
 /// Truncate the file.
///
/// \param file File to truncate.
/// \param channel The I/O channel used to allocate file request.
/// \param length New size in bytes of the file.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_file_truncate ( file : * mut spdk_file , channel : * mut spdk_io_channel , length : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Get file name.
///
/// \param file File to query.
///
/// \return the name of the file. 
 pub fn spdk_file_get_name ( file : * mut spdk_file ) -> * const libc :: c_char ; } extern "C" { 
 /// Obtain the size of the file.
///
/// \param file File to query.
///
/// \return the size in bytes of the file. 
 pub fn spdk_file_get_length ( file : * mut spdk_file ) -> u64 ; } extern "C" { 
 /// Write data to the given file.
///
/// \param file File to write.
/// \param channel The I/O channel used to allocate file request.
/// \param payload The specified buffer which should contain the data to be transmitted.
/// \param offset The beginning position to write data.
/// \param length The size in bytes of data to write.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_file_write ( file : * mut spdk_file , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , offset : u64 , length : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Read data to user buffer from the given file.
///
/// \param file File to read.
/// \param channel The I/O channel used to allocate file request.
/// \param payload The specified buffer which will store the obtained data.
/// \param offset The beginning position to read.
/// \param length The size in bytes of data to read.
///
/// \return the end position of this read operation on success, negated errno on failure. 
 pub fn spdk_file_read ( file : * mut spdk_file , channel : * mut spdk_io_channel , payload : * mut libc :: c_void , offset : u64 , length : u64 ) -> i64 ; } extern "C" { 
 /// Set cache size for the blobstore filesystem.
///
/// \param size_in_mb Cache size in megabytes. 
 pub fn spdk_fs_set_cache_size ( size_in_mb : u64 ) ; } extern "C" { 
 /// Obtain the cache size.
///
/// \return cache size in megabytes. 
 pub fn spdk_fs_get_cache_size ( ) -> u64 ; } extern "C" { 
 /// Set priority for the file.
///
/// \param file File to set priority.
/// \param priority Priority level (SPDK_FILE_PRIORITY_LOW or SPDK_FILE_PRIORITY_HIGH). 
 pub fn spdk_file_set_priority ( file : * mut spdk_file , priority : u32 ) ; } extern "C" { 
 /// Synchronize the data from the cache to the disk.
///
/// \param file File to sync.
/// \param channel The I/O channel used to allocate file request.
///
/// \return 0 on success. 
 pub fn spdk_file_sync ( file : * mut spdk_file , channel : * mut spdk_io_channel ) -> libc :: c_int ; } extern "C" { 
 /// Get the unique ID for the file.
///
/// \param file File to get the ID.
/// \param id ID buffer.
/// \param size Size of the ID buffer.
///
/// \return the length of ID on success. 
 pub fn spdk_file_get_id ( file : * mut spdk_file , id : * mut libc :: c_void , size : usize ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_conf_value { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_conf_item { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_conf_section { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_conf { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Allocate a configuration struct used for the initialization of SPDK app.
///
/// \return a pointer to the allocated configuration struct. 
 pub fn spdk_conf_allocate ( ) -> * mut spdk_conf ; } extern "C" { 
 /// Free the configuration struct.
///
/// \param cp Configuration struct to free. 
 pub fn spdk_conf_free ( cp : * mut spdk_conf ) ; } extern "C" { 
 /// Read configuration file for spdk_conf struct.
///
/// \param cp Configuration struct used for the initialization of SPDK app.
/// \param file File to read that is created by user to configure SPDK app.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_conf_read ( cp : * mut spdk_conf , file : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Find the specified section of the configuration.
///
/// \param cp Configuration struct used for the initialization of SPDK app.
/// \param name Name of section to find.
///
/// \return a pointer to the requested section on success or NULL otherwise. 
 pub fn spdk_conf_find_section ( cp : * mut spdk_conf , name : * const libc :: c_char ) -> * mut spdk_conf_section ; } extern "C" { 
 /// Get the first section of the configuration.
///
/// \param cp Configuration struct used for the initialization of SPDK app.
///
/// \return a pointer to the requested section on success or NULL otherwise. 
 pub fn spdk_conf_first_section ( cp : * mut spdk_conf ) -> * mut spdk_conf_section ; } extern "C" { 
 /// Get the next section of the configuration.
///
/// \param sp The current section of the configuration.
///
/// \return a pointer to the requested section on success or NULL otherwise. 
 pub fn spdk_conf_next_section ( sp : * mut spdk_conf_section ) -> * mut spdk_conf_section ; } extern "C" { 
 /// Match prefix of the name of section.
///
/// \param sp The section of the configuration.
/// \param name_prefix Prefix name to match.
///
/// \return ture on success, false on failure. 
 pub fn spdk_conf_section_match_prefix ( sp : * const spdk_conf_section , name_prefix : * const libc :: c_char ) -> bool ; } extern "C" { 
 /// Get the name of the section.
///
/// \param sp The section of the configuration.
///
/// \return the name of the section. 
 pub fn spdk_conf_section_get_name ( sp : * const spdk_conf_section ) -> * const libc :: c_char ; } extern "C" { 
 /// Get the number of the section.
///
/// \param sp The section of the configuration.
///
/// \return the number of the section. 
 pub fn spdk_conf_section_get_num ( sp : * const spdk_conf_section ) -> libc :: c_int ; } extern "C" { 
 /// Get the value of the item with name 'key' in the section.
///
/// If key appears multiple times, idx1 will control which version to retrieve.
/// Indices will start from the top of the configuration file at 0 and increment
/// by one for each new apperarance. If the configuration key contains multiple
/// whitespace delimited values, idx2 controls which value is returned. The index
/// begins at 0.
///
///
/// \param sp The section of the configuration.
/// \param key Name of item.
/// \param idx1 The index into the item list for the key.
/// \param idx2 The index into the value list for the item.
///
/// \return the requested value on success or NULL otherwise. 
 pub fn spdk_conf_section_get_nmval ( sp : * mut spdk_conf_section , key : * const libc :: c_char , idx1 : libc :: c_int , idx2 : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { 
 /// Get the first value of the item with name 'key' in the section.
///
/// \param sp The section of the configuration.
/// \param key Name of item.
/// \param idx The index into the value list for the item.
///
/// \return the requested value on success or NULL otherwise. 
 pub fn spdk_conf_section_get_nval ( sp : * mut spdk_conf_section , key : * const libc :: c_char , idx : libc :: c_int ) -> * mut libc :: c_char ; } extern "C" { 
 /// Get the first value of the first item with name 'key' in the section.
///
/// \param sp The section of the configuration.
/// \param key Name of item.
///
/// \return the requested value on success or NULL otherwise. 
 pub fn spdk_conf_section_get_val ( sp : * mut spdk_conf_section , key : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { 
 /// Get the first value of the first item with name 'key' in the section.
///
/// \param sp The section of the configuration.
/// \param key Name of item.
///
/// \return the requested value on success or NULL otherwise. 
 pub fn spdk_conf_section_get_intval ( sp : * mut spdk_conf_section , key : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Get the bool value of the item with name 'key' in the section.
///
/// This is used to check whether the service is enabled.
///
/// \param sp The section of the configuration.
/// \param key Name of item.
/// \param default_val Default value.
///
/// \return true if matching 'Yes/Y/True', false if matching 'No/N/False', default value otherwise. 
 pub fn spdk_conf_section_get_boolval ( sp : * mut spdk_conf_section , key : * const libc :: c_char , default_val : bool ) -> bool ; } extern "C" { 
 /// Set the configuration as the default.
///
/// \param cp Configuration to set. 
 pub fn spdk_conf_set_as_default ( cp : * mut spdk_conf ) ; } 
 /// Copy operation callback.
///
/// \param ref 'copy_req' passed to the corresponding spdk_copy_submit() call.
/// \param status 0 if it completed successfully, or negative errno if it failed. 
 pub type spdk_copy_completion_cb = :: std :: option :: Option < unsafe extern "C" fn ( ref_ : * mut libc :: c_void , status : libc :: c_int ) > ; 
 /// Copy engine finish callback.
///
/// \param cb_arg Callback argument. 
 pub type spdk_copy_fini_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_copy_task { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Initialize the copy engine.
///
/// \return 0 on success. 
 pub fn spdk_copy_engine_initialize ( ) -> libc :: c_int ; } extern "C" { 
 /// Close the copy engine.
///
/// \param cb_fn Called when the close operation completes.
/// \param cb_arg Argument passed to the callback function. 
 pub fn spdk_copy_engine_finish ( cb_fn : spdk_copy_fini_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Get the configuration for the copy engine.
///
/// \param fp The pointer to a file that will be written to the configuration. 
 pub fn spdk_copy_engine_config_text ( fp : * mut FILE ) ; } extern "C" { 
 /// Close the copy engine module and perform any necessary cleanup. 
 pub fn spdk_copy_engine_module_finish ( ) ; } extern "C" { 
 /// Get the I/O channel registered on the copy engine.
///
/// This I/O channel is used to submit copy request.
///
/// \return a pointer to the I/O channel on success, or NULL on failure. 
 pub fn spdk_copy_engine_get_io_channel ( ) -> * mut spdk_io_channel ; } extern "C" { 
 /// Submit a copy request.
///
/// \param copy_req Copy request task.
/// \param ch I/O channel to submit request to the copy engine. This channel can
/// be obtained by the function spdk_copy_engine_get_io_channel().
/// \param dst Destination to copy to.
/// \param src Source to copy from.
/// \param nbytes Length in bytes to copy.
/// \param cb Called when this copy operation completes.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_copy_submit ( copy_req : * mut spdk_copy_task , ch : * mut spdk_io_channel , dst : * mut libc :: c_void , src : * mut libc :: c_void , nbytes : u64 , cb : spdk_copy_completion_cb ) -> libc :: c_int ; } extern "C" { 
 /// Submit a fill request.
///
/// This operation will fill the destination buffer with the specified value.
///
/// \param copy_req Copy request task.
/// \param ch I/O channel to submit request to the copy engine. This channel can
/// be obtained by the function spdk_copy_engine_get_io_channel().
/// \param dst Destination to fill.
/// \param fill Constant byte to fill to the destination.
/// \param nbytes Length in bytes to fill.
/// \param cb Called when this copy operation completes.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_copy_submit_fill ( copy_req : * mut spdk_copy_task , ch : * mut spdk_io_channel , dst : * mut libc :: c_void , fill : u8 , nbytes : u64 , cb : spdk_copy_completion_cb ) -> libc :: c_int ; } extern "C" { 
 /// Get the size of copy task.
///
/// \return the size of copy task. 
 pub fn spdk_copy_task_size ( ) -> usize ; } 
 /// List of CPUs. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_cpuset { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Allocate CPU set object.
///
/// \return a pointer to the allocated zeroed cpuset on success, or NULL on failure. 
 pub fn spdk_cpuset_alloc ( ) -> * mut spdk_cpuset ; } extern "C" { 
 /// Free allocated CPU set.
///
/// \param set CPU set to be freed. 
 pub fn spdk_cpuset_free ( set : * mut spdk_cpuset ) ; } extern "C" { 
 /// Compare two CPU sets.
///
/// \param set1 CPU set1.
/// \param set2 CPU set2.
///
/// \return true if both CPU sets are equal. 
 pub fn spdk_cpuset_equal ( set1 : * const spdk_cpuset , set2 : * const spdk_cpuset ) -> bool ; } extern "C" { 
 /// Copy the content of CPU set to another.
///
/// \param dst Destination CPU set
/// \param src Source CPU set 
 pub fn spdk_cpuset_copy ( dst : * mut spdk_cpuset , src : * const spdk_cpuset ) ; } extern "C" { 
 /// Perform AND operation on two CPU sets. The result is stored in dst.
///
/// \param dst First argument of operation. This value also stores the result of operation.
/// \param src Second argument of operation. 
 pub fn spdk_cpuset_and ( dst : * mut spdk_cpuset , src : * const spdk_cpuset ) ; } extern "C" { 
 /// Perform OR operation on two CPU sets. The result is stored in dst.
///
/// \param dst First argument of operation. This value also stores the result of operation.
/// \param src Second argument of operation. 
 pub fn spdk_cpuset_or ( dst : * mut spdk_cpuset , src : * const spdk_cpuset ) ; } extern "C" { 
 /// Clear all CPUs in CPU set.
///
/// \param set CPU set to be cleared. 
 pub fn spdk_cpuset_zero ( set : * mut spdk_cpuset ) ; } extern "C" { 
 /// Set or clear CPU state in CPU set.
///
/// \param set CPU set object.
/// \param cpu CPU index to be set or cleared.
/// \param state *true* to set cpu, *false* to clear. 
 pub fn spdk_cpuset_set_cpu ( set : * mut spdk_cpuset , cpu : u32 , state : bool ) ; } extern "C" { 
 /// Get the state of CPU in CPU set.
///
/// \param set CPU set object.
/// \param cpu CPU index.
///
/// \return the state of selected CPU. 
 pub fn spdk_cpuset_get_cpu ( set : * const spdk_cpuset , cpu : u32 ) -> bool ; } extern "C" { 
 /// Get the number of CPUs that are set in CPU set.
///
/// \param set CPU set object.
///
/// \return the number of CPUs. 
 pub fn spdk_cpuset_count ( set : * const spdk_cpuset ) -> u32 ; } extern "C" { 
 /// Convert a CPU set to hex string.
///
/// \param set CPU set.
///
/// \return a pointer to hexadecimal representation of CPU set. Buffer to store a
/// string is dynamically allocated internally and freed with CPU set object.
/// Memory returned by this function might be changed after subsequent calls to
/// this function so string should be copied by user. 
 pub fn spdk_cpuset_fmt ( set : * mut spdk_cpuset ) -> * const libc :: c_char ; } extern "C" { 
 /// Convert a string containing a CPU core mask into a CPU set.
///
/// \param set CPU set.
/// \param mask String defining CPU set. By default hexadecimal value is used or
/// as CPU list enclosed in square brackets defined as: 'c1[-c2][,c3[-c4],...]'.
///
/// \return zero if success, non zero if fails. 
 pub fn spdk_cpuset_parse ( set : * mut spdk_cpuset , mask : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Calculate T10-DIF CRC-16 checksum.
///
/// \param init_crc Initial CRC-16 value.
/// \param buf Data buffer to checksum.
/// \param len Length of buf in bytes.
/// \return CRC-16 value. 
 pub fn spdk_crc16_t10dif ( init_crc : u16 , buf : * const libc :: c_void , len : usize ) -> u16 ; } extern "C" { 
 /// Calculate T10-DIF CRC-16 checksum and copy data.
///
/// \param init_crc Initial CRC-16 value.
/// \param dst Destination data buffer for copy.
/// \param src Source data buffer for CRC calculation and copy.
/// \param len Length of buffer in bytes.
/// \return CRC-16 value. 
 pub fn spdk_crc16_t10dif_copy ( init_crc : u16 , dst : * mut u8 , src : * mut u8 , len : usize ) -> u16 ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_crc32_table { pub table : [ u32 ; 256usize ] , } impl Default for spdk_crc32_table { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Initialize a CRC32 lookup table for a given polynomial.
///
/// \param table Table to fill with precalculated CRC-32 data.
/// \param polynomial_reflect Bit-reflected CRC-32 polynomial. 
 pub fn spdk_crc32_table_init ( table : * mut spdk_crc32_table , polynomial_reflect : u32 ) ; } extern "C" { 
 /// Calculate a partial CRC-32 checksum.
///
/// \param table CRC-32 table initialized with spdk_crc32_table_init().
/// \param buf Data buffer to checksum.
/// \param len Length of buf in bytes.
/// \param crc Previous CRC-32 value.
/// \return Updated CRC-32 value. 
 pub fn spdk_crc32_update ( table : * const spdk_crc32_table , buf : * const libc :: c_void , len : usize , crc : u32 ) -> u32 ; } extern "C" { 
 /// Calculate a partial CRC-32 IEEE checksum.
///
/// \param buf Data buffer to checksum.
/// \param len Length of buf in bytes.
/// \param crc Previous CRC-32 value.
/// \return Updated CRC-32 value. 
 pub fn spdk_crc32_ieee_update ( buf : * const libc :: c_void , len : usize , crc : u32 ) -> u32 ; } extern "C" { 
 /// Calculate a partial CRC-32C checksum.
///
/// \param buf Data buffer to checksum.
/// \param len Length of buf in bytes.
/// \param crc Previous CRC-32C value.
/// \return Updated CRC-32C value. 
 pub fn spdk_crc32c_update ( buf : * const libc :: c_void , len : usize , crc : u32 ) -> u32 ; } pub const spdk_dif_type_SPDK_DIF_DISABLE : spdk_dif_type = 0 ; pub const spdk_dif_type_SPDK_DIF_TYPE1 : spdk_dif_type = 1 ; pub const spdk_dif_type_SPDK_DIF_TYPE2 : spdk_dif_type = 2 ; pub const spdk_dif_type_SPDK_DIF_TYPE3 : spdk_dif_type = 3 ; pub type spdk_dif_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_dif { pub guard : u16 , pub app_tag : u16 , pub ref_tag : u32 , } 
 /// DIF context information 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_dif_ctx { 
 /// Block size 
 pub block_size : u32 , 
 /// Metadata size 
 pub md_size : u32 , 
 /// Interval for guard computation for DIF 
 pub guard_interval : u32 , 
 /// DIF type 
 pub dif_type : spdk_dif_type , pub dif_flags : u32 , pub init_ref_tag : u32 , 
 /// Application tag 
 pub app_tag : u16 , pub apptag_mask : u16 , } impl Default for spdk_dif_ctx { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// DIF error information 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_dif_error { 
 /// Error type 
 pub err_type : u8 , 
 /// Expected value 
 pub expected : u32 , 
 /// Actual value 
 pub actual : u32 , 
 /// Offset the error occurred at, block based 
 pub err_offset : u32 , } extern "C" { 
 /// Initialize DIF context.
///
/// \param ctx DIF context.
/// \param block_size Block size in a block.
/// \param md_size Metadata size in a block.
/// \param md_interleave If true, metadata is interleaved with block data.
/// If false, metadata is separated with block data.
/// \param dif_loc DIF location. If true, DIF is set in the first 8 bytes of metadata.
/// If false, DIF is in the last 8 bytes of metadata.
/// \param dif_type Type of DIF.
/// \param dif_flags Flag to specify the DIF action.
/// \param init_ref_tag Initial reference tag. For type 1, this is the
/// starting block address.
/// \param apptag_mask Application tag mask.
/// \param app_tag Application tag.
///
/// \return 0 on success and negated errno otherwise. 
 pub fn spdk_dif_ctx_init ( ctx : * mut spdk_dif_ctx , block_size : u32 , md_size : u32 , md_interleave : bool , dif_loc : bool , dif_type : spdk_dif_type , dif_flags : u32 , init_ref_tag : u32 , apptag_mask : u16 , app_tag : u16 ) -> libc :: c_int ; } extern "C" { 
 /// Generate DIF for extended LBA payload.
///
/// \param iovs iovec array describing the extended LBA payload.
/// \param iovcnt Number of elements in the iovec array.
/// \param num_blocks Number of blocks of the payload.
/// \param ctx DIF context.
///
/// \return 0 on success and negated errno otherwise. 
 pub fn spdk_dif_generate ( iovs : * mut iovec , iovcnt : libc :: c_int , num_blocks : u32 , ctx : * const spdk_dif_ctx ) -> libc :: c_int ; } extern "C" { 
 /// Verify DIF for extended LBA payload.
///
/// \param iovs iovec array describing the extended LBA payload.
/// \param iovcnt Number of elements in the iovec array.
/// \param num_blocks Number of blocks of the payload.
/// \param ctx DIF context.
/// \param err_blk Error information of the block in which DIF error is found.
///
/// \return 0 on success and negated errno otherwise. 
 pub fn spdk_dif_verify ( iovs : * mut iovec , iovcnt : libc :: c_int , num_blocks : u32 , ctx : * const spdk_dif_ctx , err_blk : * mut spdk_dif_error ) -> libc :: c_int ; } extern "C" { 
 /// Copy data and generate DIF for extended LBA payload.
///
/// \param iovs iovec array describing the LBA payload.
/// \param iovcnt Number of elements in the iovec array.
/// \param bounce_iov A contiguous buffer forming extended LBA payload.
/// \param num_blocks Number of blocks of the LBA payload.
/// \param ctx DIF context.
///
/// \return 0 on success and negated errno otherwise. 
 pub fn spdk_dif_generate_copy ( iovs : * mut iovec , iovcnt : libc :: c_int , bounce_iov : * mut iovec , num_blocks : u32 , ctx : * const spdk_dif_ctx ) -> libc :: c_int ; } extern "C" { 
 /// Verify DIF and copy data for extended LBA payload.
///
/// \param iovs iovec array describing the LBA payload.
/// \param iovcnt Number of elements in the iovec array.
/// \param bounce_iov A contiguous buffer forming extended LBA payload.
/// \param num_blocks Number of blocks of the LBA payload.
/// \param ctx DIF context.
/// \param err_blk Error information of the block in which DIF error is found.
///
/// \return 0 on success and negated errno otherwise. 
 pub fn spdk_dif_verify_copy ( iovs : * mut iovec , iovcnt : libc :: c_int , bounce_iov : * mut iovec , num_blocks : u32 , ctx : * const spdk_dif_ctx , err_blk : * mut spdk_dif_error ) -> libc :: c_int ; } extern "C" { 
 /// Inject bit flip error to extended LBA payload.
///
/// \param iovs iovec array describing the extended LBA payload.
/// \param iovcnt Number of elements in the iovec array.
/// \param num_blocks Number of blocks of the payload.
/// \param ctx DIF context.
/// \param inject_flags Flags to specify the action of error injection.
/// \param inject_offset Offset, in blocks, to which error is injected.
/// If multiple error is injected, only the last injection is stored.
///
/// \return 0 on success and negated errno otherwise including no metadata. 
 pub fn spdk_dif_inject_error ( iovs : * mut iovec , iovcnt : libc :: c_int , num_blocks : u32 , ctx : * const spdk_dif_ctx , inject_flags : u32 , inject_offset : * mut u32 ) -> libc :: c_int ; } extern "C" { 
 /// Generate DIF for separate metadata payload.
///
/// \param iovs iovec array describing the LBA payload.
/// \params iovcnt Number of elements in iovs.
/// \param md_iov A contiguous buffer for metadata.
/// \param num_blocks Number of blocks of the separate metadata payload.
/// \param ctx DIF context.
///
/// \return 0 on success and negated errno otherwise. 
 pub fn spdk_dix_generate ( iovs : * mut iovec , iovcnt : libc :: c_int , md_iov : * mut iovec , num_blocks : u32 , ctx : * const spdk_dif_ctx ) -> libc :: c_int ; } extern "C" { 
 /// Verify DIF for separate metadata payload.
///
/// \param iovs iovec array describing the LBA payload.
/// \params iovcnt Number of elements in iovs.
/// \param md_iov A contiguous buffer for metadata.
/// \param num_blocks Number of blocks of the separate metadata payload.
/// \param ctx DIF context.
/// \param err_blk Error information of the block in which DIF error is found.
///
/// \return 0 on success and negated errno otherwise. 
 pub fn spdk_dix_verify ( iovs : * mut iovec , iovcnt : libc :: c_int , md_iov : * mut iovec , num_blocks : u32 , ctx : * const spdk_dif_ctx , err_blk : * mut spdk_dif_error ) -> libc :: c_int ; } extern "C" { 
 /// Inject bit flip error to separate metadata payload.
///
/// \param iovs iovec array describing the extended LBA payload.
/// \param iovcnt Number of elements in the iovec array.
/// \param md_iov A contiguous buffer for metadata.
/// \param num_blocks Number of blocks of the payload.
/// \param ctx DIF context.
/// \param inject_flags Flag to specify the action of error injection.
/// \param inject_offset Offset, in blocks, to which error is injected.
/// If multiple error is injected, only the last injection is stored.
///
/// \return 0 on success and negated errno otherwise including no metadata. 
 pub fn spdk_dix_inject_error ( iovs : * mut iovec , iovcnt : libc :: c_int , md_iov : * mut iovec , num_blocks : u32 , ctx : * const spdk_dif_ctx , inject_flags : u32 , inject_offset : * mut u32 ) -> libc :: c_int ; } extern "C" { 
 /// Initialize the environment library after DPDK env is already initialized.
/// If DPDK's rte_eal_init is already called, this function must be called
/// instead of spdk_env_init, prior to using any other functions in SPDK
/// env library.
///
/// \return 0 on success, or negative errno on failure. 
 pub fn spdk_env_dpdk_post_init ( ) -> libc :: c_int ; } 
 /// \brief Environment initialization options 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_env_opts { pub name : * const libc :: c_char , pub core_mask : * const libc :: c_char , pub shm_id : libc :: c_int , pub mem_channel : libc :: c_int , pub master_core : libc :: c_int , pub mem_size : libc :: c_int , pub no_pci : bool , pub hugepage_single_segments : bool , pub unlink_hugepage : bool , pub num_pci_addr : usize , pub hugedir : * const libc :: c_char , pub pci_blacklist : * mut spdk_pci_addr , pub pci_whitelist : * mut spdk_pci_addr , 
 /// Opaque context for use of the env implementation. 
 pub env_context : * mut libc :: c_void , } impl Default for spdk_env_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Allocate dma/sharable memory based on a given dma_flg. It is a memory buffer
/// with the given size, alignment and socket id.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param flags Combination of SPDK_MALLOC flags (\ref SPDK_MALLOC_DMA, \ref SPDK_MALLOC_SHARE).
/// At least one flag must be specified.
///
/// \return a pointer to the allocated memory buffer. 
 pub fn spdk_malloc ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : libc :: c_int , flags : u32 ) -> * mut libc :: c_void ; } extern "C" { 
 /// Allocate dma/sharable memory based on a given dma_flg. It is a memory buffer
/// with the given size, alignment and socket id. Also, the buffer will be zeroed.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param flags Combination of SPDK_MALLOC flags (\ref SPDK_MALLOC_DMA, \ref SPDK_MALLOC_SHARE).
///
/// \return a pointer to the allocated memory buffer. 
 pub fn spdk_zmalloc ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : libc :: c_int , flags : u32 ) -> * mut libc :: c_void ; } extern "C" { 
 /// Free buffer memory that was previously allocated with spdk_malloc() or spdk_zmalloc().
///
/// \param buf Buffer to free. 
 pub fn spdk_free ( buf : * mut libc :: c_void ) ; } extern "C" { 
 /// Initialize the default value of opts.
///
/// \param opts Data structure where SPDK will initialize the default options. 
 pub fn spdk_env_opts_init ( opts : * mut spdk_env_opts ) ; } extern "C" { 
 /// Initialize the environment library. This must be called prior to using
/// any other functions in this library.
///
/// \param opts Environment initialization options.
/// \return 0 on success, or negative errno on failure. 
 pub fn spdk_env_init ( opts : * const spdk_env_opts ) -> libc :: c_int ; } extern "C" { 
 /// Allocate a pinned memory buffer with the given size and alignment.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
///
/// \return a pointer to the allocated memory buffer. 
 pub fn spdk_dma_malloc ( size : usize , align : usize , phys_addr : * mut u64 ) -> * mut libc :: c_void ; } extern "C" { 
 /// Allocate a pinned, memory buffer with the given size, alignment and socket id.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
///
/// \return a pointer to the allocated memory buffer. 
 pub fn spdk_dma_malloc_socket ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : libc :: c_int ) -> * mut libc :: c_void ; } extern "C" { 
 /// Allocate a pinned memory buffer with the given size and alignment. The buffer
/// will be zeroed.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
///
/// \return a pointer to the allocated memory buffer. 
 pub fn spdk_dma_zmalloc ( size : usize , align : usize , phys_addr : * mut u64 ) -> * mut libc :: c_void ; } extern "C" { 
 /// Allocate a pinned memory buffer with the given size, alignment and socket id.
/// The buffer will be zeroed.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
///
/// \return a pointer to the allocated memory buffer. 
 pub fn spdk_dma_zmalloc_socket ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : libc :: c_int ) -> * mut libc :: c_void ; } extern "C" { 
 /// Resize the allocated and pinned memory buffer with the given new size and
/// alignment. Existing contents are preserved.
///
/// \param buf Buffer to resize.
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
///
/// \return a pointer to the resized memory buffer. 
 pub fn spdk_dma_realloc ( buf : * mut libc :: c_void , size : usize , align : usize , phys_addr : * mut u64 ) -> * mut libc :: c_void ; } extern "C" { 
 /// Free a memory buffer previously allocated, for example from spdk_dma_zmalloc().
/// This call is never made from the performance path.
///
/// \param buf Buffer to free. 
 pub fn spdk_dma_free ( buf : * mut libc :: c_void ) ; } extern "C" { 
 /// Reserve a named, process shared memory zone with the given size, socket_id
/// and flags. Unless `SPDK_MEMZONE_NO_IOVA_CONTIG` flag is provided, the returned
/// memory will be IOVA contiguous.
///
/// \param name Name to set for this memory zone.
/// \param len Length in bytes.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param flags Flags to set for this memory zone.
///
/// \return a pointer to the allocated memory address on success, or NULL on failure. 
 pub fn spdk_memzone_reserve ( name : * const libc :: c_char , len : usize , socket_id : libc :: c_int , flags : libc :: c_uint ) -> * mut libc :: c_void ; } extern "C" { 
 /// Reserve a named, process shared memory zone with the given size, socket_id,
/// flags and alignment. Unless `SPDK_MEMZONE_NO_IOVA_CONTIG` flag is provided,
/// the returned memory will be IOVA contiguous.
///
/// \param name Name to set for this memory zone.
/// \param len Length in bytes.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param flags Flags to set for this memory zone.
/// \param align Alignment for resulting memzone. Must be a power of 2.
///
/// \return a pointer to the allocated memory address on success, or NULL on failure. 
 pub fn spdk_memzone_reserve_aligned ( name : * const libc :: c_char , len : usize , socket_id : libc :: c_int , flags : libc :: c_uint , align : libc :: c_uint ) -> * mut libc :: c_void ; } extern "C" { 
 /// Lookup the memory zone identified by the given name.
///
/// \param name Name of the memory zone.
///
/// \return a pointer to the reserved memory address on success, or NULL on failure. 
 pub fn spdk_memzone_lookup ( name : * const libc :: c_char ) -> * mut libc :: c_void ; } extern "C" { 
 /// Free the memory zone identified by the given name.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_memzone_free ( name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Dump debug information about all memzones.
///
/// \param f File to write debug information to. 
 pub fn spdk_memzone_dump ( f : * mut FILE ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_mempool { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Create a thread-safe memory pool.
///
/// \param name Name for the memory pool.
/// \param count Count of elements.
/// \param ele_size Element size in bytes.
/// \param cache_size How many elements may be cached in per-core caches. Use
/// SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
///
/// \return a pointer to the created memory pool. 
 pub fn spdk_mempool_create ( name : * const libc :: c_char , count : usize , ele_size : usize , cache_size : usize , socket_id : libc :: c_int ) -> * mut spdk_mempool ; } 
 /// An object callback function for memory pool.
///
/// Used by spdk_mempool_create_ctor(). 
 pub type spdk_mempool_obj_cb_t = :: std :: option :: Option < unsafe extern "C" fn ( mp : * mut spdk_mempool , opaque : * mut libc :: c_void , obj : * mut libc :: c_void , obj_idx : libc :: c_uint ) > ; extern "C" { 
 /// Create a thread-safe memory pool with user provided initialization function
/// and argument.
///
/// \param name Name for the memory pool.
/// \param count Count of elements.
/// \param ele_size Element size in bytes.
/// \param cache_size How many elements may be cached in per-core caches. Use
/// SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param obj_init User provided object calllback initialization function.
/// \param obj_init_arg User provided callback initialization function argument.
///
/// \return a pointer to the created memory pool. 
 pub fn spdk_mempool_create_ctor ( name : * const libc :: c_char , count : usize , ele_size : usize , cache_size : usize , socket_id : libc :: c_int , obj_init : spdk_mempool_obj_cb_t , obj_init_arg : * mut libc :: c_void ) -> * mut spdk_mempool ; } extern "C" { 
 /// Get the name of a memory pool.
///
/// \param mp Memory pool to query.
///
/// \return the name of the memory pool. 
 pub fn spdk_mempool_get_name ( mp : * mut spdk_mempool ) -> * mut libc :: c_char ; } extern "C" { 
 /// Free a memory pool. 
 pub fn spdk_mempool_free ( mp : * mut spdk_mempool ) ; } extern "C" { 
 /// Get an element from a memory pool. If no elements remain, return NULL.
///
/// \param mp Memory pool to query.
///
/// \return a pointer to the element. 
 pub fn spdk_mempool_get ( mp : * mut spdk_mempool ) -> * mut libc :: c_void ; } extern "C" { 
 /// Get multiple elements from a memory pool.
///
/// \param mp Memory pool to get multiple elements from.
/// \param ele_arr Array of the elements to fill.
/// \param count Count of elements to get.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_mempool_get_bulk ( mp : * mut spdk_mempool , ele_arr : * mut * mut libc :: c_void , count : usize ) -> libc :: c_int ; } extern "C" { 
 /// Put an element back into the memory pool.
///
/// \param mp Memory pool to put element back into.
/// \param ele Element to put. 
 pub fn spdk_mempool_put ( mp : * mut spdk_mempool , ele : * mut libc :: c_void ) ; } extern "C" { 
 /// Put multiple elements back into the memory pool.
///
/// \param mp Memory pool to put multiple elements back into.
/// \param ele_arr Array of the elements to put.
/// \param count Count of elements to put. 
 pub fn spdk_mempool_put_bulk ( mp : * mut spdk_mempool , ele_arr : * mut * mut libc :: c_void , count : usize ) ; } extern "C" { 
 /// Get the number of entries in the memory pool.
///
/// \param pool Memory pool to query.
///
/// \return the number of entries in the memory pool. 
 pub fn spdk_mempool_count ( pool : * const spdk_mempool ) -> usize ; } extern "C" { 
 /// Get the number of dedicated CPU cores utilized by this env abstraction.
///
/// \return the number of dedicated CPU cores. 
 pub fn spdk_env_get_core_count ( ) -> u32 ; } extern "C" { 
 /// Get the CPU core index of the current thread.
///
/// This will only function when called from threads set up by
/// this environment abstraction. For any other threads \c SPDK_ENV_LCORE_ID_ANY
/// will be returned.
///
/// \return the CPU core index of the current thread. 
 pub fn spdk_env_get_current_core ( ) -> u32 ; } extern "C" { 
 /// Get the index of the first dedicated CPU core for this application.
///
/// \return the index of the first dedicated CPU core. 
 pub fn spdk_env_get_first_core ( ) -> u32 ; } extern "C" { 
 /// Get the index of the last dedicated CPU core for this application.
///
/// \return the index of the last dedicated CPU core. 
 pub fn spdk_env_get_last_core ( ) -> u32 ; } extern "C" { 
 /// Get the index of the next dedicated CPU core for this application.
///
/// If there is no next core, return UINT32_MAX.
///
/// \param prev_core Index of previous core.
///
/// \return the index of the next dedicated CPU core. 
 pub fn spdk_env_get_next_core ( prev_core : u32 ) -> u32 ; } extern "C" { 
 /// Get the socket ID for the given core.
///
/// \param core CPU core to query.
///
/// \return the socket ID for the given core. 
 pub fn spdk_env_get_socket_id ( core : u32 ) -> u32 ; } pub type thread_start_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void ) -> libc :: c_int > ; extern "C" { 
 /// Launch a thread pinned to the given core. Only a single pinned thread may be
/// launched per core. Subsequent attempts to launch pinned threads on that core
/// will fail.
///
/// \param core The core to pin the thread to.
/// \param fn Entry point on the new thread.
/// \param arg Argument apssed to thread_start_fn
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_env_thread_launch_pinned ( core : u32 , fn_ : thread_start_fn , arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Wait for all threads to exit before returning. 
 pub fn spdk_env_thread_wait_all ( ) ; } extern "C" { 
 /// Check whether the calling process is primary process.
///
/// \return true if the calling process is primary process, or false otherwise. 
 pub fn spdk_process_is_primary ( ) -> bool ; } extern "C" { 
 /// Get a monotonic timestamp counter.
///
/// \return the monotonic timestamp counter. 
 pub fn spdk_get_ticks ( ) -> u64 ; } extern "C" { 
 /// Get the tick rate of spdk_get_ticks() per second.
///
/// \return the tick rate of spdk_get_ticks() per second. 
 pub fn spdk_get_ticks_hz ( ) -> u64 ; } extern "C" { 
 /// Delay the given number of microseconds.
///
/// \param us Number of microseconds. 
 pub fn spdk_delay_us ( us : libc :: c_uint ) ; } extern "C" { 
 /// Pause CPU execution for a short while 
 pub fn spdk_pause ( ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_ring { _unused : [ u8 ; 0 ] , } pub const spdk_ring_type_SPDK_RING_TYPE_SP_SC : spdk_ring_type = 0 ; pub const spdk_ring_type_SPDK_RING_TYPE_MP_SC : spdk_ring_type = 1 ; pub const spdk_ring_type_SPDK_RING_TYPE_MP_MC : spdk_ring_type = 2 ; pub type spdk_ring_type = u32 ; extern "C" { 
 /// Create a ring.
///
/// \param type Type for the ring. (SPDK_RING_TYPE_SP_SC or SPDK_RING_TYPE_MP_SC).
/// \param count Size of the ring in elements.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
///
/// \return a pointer to the created ring. 
 pub fn spdk_ring_create ( type_ : spdk_ring_type , count : usize , socket_id : libc :: c_int ) -> * mut spdk_ring ; } extern "C" { 
 /// Free the ring.
///
/// \param ring Ring to free. 
 pub fn spdk_ring_free ( ring : * mut spdk_ring ) ; } extern "C" { 
 /// Get the number of objects in the ring.
///
/// \param ring the ring.
///
/// \return the number of objects in the ring. 
 pub fn spdk_ring_count ( ring : * mut spdk_ring ) -> usize ; } extern "C" { 
 /// Queue the array of objects (with length count) on the ring.
///
/// \param ring A pointer to the ring.
/// \param objs A pointer to the array to be queued.
/// \param count Length count of the array of objects.
///
/// \return the number of objects enqueued. 
 pub fn spdk_ring_enqueue ( ring : * mut spdk_ring , objs : * mut * mut libc :: c_void , count : usize ) -> usize ; } extern "C" { 
 /// Dequeue count objects from the ring into the array objs.
///
/// \param ring A pointer to the ring.
/// \param objs A pointer to the array to be dequeued.
/// \param count Maximum number of elements to be dequeued.
///
/// \return the number of objects dequeued which is less than 'count'. 
 pub fn spdk_ring_dequeue ( ring : * mut spdk_ring , objs : * mut * mut libc :: c_void , count : usize ) -> usize ; } extern "C" { 
 /// Get the physical address of a buffer.
///
/// \param buf A pointer to a buffer.
/// \param size Contains the size of the memory region pointed to by vaddr.
/// If vaddr is successfully translated, then this is updated with the size of
/// the memory region for which the translation is valid.
///
/// \return the physical address of this buffer on success, or SPDK_VTOPHYS_ERROR
/// on failure. 
 pub fn spdk_vtophys ( buf : * mut libc :: c_void , size : * mut u64 ) -> u64 ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_pci_addr { pub domain : u32 , pub bus : u8 , pub dev : u8 , pub func : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_pci_id { pub vendor_id : u16 , pub device_id : u16 , pub subvendor_id : u16 , pub subdevice_id : u16 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_pci_device { pub dev_handle : * mut libc :: c_void , pub addr : spdk_pci_addr , pub id : spdk_pci_id , pub socket_id : libc :: c_int , pub map_bar : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_pci_device , bar : u32 , mapped_addr : * mut * mut libc :: c_void , phys_addr : * mut u64 , size : * mut u64 ) -> libc :: c_int > , pub unmap_bar : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_pci_device , bar : u32 , addr : * mut libc :: c_void ) -> libc :: c_int > , pub cfg_read : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_pci_device , value : * mut libc :: c_void , len : u32 , offset : u32 ) -> libc :: c_int > , pub cfg_write : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_pci_device , value : * mut libc :: c_void , len : u32 , offset : u32 ) -> libc :: c_int > , pub detach : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_pci_device ) > , pub internal : spdk_pci_device__spdk_pci_device_internal , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_pci_device__spdk_pci_device_internal { pub driver : * mut spdk_pci_driver , pub attached : bool , pub tailq : spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1 { pub tqe_next : * mut spdk_pci_device , pub tqe_prev : * mut * mut spdk_pci_device , } impl Default for spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_pci_device__spdk_pci_device_internal { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_pci_device { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type spdk_pci_enum_cb = :: std :: option :: Option < unsafe extern "C" fn ( enum_ctx : * mut libc :: c_void , pci_dev : * mut spdk_pci_device ) -> libc :: c_int > ; extern "C" { 
 /// Get the NVMe PCI driver object.
///
/// \return PCI driver. 
 pub fn spdk_pci_nvme_get_driver ( ) -> * mut spdk_pci_driver ; } extern "C" { 
 /// Get the I/OAT PCI driver object.
///
/// \return PCI driver. 
 pub fn spdk_pci_ioat_get_driver ( ) -> * mut spdk_pci_driver ; } extern "C" { 
 /// Get the Virtio PCI driver object.
///
/// \return PCI driver. 
 pub fn spdk_pci_virtio_get_driver ( ) -> * mut spdk_pci_driver ; } extern "C" { 
 /// Enumerate all PCI devices supported by the provided driver and try to
/// attach those that weren't attached yet. The provided callback will be
/// called for each such device and its return code will decide whether that
/// device is attached or not. Attached devices have to be manually detached
/// with spdk_pci_device_detach() to be attach-able again.
///
/// \param driver Driver for a specific device type.
/// \param enum_cb Callback to be called for each non-attached PCI device.
/// The return code can be as follows:
///  -1 - device was not attached, the enumeration is stopped
///   0 - device attached successfully, enumeration continues
///   1 - device was not attached, enumeration continues
/// \param enum_ctx Additional context passed to the callback function.
///
/// \return -1 if an internal error occured or the provided callback returned -1,
///         0 otherwise 
 pub fn spdk_pci_enumerate ( driver : * mut spdk_pci_driver , enum_cb : spdk_pci_enum_cb , enum_ctx : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Map a PCI BAR in the current process.
///
/// \param dev PCI device.
/// \param bar BAR number.
/// \param mapped_addr A variable to store the virtual address of the mapping.
/// \param phys_addr A variable to store the physical address of the mapping.
/// \param size A variable to store the size of the bar (in bytes).
///
/// \return 0 on success. 
 pub fn spdk_pci_device_map_bar ( dev : * mut spdk_pci_device , bar : u32 , mapped_addr : * mut * mut libc :: c_void , phys_addr : * mut u64 , size : * mut u64 ) -> libc :: c_int ; } extern "C" { 
 /// Unmap a PCI BAR from the current process. This happens automatically when
/// the PCI device is detached.
///
/// \param dev PCI device.
/// \param bar BAR number.
/// \param mapped_addr Virtual address of the bar.
///
/// \return 0 on success. 
 pub fn spdk_pci_device_unmap_bar ( dev : * mut spdk_pci_device , bar : u32 , mapped_addr : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Get the domain of a PCI device.
///
/// \param dev PCI device.
///
/// \return PCI device domain. 
 pub fn spdk_pci_device_get_domain ( dev : * mut spdk_pci_device ) -> u32 ; } extern "C" { 
 /// Get the bus number of a PCI device.
///
/// \param dev PCI device.
///
/// \return PCI bus number. 
 pub fn spdk_pci_device_get_bus ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { 
 /// Get the device number within the PCI bus the device is on.
///
/// \param dev PCI device.
///
/// \return PCI device number. 
 pub fn spdk_pci_device_get_dev ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { 
 /// Get the particular function number represented by struct spdk_pci_device.
///
/// \param dev PCI device.
///
/// \return PCI function number. 
 pub fn spdk_pci_device_get_func ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { 
 /// Get the full DomainBDF address of a PCI device.
///
/// \param dev PCI device.
///
/// \return PCI address. 
 pub fn spdk_pci_device_get_addr ( dev : * mut spdk_pci_device ) -> spdk_pci_addr ; } extern "C" { 
 /// Get the vendor ID of a PCI device.
///
/// \param dev PCI device.
///
/// \return vendor ID. 
 pub fn spdk_pci_device_get_vendor_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { 
 /// Get the device ID of a PCI device.
///
/// \param dev PCI device.
///
/// \return device ID. 
 pub fn spdk_pci_device_get_device_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { 
 /// Get the subvendor ID of a PCI device.
///
/// \param dev PCI device.
///
/// \return subvendor ID. 
 pub fn spdk_pci_device_get_subvendor_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { 
 /// Get the subdevice ID of a PCI device.
///
/// \param dev PCI device.
///
/// \return subdevice ID. 
 pub fn spdk_pci_device_get_subdevice_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { 
 /// Get the PCI ID of a PCI device.
///
/// \param dev PCI device.
///
/// \return PCI ID. 
 pub fn spdk_pci_device_get_id ( dev : * mut spdk_pci_device ) -> spdk_pci_id ; } extern "C" { 
 /// Get the NUMA node the PCI device is on.
///
/// \param dev PCI device.
///
/// \return NUMA node index (>= 0). 
 pub fn spdk_pci_device_get_socket_id ( dev : * mut spdk_pci_device ) -> libc :: c_int ; } extern "C" { 
 /// Serialize the PCIe Device Serial Number into the provided buffer.
/// The buffer will contain a 16-character-long serial number followed by
/// a NULL terminator.
///
/// \param dev PCI device.
/// \param sn Buffer to store the serial number in.
/// \param len Length of buffer. Must be at least 17.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_get_serial_number ( dev : * mut spdk_pci_device , sn : * mut libc :: c_char , len : usize ) -> libc :: c_int ; } extern "C" { 
 /// Claim a PCI device for exclusive SPDK userspace access.
///
/// Uses F_SETLK on a shared memory file with the PCI address embedded in its name.
/// As long as this file remains open with the lock acquired, other processes will
/// not be able to successfully call this function on the same PCI device.
///
/// \param pci_addr PCI address of the device to claim
///
/// \return -1 if the device has already been claimed, an fd otherwise. This fd
/// should be closed when the application no longer needs access to the PCI device
/// (including when it is hot removed). 
 pub fn spdk_pci_device_claim ( pci_addr : * const spdk_pci_addr ) -> libc :: c_int ; } extern "C" { 
 /// Release all resources associated with the given device and detach it. As long
/// as the PCI device is physically available, it will attachable again.
///
/// \param device PCI device. 
 pub fn spdk_pci_device_detach ( device : * mut spdk_pci_device ) ; } extern "C" { 
 /// Attach a PCI device. This will bypass all blacklist rules and explicitly
/// attach a device at the provided address. The return code of the provided
/// callback will decide whether that device is attached or not. Attached
/// devices have to be manually detached with spdk_pci_device_detach() to be
/// attach-able again.
///
/// \param driver Driver for a specific device type. The device will only be
/// attached if it's supported by this driver.
/// \param enum_cb Callback to be called for the PCI device once it's found.
/// The return code can be as follows:
///  -1, 1 - an error occured, fail the attach request entirely
///   0 - device attached successfully
/// \param enum_ctx Additional context passed to the callback function.
/// \param pci_address Address of the device to attach.
///
/// \return -1 if a device at the provided PCI address couldn't be found,
///         -1 if an internal error happened or the provided callback returned non-zero,
///         0 otherwise 
 pub fn spdk_pci_device_attach ( driver : * mut spdk_pci_driver , enum_cb : spdk_pci_enum_cb , enum_ctx : * mut libc :: c_void , pci_address : * mut spdk_pci_addr ) -> libc :: c_int ; } extern "C" { 
 /// Read \c len bytes from the PCI configuration space.
///
/// \param dev PCI device.
/// \param buf A buffer to copy the data into.
/// \param len Number of bytes to read.
/// \param offset Offset (in bytes) in the PCI config space to start reading from.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_cfg_read ( dev : * mut spdk_pci_device , buf : * mut libc :: c_void , len : u32 , offset : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Write \c len bytes into the PCI configuration space.
///
/// \param dev PCI device.
/// \param buf A buffer to copy the data from.
/// \param len Number of bytes to write.
/// \param offset Offset (in bytes) in the PCI config space to start writing to.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_cfg_write ( dev : * mut spdk_pci_device , buf : * mut libc :: c_void , len : u32 , offset : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Read 1 byte from the PCI configuration space.
///
/// \param dev PCI device.
/// \param value A buffer to copy the data into.
/// \param offset Offset (in bytes) in the PCI config space to start reading from.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_cfg_read8 ( dev : * mut spdk_pci_device , value : * mut u8 , offset : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Write 1 byte into the PCI configuration space.
///
/// \param dev PCI device.
/// \param value A value to write.
/// \param offset Offset (in bytes) in the PCI config space to start writing to.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_cfg_write8 ( dev : * mut spdk_pci_device , value : u8 , offset : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Read 2 bytes from the PCI configuration space.
///
/// \param dev PCI device.
/// \param value A buffer to copy the data into.
/// \param offset Offset (in bytes) in the PCI config space to start reading from.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_cfg_read16 ( dev : * mut spdk_pci_device , value : * mut u16 , offset : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Write 2 bytes into the PCI configuration space.
///
/// \param dev PCI device.
/// \param value A value to write.
/// \param offset Offset (in bytes) in the PCI config space to start writing to.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_cfg_write16 ( dev : * mut spdk_pci_device , value : u16 , offset : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Read 4 bytes from the PCI configuration space.
///
/// \param dev PCI device.
/// \param value A buffer to copy the data into.
/// \param offset Offset (in bytes) in the PCI config space to start reading from.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_cfg_read32 ( dev : * mut spdk_pci_device , value : * mut u32 , offset : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Write 4 bytes into the PCI configuration space.
///
/// \param dev PCI device.
/// \param value A value to write.
/// \param offset Offset (in bytes) in the PCI config space to start writing to.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_pci_device_cfg_write32 ( dev : * mut spdk_pci_device , value : u32 , offset : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Compare two PCI addresses.
///
/// \param a1 PCI address 1.
/// \param a2 PCI address 2.
///
/// \return 0 if a1 == a2, less than 0 if a1 < a2, greater than 0 if a1 > a2 
 pub fn spdk_pci_addr_compare ( a1 : * const spdk_pci_addr , a2 : * const spdk_pci_addr ) -> libc :: c_int ; } extern "C" { 
 /// Convert a string representation of a PCI address into a struct spdk_pci_addr.
///
/// \param addr PCI adddress output on success.
/// \param bdf PCI address in domain:bus:device.function format or
///	domain.bus.device.function format.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_pci_addr_parse ( addr : * mut spdk_pci_addr , bdf : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Convert a struct spdk_pci_addr to a string.
///
/// \param bdf String into which a string will be output in the format
///  domain:bus:device.function. The string must be at least 14 characters in size.
/// \param sz Size of bdf in bytes. Must be at least 14.
/// \param addr PCI address.
///
/// \return 0 on success, or a negated errno on failure. 
 pub fn spdk_pci_addr_fmt ( bdf : * mut libc :: c_char , sz : usize , addr : * const spdk_pci_addr ) -> libc :: c_int ; } extern "C" { 
 /// Hook a custom PCI device into the PCI layer. The device will be attachable,
/// enumerable, and will call provided callbacks on each PCI resource access
/// request.
///
/// \param drv driver that will be able to attach the device
/// \param dev fully initialized PCI device struct 
 pub fn spdk_pci_hook_device ( drv : * mut spdk_pci_driver , dev : * mut spdk_pci_device ) ; } extern "C" { 
 /// Un-hook a custom PCI device from the PCI layer. The device must not be attached.
///
/// \param dev fully initialized PCI device struct 
 pub fn spdk_pci_unhook_device ( dev : * mut spdk_pci_device ) ; } extern "C" { 
 /// Remove any CPU affinity from the current thread. 
 pub fn spdk_unaffinitize_thread ( ) ; } extern "C" { 
 /// Call a function with CPU affinity unset.
///
/// This can be used to run a function that creates other threads without inheriting the calling
/// thread's CPU affinity.
///
/// \param cb Function to call
/// \param arg Parameter to the function cb().
///
/// \return the return value of cb(). 
 pub fn spdk_call_unaffinitized ( cb : :: std :: option :: Option < unsafe extern "C" fn ( arg : * mut libc :: c_void ) -> * mut libc :: c_void > , arg : * mut libc :: c_void ) -> * mut libc :: c_void ; } 
 /// Page-granularity memory address translation table. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_mem_map { _unused : [ u8 ; 0 ] , } pub const spdk_mem_map_notify_action_SPDK_MEM_MAP_NOTIFY_REGISTER : spdk_mem_map_notify_action = 0 ; pub const spdk_mem_map_notify_action_SPDK_MEM_MAP_NOTIFY_UNREGISTER : spdk_mem_map_notify_action = 1 ; pub type spdk_mem_map_notify_action = u32 ; pub type spdk_mem_map_notify_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , map : * mut spdk_mem_map , action : spdk_mem_map_notify_action , vaddr : * mut libc :: c_void , size : usize ) -> libc :: c_int > ; pub type spdk_mem_map_contiguous_translations = :: std :: option :: Option < unsafe extern "C" fn ( addr_1 : u64 , addr_2 : u64 ) -> libc :: c_int > ; 
 /// A function table to be implemented by each memory map. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_mem_map_ops { pub notify_cb : spdk_mem_map_notify_cb , pub are_contiguous : spdk_mem_map_contiguous_translations , } impl Default for spdk_mem_map_ops { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Allocate a virtual memory address translation map.
///
/// \param default_translation Default translation for the map.
/// \param ops Table of callback functions for map operations.
/// \param cb_ctx Argument passed to the callback function.
///
/// \return a pointer to the allocated virtual memory address translation map. 
 pub fn spdk_mem_map_alloc ( default_translation : u64 , ops : * const spdk_mem_map_ops , cb_ctx : * mut libc :: c_void ) -> * mut spdk_mem_map ; } extern "C" { 
 /// Free a memory map previously allocated by spdk_mem_map_alloc().
///
/// \param pmap Memory map to free. 
 pub fn spdk_mem_map_free ( pmap : * mut * mut spdk_mem_map ) ; } extern "C" { 
 /// Register an address translation for a range of virtual memory.
///
/// \param map Memory map.
/// \param vaddr Virtual address of the region to register - must be 2 MB aligned.
/// \param size Size of the region in bytes - must be multiple of 2 MB in the
///  current implementation.
/// \param translation Translation to store in the map for this address range.
///
/// \sa spdk_mem_map_clear_translation().
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_mem_map_set_translation ( map : * mut spdk_mem_map , vaddr : u64 , size : u64 , translation : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Unregister an address translation.
///
/// \param map Memory map.
/// \param vaddr Virtual address of the region to unregister - must be 2 MB aligned.
/// \param size Size of the region in bytes - must be multiple of 2 MB in the
///  current implementation.
///
/// \sa spdk_mem_map_set_translation().
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_mem_map_clear_translation ( map : * mut spdk_mem_map , vaddr : u64 , size : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Look up the translation of a virtual address in a memory map.
///
/// \param map Memory map.
/// \param vaddr Virtual address.
/// \param size Contains the size of the memory region pointed to by vaddr.
/// If vaddr is successfully translated, then this is updated with the size of
/// the memory region for which the translation is valid.
///
/// \return the translation of vaddr stored in the map, or default_translation
/// as specified in spdk_mem_map_alloc() if vaddr is not present in the map. 
 pub fn spdk_mem_map_translate ( map : * const spdk_mem_map , vaddr : u64 , size : * mut u64 ) -> u64 ; } extern "C" { 
 /// Register the specified memory region for address translation.
///
/// The memory region must map to pinned huge pages (2MB or greater).
///
/// \param vaddr Virtual address to register.
/// \param len Length in bytes of the vaddr.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_mem_register ( vaddr : * mut libc :: c_void , len : usize ) -> libc :: c_int ; } extern "C" { 
 /// Unregister the specified memory region from vtophys address translation.
///
/// The caller must ensure all in-flight DMA operations to this memory region
/// are completed or cancelled before calling this function.
///
/// \param vaddr Virtual address to unregister.
/// \param len Length in bytes of the vaddr.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_mem_unregister ( vaddr : * mut libc :: c_void , len : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_log_open ( ) ; } extern "C" { pub fn spdk_log_close ( ) ; } pub const spdk_log_level_SPDK_LOG_DISABLED : spdk_log_level = -1 ; pub const spdk_log_level_SPDK_LOG_ERROR : spdk_log_level = 0 ; pub const spdk_log_level_SPDK_LOG_WARN : spdk_log_level = 1 ; pub const spdk_log_level_SPDK_LOG_NOTICE : spdk_log_level = 2 ; pub const spdk_log_level_SPDK_LOG_INFO : spdk_log_level = 3 ; pub const spdk_log_level_SPDK_LOG_DEBUG : spdk_log_level = 4 ; pub type spdk_log_level = i32 ; extern "C" { pub fn spdk_log_set_level ( level : spdk_log_level ) ; } extern "C" { pub fn spdk_log_get_level ( ) -> spdk_log_level ; } extern "C" { pub fn spdk_log_set_backtrace_level ( level : spdk_log_level ) ; } extern "C" { pub fn spdk_log_get_backtrace_level ( ) -> spdk_log_level ; } extern "C" { pub fn spdk_log_set_print_level ( level : spdk_log_level ) ; } extern "C" { pub fn spdk_log_get_print_level ( ) -> spdk_log_level ; } extern "C" { pub fn spdk_log ( level : spdk_log_level , file : * const libc :: c_char , line : libc :: c_int , func : * const libc :: c_char , format : * const libc :: c_char , ... ) ; } extern "C" { pub fn spdk_log_dump ( fp : * mut FILE , label : * const libc :: c_char , buf : * const libc :: c_void , len : usize ) ; } extern "C" { pub fn spdk_log_get_flag ( flag : * const libc :: c_char ) -> bool ; } extern "C" { pub fn spdk_log_set_flag ( flag : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_log_clear_flag ( flag : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_log_usage ( f : * mut FILE , log_arg : * const libc :: c_char ) ; } 
 /// Event handler function.
///
/// \param arg1 Argument 1.
/// \param arg2 Argument 2. 
 pub type spdk_event_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void , arg2 : * mut libc :: c_void ) > ; 
 /// \brief An event is a function that is passed to and called on an lcore. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_event { _unused : [ u8 ; 0 ] , } 
 /// Callback function for customized shutdown handling of application. 
 pub type spdk_app_shutdown_cb = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; 
 /// Signal handler fucntion.
///
/// \param signal Signal number. 
 pub type spdk_sighandler_t = :: std :: option :: Option < unsafe extern "C" fn ( signal : libc :: c_int ) > ; 
 /// \brief Event framework initialization options 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_app_opts { pub name : * const libc :: c_char , pub config_file : * const libc :: c_char , pub json_config_file : * const libc :: c_char , pub rpc_addr : * const libc :: c_char , pub reactor_mask : * const libc :: c_char , pub tpoint_group_mask : * const libc :: c_char , pub shm_id : libc :: c_int , pub shutdown_cb : spdk_app_shutdown_cb , pub usr1_handler : spdk_sighandler_t , pub enable_coredump : bool , pub mem_channel : libc :: c_int , pub master_core : libc :: c_int , pub mem_size : libc :: c_int , pub no_pci : bool , pub hugepage_single_segments : bool , pub unlink_hugepage : bool , pub hugedir : * const libc :: c_char , pub print_level : spdk_log_level , pub num_pci_addr : usize , pub pci_blacklist : * mut spdk_pci_addr , pub pci_whitelist : * mut spdk_pci_addr , pub max_delay_us : u64 , pub delay_subsystem_init : bool , pub num_entries : u64 , } impl Default for spdk_app_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_reactor_tsc_stats { pub busy_tsc : u64 , pub idle_tsc : u64 , pub unknown_tsc : u64 , } extern "C" { 
 /// Initialize the default value of opts
///
/// \param opts Data structure where SPDK will initialize the default options. 
 pub fn spdk_app_opts_init ( opts : * mut spdk_app_opts ) ; } extern "C" { 
 /// Start the framework.
///
/// Before calling this function, the fields of opts must be initialized by
/// spdk_app_opts_init(). Once started, the framework will call start_fn on the
/// master core with the arguments provided. This call will block until spdk_app_stop()
/// is called, or if an error condition occurs during the intialization
/// code within spdk_app_start(), itself, before invoking the caller's
/// supplied function.
///
/// \param opts Initialization options used for this application.
/// \param start_fn Event function that is called when the framework starts.
/// \param arg1 Argument passed to function start_fn.
/// \param arg2 Argument passed to function start_fn.
///
/// \return 0 on success or non-zero on failure. 
 pub fn spdk_app_start ( opts : * mut spdk_app_opts , start_fn : spdk_event_fn , arg1 : * mut libc :: c_void , arg2 : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Perform final shutdown operations on an application using the event framework. 
 pub fn spdk_app_fini ( ) ; } extern "C" { 
 /// Start shutting down the framework.
///
/// Typically this function is not called directly, and the shutdown process is
/// started implicitly by a process signal. But in applications that are using
/// SPDK for a subset of its process threads, this function can be called in lieu
/// of a signal. 
 pub fn spdk_app_start_shutdown ( ) ; } extern "C" { 
 /// Stop the framework.
///
/// This does not wait for all threads to exit. Instead, it kicks off the shutdown
/// process and returns. Once the shutdown process is complete, spdk_app_start()
/// will return.
///
/// \param rc The rc value specified here will be returned to caller of spdk_app_start(). 
 pub fn spdk_app_stop ( rc : libc :: c_int ) ; } extern "C" { 
 /// Generate a configuration file that corresponds to the current running state.
///
/// \param config_str Values obtained from the generated configuration file.
/// \param name Prefix for name of temporary configuration file to save the current config.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_app_get_running_config ( config_str : * mut * mut libc :: c_char , name : * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Return the shared memory id for this application.
///
/// \return shared memory id. 
 pub fn spdk_app_get_shm_id ( ) -> libc :: c_int ; } extern "C" { 
 /// Convert a string containing a CPU core mask into a bitmask
///
/// \param mask String containing a CPU core mask.
/// \param cpumask Bitmask of CPU cores.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_app_parse_core_mask ( mask : * const libc :: c_char , cpumask : * mut spdk_cpuset ) -> libc :: c_int ; } extern "C" { 
 /// Get the mask of the CPU cores active for this application
///
/// \return the bitmask of the active CPU cores. 
 pub fn spdk_app_get_core_mask ( ) -> * mut spdk_cpuset ; } pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_HELP : spdk_app_parse_args_rvals = 0 ; pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_SUCCESS : spdk_app_parse_args_rvals = 1 ; pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_FAIL : spdk_app_parse_args_rvals = 2 ; pub type spdk_app_parse_args_rvals = u32 ; pub use self :: spdk_app_parse_args_rvals as spdk_app_parse_args_rvals_t ; extern "C" { 
 /// Helper function for parsing arguments and printing usage messages.
///
/// \param argc Count of arguments in argv parameter array.
/// \param argv Array of command line arguments.
/// \param opts Default options for the application.
/// \param getopt_str String representing the app-specific command line parameters.
/// Characters in this string must not conflict with characters in SPDK_APP_GETOPT_STRING.
/// \param app_long_opts Array of full-name parameters. Can be NULL.
/// \param parse Function pointer to call if an argument in getopt_str is found.
/// \param usage Function pointer to print usage messages for app-specific command
///		line parameters.
///\return SPDK_APP_PARSE_ARGS_FAIL on failure, SPDK_APP_PARSE_ARGS_SUCCESS on
///        success, SPDK_APP_PARSE_ARGS_HELP if '-h' passed as an option. 
 pub fn spdk_app_parse_args ( argc : libc :: c_int , argv : * mut * mut libc :: c_char , opts : * mut spdk_app_opts , getopt_str : * const libc :: c_char , app_long_opts : * mut option , parse : :: std :: option :: Option < unsafe extern "C" fn ( ch : libc :: c_int , arg : * mut libc :: c_char ) -> libc :: c_int > , usage : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> spdk_app_parse_args_rvals_t ; } extern "C" { 
 /// Print usage strings for common SPDK command line options.
///
/// May only be called after spdk_app_parse_args(). 
 pub fn spdk_app_usage ( ) ; } extern "C" { 
 /// Allocate an event to be passed to spdk_event_call().
///
/// \param lcore Lcore to run this event.
/// \param fn Function used to execute event.
/// \param arg1 Argument passed to function fn.
/// \param arg2 Argument passed to function fn.
///
/// \return a pointer to the allocated event. 
 pub fn spdk_event_allocate ( lcore : u32 , fn_ : spdk_event_fn , arg1 : * mut libc :: c_void , arg2 : * mut libc :: c_void ) -> * mut spdk_event ; } extern "C" { 
 /// Pass the given event to the associated lcore and call the function.
///
/// \param event Event to execute. 
 pub fn spdk_event_call ( event : * mut spdk_event ) ; } extern "C" { 
 /// Enable or disable monitoring of context switches.
///
/// \param enabled True to enable, false to disable. 
 pub fn spdk_reactor_enable_context_switch_monitor ( enabled : bool ) ; } extern "C" { 
 /// Return whether context switch monitoring is enabled.
///
/// \return true if enabled or false otherwise. 
 pub fn spdk_reactor_context_switch_monitor_enabled ( ) -> bool ; } extern "C" { 
 /// Get tsc stats from a given reactor
/// Copy cumulative reactor tsc values to user's tsc_stats structure.
///
/// \param tsc_stats User's tsc_stats structure.
/// \param core_id Get tsc data on this Reactor core id. 
 pub fn spdk_reactor_get_tsc_stats ( tsc_stats : * mut spdk_reactor_tsc_stats , core_id : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Get the file size.
///
/// \param fd  File descriptor.
///
/// \return    File size. 
 pub fn spdk_fd_get_size ( fd : libc :: c_int ) -> u64 ; } extern "C" { 
 /// Get the block size of the file.
///
/// \param fd  File descriptor.
///
/// \return    Block size. 
 pub fn spdk_fd_get_blocklen ( fd : libc :: c_int ) -> u32 ; } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_capsule_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 35usize ] , pub fabric_specific : [ u8 ; 24usize ] , } impl Default for spdk_nvmf_capsule_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_PROPERTY_SET : spdk_nvmf_fabric_cmd_types = 0 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_CONNECT : spdk_nvmf_fabric_cmd_types = 1 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_PROPERTY_GET : spdk_nvmf_fabric_cmd_types = 4 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_AUTHENTICATION_SEND : spdk_nvmf_fabric_cmd_types = 5 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_AUTHENTICATION_RECV : spdk_nvmf_fabric_cmd_types = 6 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_START_VENDOR_SPECIFIC : spdk_nvmf_fabric_cmd_types = 192 ; pub type spdk_nvmf_fabric_cmd_types = u32 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INCOMPATIBLE_FORMAT : spdk_nvmf_fabric_cmd_status_code = 128 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_CONTROLLER_BUSY : spdk_nvmf_fabric_cmd_status_code = 129 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INVALID_PARAM : spdk_nvmf_fabric_cmd_status_code = 130 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_RESTART_DISCOVERY : spdk_nvmf_fabric_cmd_status_code = 131 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INVALID_HOST : spdk_nvmf_fabric_cmd_status_code = 132 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_LOG_RESTART_DISCOVERY : spdk_nvmf_fabric_cmd_status_code = 144 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_AUTH_REQUIRED : spdk_nvmf_fabric_cmd_status_code = 145 ; pub type spdk_nvmf_fabric_cmd_status_code = u32 ; pub const spdk_nvmf_rdma_qptype_SPDK_NVMF_RDMA_QPTYPE_RELIABLE_CONNECTED : spdk_nvmf_rdma_qptype = 1 ; pub const spdk_nvmf_rdma_qptype_SPDK_NVMF_RDMA_QPTYPE_RELIABLE_DATAGRAM : spdk_nvmf_rdma_qptype = 2 ; pub type spdk_nvmf_rdma_qptype = u32 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_NONE : spdk_nvmf_rdma_prtype = 1 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_IB : spdk_nvmf_rdma_prtype = 2 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_ROCE : spdk_nvmf_rdma_prtype = 3 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_ROCE2 : spdk_nvmf_rdma_prtype = 4 ; pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_IWARP : spdk_nvmf_rdma_prtype = 5 ; pub type spdk_nvmf_rdma_prtype = u32 ; pub const spdk_nvmf_rdma_cms_SPDK_NVMF_RDMA_CMS_RDMA_CM : spdk_nvmf_rdma_cms = 1 ; pub type spdk_nvmf_rdma_cms = u32 ; pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_RDMA : spdk_nvmf_trtype = 1 ; pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_FC : spdk_nvmf_trtype = 2 ; pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_TCP : spdk_nvmf_trtype = 3 ; pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_INTRA_HOST : spdk_nvmf_trtype = 254 ; pub type spdk_nvmf_trtype = u32 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV4 : spdk_nvmf_adrfam = 1 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV6 : spdk_nvmf_adrfam = 2 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IB : spdk_nvmf_adrfam = 3 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_FC : spdk_nvmf_adrfam = 4 ; pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_INTRA_HOST : spdk_nvmf_adrfam = 254 ; pub type spdk_nvmf_adrfam = u32 ; pub const spdk_nvmf_subtype_SPDK_NVMF_SUBTYPE_DISCOVERY : spdk_nvmf_subtype = 1 ; pub const spdk_nvmf_subtype_SPDK_NVMF_SUBTYPE_NVME : spdk_nvmf_subtype = 2 ; pub type spdk_nvmf_subtype = u32 ; pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_NOT_SPECIFIED : spdk_nvmf_treq_secure_channel = 0 ; pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_REQUIRED : spdk_nvmf_treq_secure_channel = 1 ; pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_NOT_REQUIRED : spdk_nvmf_treq_secure_channel = 2 ; pub type spdk_nvmf_treq_secure_channel = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_auth_recv_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub reserved3 : u8 , pub spsp0 : u8 , pub spsp1 : u8 , pub secp : u8 , pub al : u32 , pub reserved4 : [ u8 ; 16usize ] , } impl Default for spdk_nvmf_fabric_auth_recv_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_auth_send_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub reserved3 : u8 , pub spsp0 : u8 , pub spsp1 : u8 , pub secp : u8 , pub tl : u32 , pub reserved4 : [ u8 ; 16usize ] , } impl Default for spdk_nvmf_fabric_auth_send_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_data { pub hostid : [ u8 ; 16usize ] , pub cntlid : u16 , pub reserved5 : [ u8 ; 238usize ] , pub subnqn : [ u8 ; 256usize ] , pub hostnqn : [ u8 ; 256usize ] , pub reserved6 : [ u8 ; 256usize ] , } impl Default for spdk_nvmf_fabric_connect_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub recfmt : u16 , pub qid : u16 , pub sqsize : u16 , pub cattr : u8 , pub reserved3 : u8 , pub kato : u32 , pub reserved4 : [ u8 ; 12usize ] , } impl Default for spdk_nvmf_fabric_connect_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp { pub status_code_specific : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 , pub reserved0 : u32 , pub sqhd : u16 , pub reserved1 : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 { pub success : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 , pub invalid : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 , pub raw : u32 , _bindgen_union_align : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 { pub cntlid : u16 , pub authreq : u16 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 { pub ipo : u16 , pub iattr : u8 , pub reserved : u8 , } impl Default for spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvmf_fabric_connect_rsp { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 35usize ] , pub attrib : spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 , pub reserved3 : [ u8 ; 3usize ] , pub ofst : u32 , pub reserved4 : [ u8 ; 16usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 { # [ inline ] pub fn size ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_size ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( size : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let size : u8 = unsafe { :: std :: mem :: transmute ( size ) } ; size as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvmf_fabric_prop_get_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_rsp { pub value : spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 , pub sqhd : u16 , pub reserved0 : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 { pub u64 : u64 , pub u32 : spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 { pub low : u32 , pub high : u32 , } impl Default for spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvmf_fabric_prop_get_rsp { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd { pub opcode : u8 , pub reserved0 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved1 : [ u8 ; 35usize ] , pub attrib : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 , pub reserved2 : [ u8 ; 3usize ] , pub ofst : u32 , pub value : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 , pub reserved4 : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 { # [ inline ] pub fn size ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_size ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( size : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let size : u8 = unsafe { :: std :: mem :: transmute ( size ) } ; size as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 { pub u64 : u64 , pub u32 : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 { pub low : u32 , pub high : u32 , } impl Default for spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvmf_fabric_prop_set_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_rdma_transport_specific_address_subtype { pub rdma_qptype : u8 , pub rdma_prtype : u8 , pub rdma_cms : u8 , pub reserved0 : [ u8 ; 5usize ] , pub rdma_pkey : u16 , pub reserved2 : [ u8 ; 246usize ] , } impl Default for spdk_nvmf_rdma_transport_specific_address_subtype { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_tcp_secure_socket_type_SPDK_NVME_TCP_SECURITY_NONE : spdk_nvme_tcp_secure_socket_type = 0 ; pub const spdk_nvme_tcp_secure_socket_type_SPDK_NVME_TCP_SECURITY_TLS : spdk_nvme_tcp_secure_socket_type = 1 ; pub type spdk_nvme_tcp_secure_socket_type = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_tcp_transport_specific_address_subtype { pub sectype : u8 , pub reserved0 : [ u8 ; 255usize ] , } impl Default for spdk_nvme_tcp_transport_specific_address_subtype { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_transport_specific_address_subtype { pub raw : [ u8 ; 256usize ] , pub rdma : spdk_nvmf_rdma_transport_specific_address_subtype , pub tcp : spdk_nvme_tcp_transport_specific_address_subtype , _bindgen_union_align : [ u8 ; 256usize ] , } impl Default for spdk_nvmf_transport_specific_address_subtype { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_discovery_log_page_entry { pub trtype : u8 , pub adrfam : u8 , pub subtype : u8 , pub treq : spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 , pub portid : u16 , pub cntlid : u16 , pub asqsz : u16 , pub reserved0 : [ u8 ; 22usize ] , pub trsvcid : [ u8 ; 32usize ] , pub reserved1 : [ u8 ; 192usize ] , pub subnqn : [ u8 ; 256usize ] , pub traddr : [ u8 ; 256usize ] , pub tsas : spdk_nvmf_transport_specific_address_subtype , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 { # [ inline ] pub fn secure_channel ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_secure_channel ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( secure_channel : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let secure_channel : u8 = unsafe { :: std :: mem :: transmute ( secure_channel ) } ; secure_channel as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvmf_discovery_log_page_entry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] pub struct spdk_nvmf_discovery_log_page { pub genctr : u64 , pub numrec : u64 , pub recfmt : u16 , pub reserved0 : [ u8 ; 1006usize ] , pub entries : __IncompleteArrayField < spdk_nvmf_discovery_log_page_entry > , } impl Default for spdk_nvmf_discovery_log_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_request_private_data { pub recfmt : u16 , pub qid : u16 , pub hrqsize : u16 , pub hsqsize : u16 , pub cntlid : u16 , pub reserved : [ u8 ; 22usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_accept_private_data { pub recfmt : u16 , pub crqsize : u16 , pub reserved : [ u8 ; 28usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_reject_private_data { pub recfmt : u16 , pub sts : u16 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_rdma_private_data { pub pd_request : spdk_nvmf_rdma_request_private_data , pub pd_accept : spdk_nvmf_rdma_accept_private_data , pub pd_reject : spdk_nvmf_rdma_reject_private_data , _bindgen_union_align : [ u8 ; 32usize ] , } impl Default for spdk_nvmf_rdma_private_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_PRIVATE_DATA_LENGTH : spdk_nvmf_rdma_transport_error = 1 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_RECFMT : spdk_nvmf_rdma_transport_error = 2 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_QID : spdk_nvmf_rdma_transport_error = 3 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_HSQSIZE : spdk_nvmf_rdma_transport_error = 4 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_HRQSIZE : spdk_nvmf_rdma_transport_error = 5 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_NO_RESOURCES : spdk_nvmf_rdma_transport_error = 6 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_IRD : spdk_nvmf_rdma_transport_error = 7 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_ORD : spdk_nvmf_rdma_transport_error = 8 ; pub type spdk_nvmf_rdma_transport_error = u32 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_IC_REQ : spdk_nvme_tcp_pdu_type = 0 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_IC_RESP : spdk_nvme_tcp_pdu_type = 1 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ : spdk_nvme_tcp_pdu_type = 2 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_C2H_TERM_REQ : spdk_nvme_tcp_pdu_type = 3 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_CAPSULE_CMD : spdk_nvme_tcp_pdu_type = 4 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_CAPSULE_RESP : spdk_nvme_tcp_pdu_type = 5 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_H2C_DATA : spdk_nvme_tcp_pdu_type = 6 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_C2H_DATA : spdk_nvme_tcp_pdu_type = 7 ; pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_R2T : spdk_nvme_tcp_pdu_type = 9 ; pub type spdk_nvme_tcp_pdu_type = u32 ; # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_tcp_common_pdu_hdr { pub pdu_type : u8 , pub flags : u8 , pub hlen : u8 , pub pdo : u8 , pub plen : u32 , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_tcp_ic_req { pub common : spdk_nvme_tcp_common_pdu_hdr , pub pfv : u16 , pub hpda : u8 , pub dgst : spdk_nvme_tcp_ic_req__bindgen_ty_1 , pub maxr2t : u32 , pub reserved16 : [ u8 ; 112usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_tcp_ic_req__bindgen_ty_1 { pub raw : u8 , pub bits : spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn hdgst_enable ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_hdgst_enable ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ddgst_enable ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ddgst_enable ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( hdgst_enable : u8 , ddgst_enable : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let hdgst_enable : u8 = unsafe { :: std :: mem :: transmute ( hdgst_enable ) } ; hdgst_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ddgst_enable : u8 = unsafe { :: std :: mem :: transmute ( ddgst_enable ) } ; ddgst_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_tcp_ic_req__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_tcp_ic_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_tcp_ic_resp { pub common : spdk_nvme_tcp_common_pdu_hdr , pub pfv : u16 , pub cpda : u8 , pub dgst : spdk_nvme_tcp_ic_resp__bindgen_ty_1 , pub maxh2cdata : u32 , pub reserved16 : [ u8 ; 112usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_tcp_ic_resp__bindgen_ty_1 { pub raw : u8 , pub bits : spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn hdgst_enable ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_hdgst_enable ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ddgst_enable ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ddgst_enable ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( hdgst_enable : u8 , ddgst_enable : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let hdgst_enable : u8 = unsafe { :: std :: mem :: transmute ( hdgst_enable ) } ; hdgst_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ddgst_enable : u8 = unsafe { :: std :: mem :: transmute ( ddgst_enable ) } ; ddgst_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_tcp_ic_resp__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_nvme_tcp_ic_resp { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_tcp_term_req_hdr { pub common : spdk_nvme_tcp_common_pdu_hdr , pub fes : u16 , pub fei : [ u8 ; 4usize ] , pub reserved14 : [ u8 ; 10usize ] , } pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_INVALID_HEADER_FIELD : spdk_nvme_tcp_term_req_fes = 1 ; pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_PDU_SEQUENCE_ERROR : spdk_nvme_tcp_term_req_fes = 2 ; pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_HDGST_ERROR : spdk_nvme_tcp_term_req_fes = 3 ; pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_DATA_TRANSFER_OUT_OF_RANGE : spdk_nvme_tcp_term_req_fes = 4 ; pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_DATA_TRANSFER_LIMIT_EXCEEDED : spdk_nvme_tcp_term_req_fes = 5 ; pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_R2T_LIMIT_EXCEEDED : spdk_nvme_tcp_term_req_fes = 5 ; pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_INVALID_DATA_UNSUPPORTED_PARAMETER : spdk_nvme_tcp_term_req_fes = 6 ; pub type spdk_nvme_tcp_term_req_fes = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_tcp_cmd { pub common : spdk_nvme_tcp_common_pdu_hdr , pub ccsqe : spdk_nvme_cmd , } impl Default for spdk_nvme_tcp_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_tcp_rsp { pub common : spdk_nvme_tcp_common_pdu_hdr , pub rccqe : spdk_nvme_cpl , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_tcp_h2c_data_hdr { pub common : spdk_nvme_tcp_common_pdu_hdr , pub cccid : u16 , pub ttag : u16 , pub datao : u32 , pub datal : u32 , pub reserved20 : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_tcp_c2h_data_hdr { pub common : spdk_nvme_tcp_common_pdu_hdr , pub cccid : u16 , pub reserved10 : [ u8 ; 2usize ] , pub datao : u32 , pub datal : u32 , pub reserved20 : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_tcp_r2t_hdr { pub common : spdk_nvme_tcp_common_pdu_hdr , pub cccid : u16 , pub ttag : u16 , pub r2to : u32 , pub r2tl : u32 , pub reserved20 : [ u8 ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_ctrlr { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_opts { pub num_io_queues : u32 , pub use_cmb_sqs : bool , pub arb_mechanism : spdk_nvme_cc_ams , pub keep_alive_timeout_ms : u32 , pub transport_retry_count : libc :: c_int , pub io_queue_size : u32 , pub hostnqn : [ libc :: c_char ; 224usize ] , pub io_queue_requests : u32 , pub src_addr : [ libc :: c_char ; 257usize ] , pub src_svcid : [ libc :: c_char ; 33usize ] , pub host_id : [ u8 ; 8usize ] , pub extended_host_id : [ u8 ; 16usize ] , pub command_set : spdk_nvme_cc_css , pub admin_timeout_ms : u32 , pub header_digest : bool , pub data_digest : bool , } impl Default for spdk_nvme_ctrlr_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_nvme_ctrlr_is_discovery ( ctrlr : * mut spdk_nvme_ctrlr ) -> bool ; } extern "C" { pub fn spdk_nvme_ctrlr_get_default_ctrlr_opts ( opts : * mut spdk_nvme_ctrlr_opts , opts_size : usize ) ; } pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_PCIE : spdk_nvme_transport_type = 256 ; pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_RDMA : spdk_nvme_transport_type = 1 ; pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_FC : spdk_nvme_transport_type = 2 ; pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_TCP : spdk_nvme_transport_type = 3 ; pub type spdk_nvme_transport_type = u32 ; pub use self :: spdk_nvme_transport_type as spdk_nvme_transport_type_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_transport_id { pub trtype : spdk_nvme_transport_type , pub adrfam : spdk_nvmf_adrfam , pub traddr : [ libc :: c_char ; 257usize ] , pub trsvcid : [ libc :: c_char ; 33usize ] , pub subnqn : [ libc :: c_char ; 224usize ] , } impl Default for spdk_nvme_transport_id { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_host_id { pub hostaddr : [ libc :: c_char ; 257usize ] , pub hostsvcid : [ libc :: c_char ; 33usize ] , } impl Default for spdk_nvme_host_id { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_nvme_transport_id_parse ( trid : * mut spdk_nvme_transport_id , str : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_host_id_parse ( hostid : * mut spdk_nvme_host_id , str : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_transport_id_parse_trtype ( trtype : * mut spdk_nvme_transport_type , str : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_transport_id_trtype_str ( trtype : spdk_nvme_transport_type ) -> * const libc :: c_char ; } extern "C" { pub fn spdk_nvme_transport_id_adrfam_str ( adrfam : spdk_nvmf_adrfam ) -> * const libc :: c_char ; } extern "C" { pub fn spdk_nvme_transport_id_parse_adrfam ( adrfam : * mut spdk_nvmf_adrfam , str : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_transport_id_compare ( trid1 : * const spdk_nvme_transport_id , trid2 : * const spdk_nvme_transport_id ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_transport_available ( trtype : spdk_nvme_transport_type ) -> bool ; } pub type spdk_nvme_probe_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , trid : * const spdk_nvme_transport_id , opts : * mut spdk_nvme_ctrlr_opts ) -> bool > ; pub type spdk_nvme_attach_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , trid : * const spdk_nvme_transport_id , ctrlr : * mut spdk_nvme_ctrlr , opts : * const spdk_nvme_ctrlr_opts ) > ; pub type spdk_nvme_remove_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , ctrlr : * mut spdk_nvme_ctrlr ) > ; extern "C" { pub fn spdk_nvme_probe ( trid : * const spdk_nvme_transport_id , cb_ctx : * mut libc :: c_void , probe_cb : spdk_nvme_probe_cb , attach_cb : spdk_nvme_attach_cb , remove_cb : spdk_nvme_remove_cb ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_connect ( trid : * const spdk_nvme_transport_id , opts : * const spdk_nvme_ctrlr_opts , opts_size : usize ) -> * mut spdk_nvme_ctrlr ; } extern "C" { pub fn spdk_nvme_detach ( ctrlr : * mut spdk_nvme_ctrlr ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_reset ( ctrlr : * mut spdk_nvme_ctrlr ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_get_data ( ctrlr : * mut spdk_nvme_ctrlr ) -> * const spdk_nvme_ctrlr_data ; } extern "C" { pub fn spdk_nvme_ctrlr_get_regs_csts ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_csts_register ; } extern "C" { pub fn spdk_nvme_ctrlr_get_regs_cap ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_cap_register ; } extern "C" { pub fn spdk_nvme_ctrlr_get_regs_vs ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_vs_register ; } extern "C" { pub fn spdk_nvme_ctrlr_get_regs_cmbsz ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_cmbsz_register ; } extern "C" { pub fn spdk_nvme_ctrlr_get_num_ns ( ctrlr : * mut spdk_nvme_ctrlr ) -> u32 ; } extern "C" { pub fn spdk_nvme_ctrlr_get_pci_device ( ctrlr : * mut spdk_nvme_ctrlr ) -> * mut spdk_pci_device ; } extern "C" { pub fn spdk_nvme_ctrlr_get_max_xfer_size ( ctrlr : * const spdk_nvme_ctrlr ) -> u32 ; } extern "C" { pub fn spdk_nvme_ctrlr_is_active_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 ) -> bool ; } extern "C" { pub fn spdk_nvme_ctrlr_get_first_active_ns ( ctrlr : * mut spdk_nvme_ctrlr ) -> u32 ; } extern "C" { pub fn spdk_nvme_ctrlr_get_next_active_ns ( ctrlr : * mut spdk_nvme_ctrlr , prev_nsid : u32 ) -> u32 ; } extern "C" { pub fn spdk_nvme_ctrlr_is_log_page_supported ( ctrlr : * mut spdk_nvme_ctrlr , log_page : u8 ) -> bool ; } extern "C" { pub fn spdk_nvme_ctrlr_is_feature_supported ( ctrlr : * mut spdk_nvme_ctrlr , feature_code : u8 ) -> bool ; } pub type spdk_nvme_cmd_cb = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void , arg2 : * const spdk_nvme_cpl ) > ; pub type spdk_nvme_aer_cb = :: std :: option :: Option < unsafe extern "C" fn ( aer_cb_arg : * mut libc :: c_void , arg1 : * const spdk_nvme_cpl ) > ; extern "C" { pub fn spdk_nvme_ctrlr_register_aer_callback ( ctrlr : * mut spdk_nvme_ctrlr , aer_cb_fn : spdk_nvme_aer_cb , aer_cb_arg : * mut libc :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_qpair { _unused : [ u8 ; 0 ] , } pub type spdk_nvme_timeout_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cid : u16 ) > ; extern "C" { pub fn spdk_nvme_ctrlr_register_timeout_callback ( ctrlr : * mut spdk_nvme_ctrlr , timeout_us : u64 , cb_fn : spdk_nvme_timeout_cb , cb_arg : * mut libc :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_io_qpair_opts { pub qprio : spdk_nvme_qprio , pub io_queue_size : u32 , pub io_queue_requests : u32 , } impl Default for spdk_nvme_io_qpair_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn spdk_nvme_ctrlr_get_default_io_qpair_opts ( ctrlr : * mut spdk_nvme_ctrlr , opts : * mut spdk_nvme_io_qpair_opts , opts_size : usize ) ; } extern "C" { pub fn spdk_nvme_ctrlr_alloc_io_qpair ( ctrlr : * mut spdk_nvme_ctrlr , opts : * const spdk_nvme_io_qpair_opts , opts_size : usize ) -> * mut spdk_nvme_qpair ; } extern "C" { pub fn spdk_nvme_ctrlr_free_io_qpair ( qpair : * mut spdk_nvme_qpair ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_io_raw ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cmd : * mut spdk_nvme_cmd , buf : * mut libc :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_io_raw_with_md ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cmd : * mut spdk_nvme_cmd , buf : * mut libc :: c_void , len : u32 , md_buf : * mut libc :: c_void , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_qpair_process_completions ( qpair : * mut spdk_nvme_qpair , max_completions : u32 ) -> i32 ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_admin_raw ( ctrlr : * mut spdk_nvme_ctrlr , cmd : * mut spdk_nvme_cmd , buf : * mut libc :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_process_admin_completions ( ctrlr : * mut spdk_nvme_ctrlr ) -> i32 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_ns { _unused : [ u8 ; 0 ] , } extern "C" { pub fn spdk_nvme_ctrlr_get_ns ( ctrlr : * mut spdk_nvme_ctrlr , ns_id : u32 ) -> * mut spdk_nvme_ns ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_get_log_page ( ctrlr : * mut spdk_nvme_ctrlr , log_page : u8 , nsid : u32 , payload : * mut libc :: c_void , payload_size : u32 , offset : u64 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_abort ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cid : u16 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_set_feature ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , cdw12 : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_get_feature ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_get_feature_ns ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , ns_id : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_cmd_set_feature_ns ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , cdw12 : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , ns_id : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_security_receive ( ctrlr : * mut spdk_nvme_ctrlr , secp : u8 , spsp : u16 , nssf : u8 , payload : * mut libc :: c_void , size : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_security_send ( ctrlr : * mut spdk_nvme_ctrlr , secp : u8 , spsp : u16 , nssf : u8 , payload : * mut libc :: c_void , size : usize ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_attach_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , payload : * mut spdk_nvme_ctrlr_list ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_detach_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , payload : * mut spdk_nvme_ctrlr_list ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_create_ns ( ctrlr : * mut spdk_nvme_ctrlr , payload : * mut spdk_nvme_ns_data ) -> u32 ; } extern "C" { pub fn spdk_nvme_ctrlr_delete_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_format ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , format : * mut spdk_nvme_format ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_update_firmware ( ctrlr : * mut spdk_nvme_ctrlr , payload : * mut libc :: c_void , size : u32 , slot : libc :: c_int , commit_action : spdk_nvme_fw_commit_action , completion_status : * mut spdk_nvme_status ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ctrlr_alloc_cmb_io_buffer ( ctrlr : * mut spdk_nvme_ctrlr , size : usize ) -> * mut libc :: c_void ; } extern "C" { pub fn spdk_nvme_ctrlr_free_cmb_io_buffer ( ctrlr : * mut spdk_nvme_ctrlr , buf : * mut libc :: c_void , size : usize ) ; } extern "C" { pub fn spdk_nvme_ns_get_data ( ns : * mut spdk_nvme_ns ) -> * const spdk_nvme_ns_data ; } extern "C" { pub fn spdk_nvme_ns_get_id ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { pub fn spdk_nvme_ns_get_ctrlr ( ns : * mut spdk_nvme_ns ) -> * mut spdk_nvme_ctrlr ; } extern "C" { pub fn spdk_nvme_ns_is_active ( ns : * mut spdk_nvme_ns ) -> bool ; } extern "C" { pub fn spdk_nvme_ns_get_max_io_xfer_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { pub fn spdk_nvme_ns_get_sector_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { pub fn spdk_nvme_ns_get_extended_sector_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { pub fn spdk_nvme_ns_get_num_sectors ( ns : * mut spdk_nvme_ns ) -> u64 ; } extern "C" { pub fn spdk_nvme_ns_get_size ( ns : * mut spdk_nvme_ns ) -> u64 ; } extern "C" { pub fn spdk_nvme_ns_get_pi_type ( ns : * mut spdk_nvme_ns ) -> spdk_nvme_pi_type ; } extern "C" { pub fn spdk_nvme_ns_get_md_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { pub fn spdk_nvme_ns_supports_extended_lba ( ns : * mut spdk_nvme_ns ) -> bool ; } extern "C" { pub fn spdk_nvme_ns_get_dealloc_logical_block_read_value ( ns : * mut spdk_nvme_ns ) -> spdk_nvme_dealloc_logical_block_read_value ; } extern "C" { pub fn spdk_nvme_ns_get_optimal_io_boundary ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { pub fn spdk_nvme_ns_get_uuid ( ns : * const spdk_nvme_ns ) -> * const spdk_uuid ; } pub const spdk_nvme_ns_flags_SPDK_NVME_NS_DEALLOCATE_SUPPORTED : spdk_nvme_ns_flags = 1 ; pub const spdk_nvme_ns_flags_SPDK_NVME_NS_FLUSH_SUPPORTED : spdk_nvme_ns_flags = 2 ; pub const spdk_nvme_ns_flags_SPDK_NVME_NS_RESERVATION_SUPPORTED : spdk_nvme_ns_flags = 4 ; pub const spdk_nvme_ns_flags_SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED : spdk_nvme_ns_flags = 8 ; pub const spdk_nvme_ns_flags_SPDK_NVME_NS_DPS_PI_SUPPORTED : spdk_nvme_ns_flags = 16 ; pub const spdk_nvme_ns_flags_SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED : spdk_nvme_ns_flags = 32 ; pub type spdk_nvme_ns_flags = u32 ; extern "C" { pub fn spdk_nvme_ns_get_flags ( ns : * mut spdk_nvme_ns ) -> u32 ; } pub type spdk_nvme_req_reset_sgl_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , offset : u32 ) > ; pub type spdk_nvme_req_next_sge_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , address : * mut * mut libc :: c_void , length : * mut u32 ) -> libc :: c_int > ; extern "C" { pub fn spdk_nvme_ns_cmd_write ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_writev ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_writev_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb , metadata : * mut libc :: c_void , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_write_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , metadata : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_write_zeroes ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_read ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_readv ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_readv_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb , metadata : * mut libc :: c_void , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_read_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , metadata : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_dataset_management ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , type_ : u32 , ranges : * const spdk_nvme_dsm_range , num_ranges : u16 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_flush ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_reservation_register ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_register_data , ignore_key : bool , action : spdk_nvme_reservation_register_action , cptpl : spdk_nvme_reservation_register_cptpl , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_reservation_release ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_key_data , ignore_key : bool , action : spdk_nvme_reservation_release_action , type_ : spdk_nvme_reservation_type , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_reservation_acquire ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_acquire_data , ignore_key : bool , action : spdk_nvme_reservation_acquire_action , type_ : spdk_nvme_reservation_type , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_reservation_report ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_compare ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_comparev ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ns_cmd_compare_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut libc :: c_void , metadata : * mut libc :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_qpair_add_cmd_error_injection ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , opc : u8 , do_not_submit : bool , timeout_in_us : u64 , err_count : u32 , sct : u8 , sc : u8 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_qpair_remove_cmd_error_injection ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , opc : u8 ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_dev_lba_fmt { pub grp_len : u8 , pub pu_len : u8 , pub chk_len : u8 , pub lbk_len : u8 , pub reserved : [ u8 ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ocssd_geometry_data { pub mjr : u8 , pub mnr : u8 , pub reserved1 : [ u8 ; 6usize ] , pub lbaf : spdk_ocssd_dev_lba_fmt , pub mccap : spdk_ocssd_geometry_data__bindgen_ty_1 , pub reserved2 : [ u8 ; 12usize ] , pub wit : u8 , pub reserved3 : [ u8 ; 31usize ] , pub num_grp : u16 , pub num_pu : u16 , pub num_chk : u32 , pub clba : u32 , pub reserved4 : [ u8 ; 52usize ] , pub ws_min : u32 , pub ws_opt : u32 , pub mw_cunits : u32 , pub maxoc : u32 , pub maxocpu : u32 , pub reserved5 : [ u8 ; 44usize ] , pub trdt : u32 , pub trdm : u32 , pub twrt : u32 , pub twrm : u32 , pub tcrst : u32 , pub tcrsm : u32 , pub reserved6 : [ u8 ; 40usize ] , pub reserved7 : [ u8 ; 2816usize ] , pub vs : [ u8 ; 1024usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_geometry_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_ocssd_geometry_data__bindgen_ty_1 { # [ inline ] pub fn vec_chk_cpy ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_vec_chk_cpy ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn multi_reset ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_multi_reset ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( vec_chk_cpy : u32 , multi_reset : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let vec_chk_cpy : u32 = unsafe { :: std :: mem :: transmute ( vec_chk_cpy ) } ; vec_chk_cpy as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let multi_reset : u32 = unsafe { :: std :: mem :: transmute ( multi_reset ) } ; multi_reset as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_ocssd_geometry_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_chunk_information_entry { pub cs : spdk_ocssd_chunk_information_entry__bindgen_ty_1 , pub ct : spdk_ocssd_chunk_information_entry__bindgen_ty_2 , pub wli : u8 , pub reserved : [ u8 ; 5usize ] , pub slba : u64 , pub cnlb : u64 , pub wp : u64 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_chunk_information_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_ocssd_chunk_information_entry__bindgen_ty_1 { # [ inline ] pub fn free ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_free ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn closed ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_closed ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn open ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_open ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn offline ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_offline ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( free : u8 , closed : u8 , open : u8 , offline : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let free : u8 = unsafe { :: std :: mem :: transmute ( free ) } ; free as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let closed : u8 = unsafe { :: std :: mem :: transmute ( closed ) } ; closed as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let open : u8 = unsafe { :: std :: mem :: transmute ( open ) } ; open as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let offline : u8 = unsafe { :: std :: mem :: transmute ( offline ) } ; offline as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_chunk_information_entry__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_ocssd_chunk_information_entry__bindgen_ty_2 { # [ inline ] pub fn seq_write ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_seq_write ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rnd_write ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_rnd_write ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn size_deviate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_size_deviate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( seq_write : u8 , rnd_write : u8 , reserved1 : u8 , size_deviate : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let seq_write : u8 = unsafe { :: std :: mem :: transmute ( seq_write ) } ; seq_write as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let rnd_write : u8 = unsafe { :: std :: mem :: transmute ( rnd_write ) } ; rnd_write as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let size_deviate : u8 = unsafe { :: std :: mem :: transmute ( size_deviate ) } ; size_deviate as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_chunk_notification_entry { pub nc : u64 , pub lba : u64 , pub nsid : u32 , pub state : spdk_ocssd_chunk_notification_entry__bindgen_ty_1 , pub mask : spdk_ocssd_chunk_notification_entry__bindgen_ty_2 , pub rsvd : [ u8 ; 9usize ] , pub nlb : u16 , pub rsvd2 : [ u8 ; 30usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_chunk_notification_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , } impl spdk_ocssd_chunk_notification_entry__bindgen_ty_1 { # [ inline ] pub fn error_rate_low ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_error_rate_low ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn error_rate_medium ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_error_rate_medium ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn error_rate_high ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_error_rate_high ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn unrecoverable ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_unrecoverable ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn refreshed ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_refreshed ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn wit_exceeded ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_wit_exceeded ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rsvd2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_rsvd2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( error_rate_low : u8 , error_rate_medium : u8 , error_rate_high : u8 , unrecoverable : u8 , refreshed : u8 , rsvd : u8 , wit_exceeded : u8 , rsvd2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let error_rate_low : u8 = unsafe { :: std :: mem :: transmute ( error_rate_low ) } ; error_rate_low as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let error_rate_medium : u8 = unsafe { :: std :: mem :: transmute ( error_rate_medium ) } ; error_rate_medium as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let error_rate_high : u8 = unsafe { :: std :: mem :: transmute ( error_rate_high ) } ; error_rate_high as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let unrecoverable : u8 = unsafe { :: std :: mem :: transmute ( unrecoverable ) } ; unrecoverable as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let refreshed : u8 = unsafe { :: std :: mem :: transmute ( refreshed ) } ; refreshed as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let rsvd : u8 = unsafe { :: std :: mem :: transmute ( rsvd ) } ; rsvd as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let wit_exceeded : u8 = unsafe { :: std :: mem :: transmute ( wit_exceeded ) } ; wit_exceeded as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 7u8 , { let rsvd2 : u8 = unsafe { :: std :: mem :: transmute ( rsvd2 ) } ; rsvd2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_chunk_notification_entry__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } impl spdk_ocssd_chunk_notification_entry__bindgen_ty_2 { # [ inline ] pub fn lblk ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_lblk ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn chunk ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_chunk ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pu ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pu ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( lblk : u8 , chunk : u8 , pu : u8 , rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let lblk : u8 = unsafe { :: std :: mem :: transmute ( lblk ) } ; lblk as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let chunk : u8 = unsafe { :: std :: mem :: transmute ( chunk ) } ; chunk as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let pu : u8 = unsafe { :: std :: mem :: transmute ( pu ) } ; pu as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let rsvd : u8 = unsafe { :: std :: mem :: transmute ( rsvd ) } ; rsvd as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ocssd_vector_cpl { pub lba_status : u64 , pub sqhd : u16 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , } pub const spdk_ocssd_admin_opcode_SPDK_OCSSD_OPC_GEOMETRY : spdk_ocssd_admin_opcode = 226 ; pub type spdk_ocssd_admin_opcode = u32 ; pub const spdk_ocssd_io_opcode_SPDK_OCSSD_OPC_VECTOR_RESET : spdk_ocssd_io_opcode = 144 ; pub const spdk_ocssd_io_opcode_SPDK_OCSSD_OPC_VECTOR_WRITE : spdk_ocssd_io_opcode = 145 ; pub const spdk_ocssd_io_opcode_SPDK_OCSSD_OPC_VECTOR_READ : spdk_ocssd_io_opcode = 146 ; pub const spdk_ocssd_io_opcode_SPDK_OCSSD_OPC_VECTOR_COPY : spdk_ocssd_io_opcode = 147 ; pub type spdk_ocssd_io_opcode = u32 ; pub const spdk_ocssd_log_page_SPDK_OCSSD_LOG_CHUNK_INFO : spdk_ocssd_log_page = 202 ; pub const spdk_ocssd_log_page_SPDK_OCSSD_LOG_CHUNK_NOTIFICATION : spdk_ocssd_log_page = 208 ; pub type spdk_ocssd_log_page = u32 ; pub const spdk_ocssd_feat_SPDK_OCSSD_FEAT_MEDIA_FEEDBACK : spdk_ocssd_feat = 202 ; pub type spdk_ocssd_feat = u32 ; pub const spdk_ocssd_media_error_status_code_SPDK_OCSSD_SC_OFFLINE_CHUNK : spdk_ocssd_media_error_status_code = 192 ; pub const spdk_ocssd_media_error_status_code_SPDK_OCSSD_SC_INVALID_RESET : spdk_ocssd_media_error_status_code = 193 ; pub const spdk_ocssd_media_error_status_code_SPDK_OCSSD_SC_WRITE_FAIL_WRITE_NEXT_UNIT : spdk_ocssd_media_error_status_code = 240 ; pub const spdk_ocssd_media_error_status_code_SPDK_OCSSD_SC_WRITE_FAIL_CHUNK_EARLY_CLOSE : spdk_ocssd_media_error_status_code = 241 ; pub const spdk_ocssd_media_error_status_code_SPDK_OCSSD_SC_OUT_OF_ORDER_WRITE : spdk_ocssd_media_error_status_code = 242 ; pub const spdk_ocssd_media_error_status_code_SPDK_OCSSD_SC_READ_HIGH_ECC : spdk_ocssd_media_error_status_code = 208 ; pub type spdk_ocssd_media_error_status_code = u32 ; extern "C" { pub fn spdk_nvme_ctrlr_is_ocssd_supported ( ctrlr : * mut spdk_nvme_ctrlr ) -> bool ; } extern "C" { pub fn spdk_nvme_ocssd_ctrlr_cmd_geometry ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , payload : * mut libc :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ocssd_ns_cmd_vector_reset ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba_list : * mut u64 , num_lbas : u32 , chunk_info : * mut spdk_ocssd_chunk_information_entry , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ocssd_ns_cmd_vector_write ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , buffer : * mut libc :: c_void , lba_list : * mut u64 , num_lbas : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ocssd_ns_cmd_vector_write_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , buffer : * mut libc :: c_void , metadata : * mut libc :: c_void , lba_list : * mut u64 , num_lbas : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ocssd_ns_cmd_vector_read ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , buffer : * mut libc :: c_void , lba_list : * mut u64 , num_lbas : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ocssd_ns_cmd_vector_read_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , buffer : * mut libc :: c_void , metadata : * mut libc :: c_void , lba_list : * mut u64 , num_lbas : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } extern "C" { pub fn spdk_nvme_ocssd_ns_cmd_vector_copy ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , dst_lba_list : * mut u64 , src_lba_list : * mut u64 , num_lbas : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut libc :: c_void , io_flags : u32 ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_ftl_dev { _unused : [ u8 ; 0 ] , } pub const SPDK_FTL_LIMIT_CRIT : _bindgen_ty_35 = 0 ; pub const SPDK_FTL_LIMIT_HIGH : _bindgen_ty_35 = 1 ; pub const SPDK_FTL_LIMIT_LOW : _bindgen_ty_35 = 2 ; pub const SPDK_FTL_LIMIT_START : _bindgen_ty_35 = 3 ; pub const SPDK_FTL_LIMIT_MAX : _bindgen_ty_35 = 4 ; pub type _bindgen_ty_35 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ftl_limit { pub thld : usize , pub limit : usize , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ftl_conf { pub lba_rsvd : usize , pub rwb_size : usize , pub band_thld : usize , pub max_reloc_qdepth : usize , pub max_active_relocs : usize , pub user_io_pool_size : usize , pub defrag : spdk_ftl_conf__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ftl_conf__bindgen_ty_1 { pub invalid_thld : usize , pub limits : [ spdk_ftl_limit ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ftl_punit_range { pub begin : libc :: c_uint , pub end : libc :: c_uint , } pub const spdk_ftl_mode_SPDK_FTL_MODE_CREATE : spdk_ftl_mode = 1 ; pub type spdk_ftl_mode = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ftl_dev_init_opts { pub ctrlr : * mut spdk_nvme_ctrlr , pub trid : spdk_nvme_transport_id , pub core_thread : * mut spdk_thread , pub read_thread : * mut spdk_thread , pub conf : * mut spdk_ftl_conf , pub name : * const libc :: c_char , pub range : spdk_ftl_punit_range , pub mode : libc :: c_uint , pub uuid : spdk_uuid , } impl Default for spdk_ftl_dev_init_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ftl_attrs { pub uuid : spdk_uuid , pub range : spdk_ftl_punit_range , pub lbk_cnt : u64 , pub lbk_size : usize , } impl Default for spdk_ftl_attrs { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ftl_module_init_opts { pub anm_thread : * mut spdk_thread , } impl Default for ftl_module_init_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type spdk_ftl_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut libc :: c_void , arg2 : libc :: c_int ) > ; pub type spdk_ftl_init_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut spdk_ftl_dev , arg2 : * mut libc :: c_void , arg3 : libc :: c_int ) > ; extern "C" { 
 /// Initialize the FTL module.
///
/// \param opts module configuration
/// \param cb callback function to call when the module is initialized
/// \param cb_arg callback's argument
///
/// \return 0 if successfully started initialization, negative values if
/// resources could not be allocated. 
 pub fn spdk_ftl_module_init ( opts : * const ftl_module_init_opts , cb : spdk_ftl_fn , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Deinitialize the FTL module. All FTL devices have to be unregistered prior to
/// calling this function.
///
/// \param cb callback function to call when the deinitialization is completed
/// \param cb_arg callback's argument
///
/// \return 0 if successfully scheduled deinitialization, negative errno
/// otherwise. 
 pub fn spdk_ftl_module_fini ( cb : spdk_ftl_fn , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Initialize the FTL on given NVMe device and parallel unit range.
///
/// Covers the following:
/// - initialize and register NVMe ctrlr,
/// - retrieve geometry and check if the device has proper configuration,
/// - allocate buffers and resources,
/// - initialize internal structures,
/// - initialize internal thread(s),
/// - restore or create L2P table.
///
/// \param opts configuration for new device
/// \param cb callback function to call when the device is created
/// \param cb_arg callback's argument
///
/// \return 0 if initialization was started successfully, negative errno otherwise. 
 pub fn spdk_ftl_dev_init ( opts : * const spdk_ftl_dev_init_opts , cb : spdk_ftl_init_fn , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Deinitialize and free given device.
///
/// \param dev device
/// \param cb callback function to call when the device is freed
/// \param cb_arg callback's argument
///
/// \return 0 if successfully scheduled free, negative errno otherwise. 
 pub fn spdk_ftl_dev_free ( dev : * mut spdk_ftl_dev , cb : spdk_ftl_fn , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Initialize FTL configuration structure with default values.
///
/// \param conf FTL configuration to initialize 
 pub fn spdk_ftl_conf_init_defaults ( conf : * mut spdk_ftl_conf ) ; } extern "C" { 
 /// Retrieve devices attributes.
///
/// \param dev device
/// \param attr Attribute structure to fill
///
/// \return 0 if successfully initialized, negated EINVAL otherwise. 
 pub fn spdk_ftl_dev_get_attrs ( dev : * const spdk_ftl_dev , attr : * mut spdk_ftl_attrs ) -> libc :: c_int ; } extern "C" { 
 /// Submits a read to the specified device.
///
/// \param dev Device
/// \param ch I/O channel
/// \param lba Starting LBA to read the data
/// \param lba_cnt Number of sectors to read
/// \param iov Single IO vector or pointer to IO vector table
/// \param iov_cnt Number of IO vectors
/// \param cb_fn Callback function to invoke when the I/O is completed
/// \param cb_arg Argument to pass to the callback function
///
/// \return 0 if successfully submitted, negated EINVAL otherwise. 
 pub fn spdk_ftl_read ( dev : * mut spdk_ftl_dev , ch : * mut spdk_io_channel , lba : u64 , lba_cnt : usize , iov : * mut iovec , iov_cnt : usize , cb_fn : spdk_ftl_fn , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submits a write to the specified device.
///
/// \param dev Device
/// \param ch I/O channel
/// \param lba Starting LBA to write the data
/// \param lba_cnt Number of sectors to write
/// \param iov Single IO vector or pointer to IO vector table
/// \param iov_cnt Number of IO vectors
/// \param cb_fn Callback function to invoke when the I/O is completed
/// \param cb_arg Argument to pass to the callback function
///
/// \return 0 if successfully submitted, negative values otherwise. 
 pub fn spdk_ftl_write ( dev : * mut spdk_ftl_dev , ch : * mut spdk_io_channel , lba : u64 , lba_cnt : usize , iov : * mut iovec , iov_cnt : usize , cb_fn : spdk_ftl_fn , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Submits a flush request to the specified device.
///
/// \param dev device
/// \param cb_fn Callback function to invoke when all prior IOs have been completed
/// \param cb_arg Argument to pass to the callback function
///
/// \return 0 if successfully submitted, negated EINVAL or ENOMEM otherwise. 
 pub fn spdk_ftl_flush ( dev : * mut spdk_ftl_dev , cb_fn : spdk_ftl_fn , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_mbr_chs { pub head : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , } impl spdk_mbr_chs { # [ inline ] pub fn sector ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u16 ) } } # [ inline ] pub fn set_sector ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn cylinder ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 10u8 ) as u16 ) } } # [ inline ] pub fn set_cylinder ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( sector : u16 , cylinder : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let sector : u16 = unsafe { :: std :: mem :: transmute ( sector ) } ; sector as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 10u8 , { let cylinder : u16 = unsafe { :: std :: mem :: transmute ( cylinder ) } ; cylinder as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_mbr_partition_entry { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub start_chs : spdk_mbr_chs , pub os_type : u8 , pub end_chs : spdk_mbr_chs , pub start_lba : u32 , pub size_lba : u32 , } impl spdk_mbr_partition_entry { # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn bootable ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_bootable ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( reserved : u8 , bootable : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let bootable : u8 = unsafe { :: std :: mem :: transmute ( bootable ) } ; bootable as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_mbr { pub boot_code : [ u8 ; 440usize ] , pub disk_signature : u32 , pub reserved_444 : u16 , pub partitions : [ spdk_mbr_partition_entry ; 4usize ] , pub mbr_signature : u16 , } impl Default for spdk_mbr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_gpt_guid { pub raw : [ u8 ; 16usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_gpt_header { pub gpt_signature : [ libc :: c_char ; 8usize ] , pub revision : u32 , pub header_size : u32 , pub header_crc32 : u32 , pub reserved : u32 , pub my_lba : u64 , pub alternate_lba : u64 , pub first_usable_lba : u64 , pub last_usable_lba : u64 , pub disk_guid : spdk_gpt_guid , pub partition_entry_lba : u64 , pub num_partition_entries : u32 , pub size_of_partition_entry : u32 , pub partition_entry_array_crc32 : u32 , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_gpt_partition_entry { pub part_type_guid : spdk_gpt_guid , pub unique_partition_guid : spdk_gpt_guid , pub starting_lba : u64 , pub ending_lba : u64 , pub attr : spdk_gpt_partition_entry__bindgen_ty_1 , pub partition_name : [ u16 ; 36usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_gpt_partition_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > , } impl spdk_gpt_partition_entry__bindgen_ty_1 { # [ inline ] pub fn required ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_required ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn no_block_io_proto ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_no_block_io_proto ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn legacy_bios_bootable ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u64 ) } } # [ inline ] pub fn set_legacy_bios_bootable ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved_uefi ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 45u8 ) as u64 ) } } # [ inline ] pub fn set_reserved_uefi ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 45u8 , val as u64 ) } } # [ inline ] pub fn guid_specific ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 48usize , 16u8 ) as u64 ) } } # [ inline ] pub fn set_guid_specific ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 48usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( required : u64 , no_block_io_proto : u64 , legacy_bios_bootable : u64 , reserved_uefi : u64 , guid_specific : u64 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u64 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let required : u64 = unsafe { :: std :: mem :: transmute ( required ) } ; required as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let no_block_io_proto : u64 = unsafe { :: std :: mem :: transmute ( no_block_io_proto ) } ; no_block_io_proto as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let legacy_bios_bootable : u64 = unsafe { :: std :: mem :: transmute ( legacy_bios_bootable ) } ; legacy_bios_bootable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 45u8 , { let reserved_uefi : u64 = unsafe { :: std :: mem :: transmute ( reserved_uefi ) } ; reserved_uefi as u64 } ) ; __bindgen_bitfield_unit . set ( 48usize , 16u8 , { let guid_specific : u64 = unsafe { :: std :: mem :: transmute ( guid_specific ) } ; guid_specific as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_gpt_partition_entry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Opaque handle for a single I/OAT channel returned by \ref spdk_ioat_probe(). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_ioat_chan { _unused : [ u8 ; 0 ] , } 
 /// Signature for callback function invoked when a request is completed.
///
/// \param arg User-specified opaque value corresponding to cb_arg from the
/// request submission. 
 pub type spdk_ioat_req_cb = :: std :: option :: Option < unsafe extern "C" fn ( arg : * mut libc :: c_void ) > ; 
 /// Callback for spdk_ioat_probe() enumeration.
///
/// \param cb_ctx User-specified opaque value corresponding to cb_ctx from spdk_ioat_probe().
/// \param pci_dev PCI device that is being probed.
///
/// \return true to attach to this device. 
 pub type spdk_ioat_probe_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , pci_dev : * mut spdk_pci_device ) -> bool > ; 
 /// Callback for spdk_ioat_probe() to report a device that has been attached to
/// the userspace I/OAT driver.
///
/// \param cb_ctx User-specified opaque value corresponding to cb_ctx from spdk_ioat_probe().
/// \param pci_dev PCI device that was attached to the driver.
/// \param ioat I/OAT channel that was attached to the driver. 
 pub type spdk_ioat_attach_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut libc :: c_void , pci_dev : * mut spdk_pci_device , ioat : * mut spdk_ioat_chan ) > ; extern "C" { 
 /// Enumerate the I/OAT devices attached to the system and attach the userspace
/// I/OAT driver to them if desired.
///
/// If called more than once, only devices that are not already attached to the
/// SPDK I/OAT driver will be reported.
///
/// To stop using the controller and release its associated resources, call
/// spdk_ioat_detach() with the ioat_channel instance returned by this function.
///
/// \param cb_ctx Opaque value which will be passed back in cb_ctx parameter of
/// the callbacks.
/// \param probe_cb will be called once per I/OAT device found in the system.
/// \param attach_cb will be called for devices for which probe_cb returned true
/// once the I/OAT controller has been attached to the userspace driver.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_ioat_probe ( cb_ctx : * mut libc :: c_void , probe_cb : spdk_ioat_probe_cb , attach_cb : spdk_ioat_attach_cb ) -> libc :: c_int ; } extern "C" { 
 /// Detach specified device returned by spdk_ioat_probe() from the I/OAT driver.
///
/// \param ioat I/OAT channel to detach from the driver. 
 pub fn spdk_ioat_detach ( ioat : * mut spdk_ioat_chan ) ; } extern "C" { 
 /// Submit a DMA engine memory copy request.
///
/// \param chan I/OAT channel to submit request.
/// \param cb_arg Opaque value which will be passed back as the arg parameter in
/// the completion callback.
/// \param cb_fn Callback function which will be called when the request is complete.
/// \param dst Destination virtual address.
/// \param src Source virtual address.
/// \param nbytes Number of bytes to copy.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_ioat_submit_copy ( chan : * mut spdk_ioat_chan , cb_arg : * mut libc :: c_void , cb_fn : spdk_ioat_req_cb , dst : * mut libc :: c_void , src : * const libc :: c_void , nbytes : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Submit a DMA engine memory fill request.
///
/// \param chan I/OAT channel to submit request.
/// \param cb_arg Opaque value which will be passed back as the cb_arg parameter
/// in the completion callback.
/// \param cb_fn Callback function which will be called when the request is complete.
/// \param dst Destination virtual address.
/// \param fill_pattern Repeating eight-byte pattern to use for memory fill.
/// \param nbytes Number of bytes to fill.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_ioat_submit_fill ( chan : * mut spdk_ioat_chan , cb_arg : * mut libc :: c_void , cb_fn : spdk_ioat_req_cb , dst : * mut libc :: c_void , fill_pattern : u64 , nbytes : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Check for completed requests on an I/OAT channel.
///
/// \param chan I/OAT channel to check for completions.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_ioat_process_events ( chan : * mut spdk_ioat_chan ) -> libc :: c_int ; } 
 ///< The memory copy is supported 
 pub const spdk_ioat_dma_capability_flags_SPDK_IOAT_ENGINE_COPY_SUPPORTED : spdk_ioat_dma_capability_flags = 1 ; 
 ///< The memory fill is supported 
 pub const spdk_ioat_dma_capability_flags_SPDK_IOAT_ENGINE_FILL_SUPPORTED : spdk_ioat_dma_capability_flags = 2 ; 
 /// DMA engine capability flags 
 pub type spdk_ioat_dma_capability_flags = u32 ; extern "C" { 
 /// Get the DMA engine capabilities.
///
/// \param chan I/OAT channel to query.
///
/// \return a combination of flags from spdk_ioat_dma_capability_flags(). 
 pub fn spdk_ioat_get_dma_capabilities ( chan : * mut spdk_ioat_chan ) -> u32 ; } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ioat_registers { pub chancnt : u8 , pub xfercap : u8 , pub genctrl : u8 , pub intrctrl : u8 , pub attnstatus : u32 , pub cbver : u8 , pub reserved4 : [ u8 ; 3usize ] , pub intrdelay : u16 , pub cs_status : u16 , pub dmacapability : u32 , pub reserved5 : [ u8 ; 108usize ] , pub chanctrl : u16 , pub reserved6 : [ u8 ; 2usize ] , pub chancmd : u8 , pub reserved3 : [ u8 ; 1usize ] , pub dmacount : u16 , pub chansts : u64 , pub chainaddr : u64 , pub chancmp : u64 , pub reserved2 : [ u8 ; 8usize ] , pub chanerr : u32 , pub chanerrmask : u32 , } impl Default for spdk_ioat_registers { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ioat_generic_hw_desc { pub size : u32 , pub u : spdk_ioat_generic_hw_desc__bindgen_ty_1 , pub src_addr : u64 , pub dest_addr : u64 , pub next : u64 , pub op_specific : [ u64 ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_ioat_generic_hw_desc__bindgen_ty_1 { pub control_raw : u32 , pub control : spdk_ioat_generic_hw_desc__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_generic_hw_desc__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_ioat_generic_hw_desc__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn int_enable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_int_enable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_src_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn completion_update ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_completion_update ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fence ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fence ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_page_break ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_src_page_break ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_page_break ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_page_break ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn bundle ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bundle ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_dca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_dca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn hint ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_hint ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 13u8 , val as u64 ) } } # [ inline ] pub fn op ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_op ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( int_enable : u32 , src_snoop_disable : u32 , dest_snoop_disable : u32 , completion_update : u32 , fence : u32 , reserved2 : u32 , src_page_break : u32 , dest_page_break : u32 , bundle : u32 , dest_dca : u32 , hint : u32 , reserved : u32 , op : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let int_enable : u32 = unsafe { :: std :: mem :: transmute ( int_enable ) } ; int_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let src_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( src_snoop_disable ) } ; src_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dest_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( dest_snoop_disable ) } ; dest_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let completion_update : u32 = unsafe { :: std :: mem :: transmute ( completion_update ) } ; completion_update as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let fence : u32 = unsafe { :: std :: mem :: transmute ( fence ) } ; fence as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let src_page_break : u32 = unsafe { :: std :: mem :: transmute ( src_page_break ) } ; src_page_break as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let dest_page_break : u32 = unsafe { :: std :: mem :: transmute ( dest_page_break ) } ; dest_page_break as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let bundle : u32 = unsafe { :: std :: mem :: transmute ( bundle ) } ; bundle as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let dest_dca : u32 = unsafe { :: std :: mem :: transmute ( dest_dca ) } ; dest_dca as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let hint : u32 = unsafe { :: std :: mem :: transmute ( hint ) } ; hint as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 13u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let op : u32 = unsafe { :: std :: mem :: transmute ( op ) } ; op as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_ioat_generic_hw_desc__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_ioat_generic_hw_desc { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ioat_dma_hw_desc { pub size : u32 , pub u : spdk_ioat_dma_hw_desc__bindgen_ty_1 , pub src_addr : u64 , pub dest_addr : u64 , pub next : u64 , pub reserved : u64 , pub reserved2 : u64 , pub user1 : u64 , pub user2 : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_ioat_dma_hw_desc__bindgen_ty_1 { pub control_raw : u32 , pub control : spdk_ioat_dma_hw_desc__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_dma_hw_desc__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_ioat_dma_hw_desc__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn int_enable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_int_enable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_src_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn completion_update ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_completion_update ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fence ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fence ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn null ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_null ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_page_break ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_src_page_break ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_page_break ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_page_break ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn bundle ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bundle ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_dca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_dca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn hint ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_hint ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 13u8 , val as u64 ) } } # [ inline ] pub fn op ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_op ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( int_enable : u32 , src_snoop_disable : u32 , dest_snoop_disable : u32 , completion_update : u32 , fence : u32 , null : u32 , src_page_break : u32 , dest_page_break : u32 , bundle : u32 , dest_dca : u32 , hint : u32 , reserved : u32 , op : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let int_enable : u32 = unsafe { :: std :: mem :: transmute ( int_enable ) } ; int_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let src_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( src_snoop_disable ) } ; src_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dest_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( dest_snoop_disable ) } ; dest_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let completion_update : u32 = unsafe { :: std :: mem :: transmute ( completion_update ) } ; completion_update as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let fence : u32 = unsafe { :: std :: mem :: transmute ( fence ) } ; fence as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let null : u32 = unsafe { :: std :: mem :: transmute ( null ) } ; null as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let src_page_break : u32 = unsafe { :: std :: mem :: transmute ( src_page_break ) } ; src_page_break as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let dest_page_break : u32 = unsafe { :: std :: mem :: transmute ( dest_page_break ) } ; dest_page_break as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let bundle : u32 = unsafe { :: std :: mem :: transmute ( bundle ) } ; bundle as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let dest_dca : u32 = unsafe { :: std :: mem :: transmute ( dest_dca ) } ; dest_dca as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let hint : u32 = unsafe { :: std :: mem :: transmute ( hint ) } ; hint as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 13u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let op : u32 = unsafe { :: std :: mem :: transmute ( op ) } ; op as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_ioat_dma_hw_desc__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_ioat_dma_hw_desc { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ioat_fill_hw_desc { pub size : u32 , pub u : spdk_ioat_fill_hw_desc__bindgen_ty_1 , pub src_data : u64 , pub dest_addr : u64 , pub next : u64 , pub reserved : u64 , pub next_dest_addr : u64 , pub user1 : u64 , pub user2 : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_ioat_fill_hw_desc__bindgen_ty_1 { pub control_raw : u32 , pub control : spdk_ioat_fill_hw_desc__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_fill_hw_desc__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_ioat_fill_hw_desc__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn int_enable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_int_enable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn completion_update ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_completion_update ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fence ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fence ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 2u8 , val as u64 ) } } # [ inline ] pub fn dest_page_break ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_page_break ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn bundle ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bundle ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 15u8 , val as u64 ) } } # [ inline ] pub fn op ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_op ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( int_enable : u32 , reserved : u32 , dest_snoop_disable : u32 , completion_update : u32 , fence : u32 , reserved2 : u32 , dest_page_break : u32 , bundle : u32 , reserved3 : u32 , op : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let int_enable : u32 = unsafe { :: std :: mem :: transmute ( int_enable ) } ; int_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dest_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( dest_snoop_disable ) } ; dest_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let completion_update : u32 = unsafe { :: std :: mem :: transmute ( completion_update ) } ; completion_update as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let fence : u32 = unsafe { :: std :: mem :: transmute ( fence ) } ; fence as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 2u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let dest_page_break : u32 = unsafe { :: std :: mem :: transmute ( dest_page_break ) } ; dest_page_break as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let bundle : u32 = unsafe { :: std :: mem :: transmute ( bundle ) } ; bundle as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 15u8 , { let reserved3 : u32 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let op : u32 = unsafe { :: std :: mem :: transmute ( op ) } ; op as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_ioat_fill_hw_desc__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_ioat_fill_hw_desc { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ioat_xor_hw_desc { pub size : u32 , pub u : spdk_ioat_xor_hw_desc__bindgen_ty_1 , pub src_addr : u64 , pub dest_addr : u64 , pub next : u64 , pub src_addr2 : u64 , pub src_addr3 : u64 , pub src_addr4 : u64 , pub src_addr5 : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_ioat_xor_hw_desc__bindgen_ty_1 { pub control_raw : u32 , pub control : spdk_ioat_xor_hw_desc__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_xor_hw_desc__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_ioat_xor_hw_desc__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn int_enable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_int_enable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_src_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn completion_update ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_completion_update ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fence ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fence ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_count ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_src_count ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn bundle ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bundle ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_dca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_dca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn hint ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_hint ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 13u8 , val as u64 ) } } # [ inline ] pub fn op ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_op ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( int_enable : u32 , src_snoop_disable : u32 , dest_snoop_disable : u32 , completion_update : u32 , fence : u32 , src_count : u32 , bundle : u32 , dest_dca : u32 , hint : u32 , reserved : u32 , op : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let int_enable : u32 = unsafe { :: std :: mem :: transmute ( int_enable ) } ; int_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let src_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( src_snoop_disable ) } ; src_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dest_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( dest_snoop_disable ) } ; dest_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let completion_update : u32 = unsafe { :: std :: mem :: transmute ( completion_update ) } ; completion_update as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let fence : u32 = unsafe { :: std :: mem :: transmute ( fence ) } ; fence as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let src_count : u32 = unsafe { :: std :: mem :: transmute ( src_count ) } ; src_count as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let bundle : u32 = unsafe { :: std :: mem :: transmute ( bundle ) } ; bundle as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let dest_dca : u32 = unsafe { :: std :: mem :: transmute ( dest_dca ) } ; dest_dca as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let hint : u32 = unsafe { :: std :: mem :: transmute ( hint ) } ; hint as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 13u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let op : u32 = unsafe { :: std :: mem :: transmute ( op ) } ; op as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_ioat_xor_hw_desc__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_ioat_xor_hw_desc { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_xor_ext_hw_desc { pub src_addr6 : u64 , pub src_addr7 : u64 , pub src_addr8 : u64 , pub next : u64 , pub reserved : [ u64 ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ioat_pq_hw_desc { pub size : u32 , pub u : spdk_ioat_pq_hw_desc__bindgen_ty_1 , pub src_addr : u64 , pub p_addr : u64 , pub next : u64 , pub src_addr2 : u64 , pub src_addr3 : u64 , pub coef : [ u8 ; 8usize ] , pub q_addr : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_ioat_pq_hw_desc__bindgen_ty_1 { pub control_raw : u32 , pub control : spdk_ioat_pq_hw_desc__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_pq_hw_desc__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_ioat_pq_hw_desc__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn int_enable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_int_enable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_src_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn completion_update ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_completion_update ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fence ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fence ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_count ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_src_count ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn bundle ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bundle ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_dca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_dca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn hint ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_hint ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn p_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_p_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn q_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_q_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 11u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 11u8 , val as u64 ) } } # [ inline ] pub fn op ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_op ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( int_enable : u32 , src_snoop_disable : u32 , dest_snoop_disable : u32 , completion_update : u32 , fence : u32 , src_count : u32 , bundle : u32 , dest_dca : u32 , hint : u32 , p_disable : u32 , q_disable : u32 , reserved : u32 , op : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let int_enable : u32 = unsafe { :: std :: mem :: transmute ( int_enable ) } ; int_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let src_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( src_snoop_disable ) } ; src_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dest_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( dest_snoop_disable ) } ; dest_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let completion_update : u32 = unsafe { :: std :: mem :: transmute ( completion_update ) } ; completion_update as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let fence : u32 = unsafe { :: std :: mem :: transmute ( fence ) } ; fence as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let src_count : u32 = unsafe { :: std :: mem :: transmute ( src_count ) } ; src_count as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let bundle : u32 = unsafe { :: std :: mem :: transmute ( bundle ) } ; bundle as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let dest_dca : u32 = unsafe { :: std :: mem :: transmute ( dest_dca ) } ; dest_dca as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let hint : u32 = unsafe { :: std :: mem :: transmute ( hint ) } ; hint as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let p_disable : u32 = unsafe { :: std :: mem :: transmute ( p_disable ) } ; p_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let q_disable : u32 = unsafe { :: std :: mem :: transmute ( q_disable ) } ; q_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 11u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let op : u32 = unsafe { :: std :: mem :: transmute ( op ) } ; op as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_ioat_pq_hw_desc__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_ioat_pq_hw_desc { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_pq_ext_hw_desc { pub src_addr4 : u64 , pub src_addr5 : u64 , pub src_addr6 : u64 , pub next : u64 , pub src_addr7 : u64 , pub src_addr8 : u64 , pub reserved : [ u64 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_ioat_pq_update_hw_desc { pub size : u32 , pub u : spdk_ioat_pq_update_hw_desc__bindgen_ty_1 , pub src_addr : u64 , pub p_addr : u64 , pub next : u64 , pub src_addr2 : u64 , pub p_src : u64 , pub q_src : u64 , pub q_addr : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_ioat_pq_update_hw_desc__bindgen_ty_1 { pub control_raw : u32 , pub control : spdk_ioat_pq_update_hw_desc__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_pq_update_hw_desc__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_ioat_pq_update_hw_desc__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn int_enable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_int_enable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_src_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_snoop_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_snoop_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn completion_update ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_completion_update ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fence ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fence ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn src_cnt ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_src_cnt ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn bundle ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bundle ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dest_dca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dest_dca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn hint ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_hint ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn p_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_p_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn q_disable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_q_disable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn coef ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_coef ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn op ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_op ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( int_enable : u32 , src_snoop_disable : u32 , dest_snoop_disable : u32 , completion_update : u32 , fence : u32 , src_cnt : u32 , bundle : u32 , dest_dca : u32 , hint : u32 , p_disable : u32 , q_disable : u32 , reserved : u32 , coef : u32 , op : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let int_enable : u32 = unsafe { :: std :: mem :: transmute ( int_enable ) } ; int_enable as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let src_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( src_snoop_disable ) } ; src_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dest_snoop_disable : u32 = unsafe { :: std :: mem :: transmute ( dest_snoop_disable ) } ; dest_snoop_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let completion_update : u32 = unsafe { :: std :: mem :: transmute ( completion_update ) } ; completion_update as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let fence : u32 = unsafe { :: std :: mem :: transmute ( fence ) } ; fence as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let src_cnt : u32 = unsafe { :: std :: mem :: transmute ( src_cnt ) } ; src_cnt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let bundle : u32 = unsafe { :: std :: mem :: transmute ( bundle ) } ; bundle as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let dest_dca : u32 = unsafe { :: std :: mem :: transmute ( dest_dca ) } ; dest_dca as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let hint : u32 = unsafe { :: std :: mem :: transmute ( hint ) } ; hint as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let p_disable : u32 = unsafe { :: std :: mem :: transmute ( p_disable ) } ; p_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let q_disable : u32 = unsafe { :: std :: mem :: transmute ( q_disable ) } ; q_disable as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let coef : u32 = unsafe { :: std :: mem :: transmute ( coef ) } ; coef as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let op : u32 = unsafe { :: std :: mem :: transmute ( op ) } ; op as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_ioat_pq_update_hw_desc__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_ioat_pq_update_hw_desc { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_ioat_raw_hw_desc { pub field : [ u64 ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_ioat_hw_desc { pub raw : spdk_ioat_raw_hw_desc , pub generic : spdk_ioat_generic_hw_desc , pub dma : spdk_ioat_dma_hw_desc , pub fill : spdk_ioat_fill_hw_desc , pub xor_desc : spdk_ioat_xor_hw_desc , pub xor_ext : spdk_ioat_xor_ext_hw_desc , pub pq : spdk_ioat_pq_hw_desc , pub pq_ext : spdk_ioat_pq_ext_hw_desc , pub pq_update : spdk_ioat_pq_update_hw_desc , _bindgen_union_align : [ u64 ; 8usize ] , } impl Default for spdk_ioat_hw_desc { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const iscsi_op_ISCSI_OP_NOPOUT : iscsi_op = 0 ; pub const iscsi_op_ISCSI_OP_SCSI : iscsi_op = 1 ; pub const iscsi_op_ISCSI_OP_TASK : iscsi_op = 2 ; pub const iscsi_op_ISCSI_OP_LOGIN : iscsi_op = 3 ; pub const iscsi_op_ISCSI_OP_TEXT : iscsi_op = 4 ; pub const iscsi_op_ISCSI_OP_SCSI_DATAOUT : iscsi_op = 5 ; pub const iscsi_op_ISCSI_OP_LOGOUT : iscsi_op = 6 ; pub const iscsi_op_ISCSI_OP_SNACK : iscsi_op = 16 ; pub const iscsi_op_ISCSI_OP_VENDOR_1C : iscsi_op = 28 ; pub const iscsi_op_ISCSI_OP_VENDOR_1D : iscsi_op = 29 ; pub const iscsi_op_ISCSI_OP_VENDOR_1E : iscsi_op = 30 ; pub const iscsi_op_ISCSI_OP_NOPIN : iscsi_op = 32 ; pub const iscsi_op_ISCSI_OP_SCSI_RSP : iscsi_op = 33 ; pub const iscsi_op_ISCSI_OP_TASK_RSP : iscsi_op = 34 ; pub const iscsi_op_ISCSI_OP_LOGIN_RSP : iscsi_op = 35 ; pub const iscsi_op_ISCSI_OP_TEXT_RSP : iscsi_op = 36 ; pub const iscsi_op_ISCSI_OP_SCSI_DATAIN : iscsi_op = 37 ; pub const iscsi_op_ISCSI_OP_LOGOUT_RSP : iscsi_op = 38 ; pub const iscsi_op_ISCSI_OP_R2T : iscsi_op = 49 ; pub const iscsi_op_ISCSI_OP_ASYNC : iscsi_op = 50 ; pub const iscsi_op_ISCSI_OP_VENDOR_3C : iscsi_op = 60 ; pub const iscsi_op_ISCSI_OP_VENDOR_3D : iscsi_op = 61 ; pub const iscsi_op_ISCSI_OP_VENDOR_3E : iscsi_op = 62 ; pub const iscsi_op_ISCSI_OP_REJECT : iscsi_op = 63 ; pub type iscsi_op = u32 ; pub const iscsi_task_func_ISCSI_TASK_FUNC_ABORT_TASK : iscsi_task_func = 1 ; pub const iscsi_task_func_ISCSI_TASK_FUNC_ABORT_TASK_SET : iscsi_task_func = 2 ; pub const iscsi_task_func_ISCSI_TASK_FUNC_CLEAR_ACA : iscsi_task_func = 3 ; pub const iscsi_task_func_ISCSI_TASK_FUNC_CLEAR_TASK_SET : iscsi_task_func = 4 ; pub const iscsi_task_func_ISCSI_TASK_FUNC_LOGICAL_UNIT_RESET : iscsi_task_func = 5 ; pub const iscsi_task_func_ISCSI_TASK_FUNC_TARGET_WARM_RESET : iscsi_task_func = 6 ; pub const iscsi_task_func_ISCSI_TASK_FUNC_TARGET_COLD_RESET : iscsi_task_func = 7 ; pub const iscsi_task_func_ISCSI_TASK_FUNC_TASK_REASSIGN : iscsi_task_func = 8 ; pub type iscsi_task_func = u32 ; pub const iscsi_task_func_resp_ISCSI_TASK_FUNC_RESP_COMPLETE : iscsi_task_func_resp = 0 ; pub const iscsi_task_func_resp_ISCSI_TASK_FUNC_RESP_TASK_NOT_EXIST : iscsi_task_func_resp = 1 ; pub const iscsi_task_func_resp_ISCSI_TASK_FUNC_RESP_LUN_NOT_EXIST : iscsi_task_func_resp = 2 ; pub const iscsi_task_func_resp_ISCSI_TASK_FUNC_RESP_TASK_STILL_ALLEGIANT : iscsi_task_func_resp = 3 ; pub const iscsi_task_func_resp_ISCSI_TASK_FUNC_RESP_REASSIGNMENT_NOT_SUPPORTED : iscsi_task_func_resp = 4 ; pub const iscsi_task_func_resp_ISCSI_TASK_FUNC_RESP_FUNC_NOT_SUPPORTED : iscsi_task_func_resp = 5 ; pub const iscsi_task_func_resp_ISCSI_TASK_FUNC_RESP_AUTHORIZATION_FAILED : iscsi_task_func_resp = 6 ; pub const iscsi_task_func_resp_ISCSI_TASK_FUNC_REJECTED : iscsi_task_func_resp = 255 ; pub type iscsi_task_func_resp = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub rsv : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub stat_sn : u32 , pub exp_stat_sn : u32 , pub max_stat_sn : u32 , pub res3 : [ u8 ; 12usize ] , } impl iscsi_bhs { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn immediate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_immediate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , immediate : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let immediate : u8 = unsafe { :: std :: mem :: transmute ( immediate ) } ; immediate as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_async { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub ffffffff : u32 , pub res3 : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub async_event : u8 , pub async_vcode : u8 , pub param1 : u16 , pub param2 : u16 , pub param3 : u16 , pub res4 : [ u8 ; 4usize ] , } impl iscsi_bhs_async { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_login_req { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub version_max : u8 , pub version_min : u8 , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub isid : [ u8 ; 6usize ] , pub tsih : u16 , pub itt : u32 , pub cid : u16 , pub res2 : u16 , pub cmd_sn : u32 , pub exp_stat_sn : u32 , pub res3 : [ u8 ; 16usize ] , } impl iscsi_bhs_login_req { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn immediate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_immediate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , immediate : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let immediate : u8 = unsafe { :: std :: mem :: transmute ( immediate ) } ; immediate as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_login_rsp { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub version_max : u8 , pub version_act : u8 , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub isid : [ u8 ; 6usize ] , pub tsih : u16 , pub itt : u32 , pub res2 : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub status_class : u8 , pub status_detail : u8 , pub res3 : [ u8 ; 10usize ] , } impl iscsi_bhs_login_rsp { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_logout_req { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub res2 : [ u8 ; 8usize ] , pub itt : u32 , pub cid : u16 , pub res3 : u16 , pub cmd_sn : u32 , pub exp_stat_sn : u32 , pub res4 : [ u8 ; 16usize ] , } impl iscsi_bhs_logout_req { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn immediate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_immediate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reason ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reason ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 7u8 , val as u64 ) } } # [ inline ] pub fn reason_1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reason_1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , immediate : u8 , reserved : u8 , reason : u8 , reason_1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let immediate : u8 = unsafe { :: std :: mem :: transmute ( immediate ) } ; immediate as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 7u8 , { let reason : u8 = unsafe { :: std :: mem :: transmute ( reason ) } ; reason as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let reason_1 : u8 = unsafe { :: std :: mem :: transmute ( reason_1 ) } ; reason_1 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_logout_resp { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub response : u8 , pub res : u8 , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub res2 : [ u8 ; 8usize ] , pub itt : u32 , pub res3 : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub res4 : u32 , pub time_2_wait : u16 , pub time_2_retain : u16 , pub res5 : u32 , } impl iscsi_bhs_logout_resp { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_nop_in { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub res3 : [ u8 ; 12usize ] , } impl iscsi_bhs_nop_in { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_nop_out { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub cmd_sn : u32 , pub exp_stat_sn : u32 , pub res4 : [ u8 ; 16usize ] , } impl iscsi_bhs_nop_out { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn immediate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_immediate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , immediate : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let immediate : u8 = unsafe { :: std :: mem :: transmute ( immediate ) } ; immediate as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_r2t { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub rsv : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub r2t_sn : u32 , pub buffer_offset : u32 , pub desired_xfer_len : u32 , } impl iscsi_bhs_r2t { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_reject { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub reason : u8 , pub res : u8 , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub res2 : [ u8 ; 8usize ] , pub ffffffff : u32 , pub res3 : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub data_sn : u32 , pub res4 : [ u8 ; 8usize ] , } impl iscsi_bhs_reject { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_scsi_req { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub expected_data_xfer_len : u32 , pub cmd_sn : u32 , pub exp_stat_sn : u32 , pub cdb : [ u8 ; 16usize ] , } impl iscsi_bhs_scsi_req { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn immediate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_immediate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn attribute ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_attribute ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 2u8 , val as u64 ) } } # [ inline ] pub fn write_bit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_bit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn read_bit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_read_bit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn final_bit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_final_bit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , immediate : u8 , reserved : u8 , attribute : u8 , reserved2 : u8 , write_bit : u8 , read_bit : u8 , final_bit : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let immediate : u8 = unsafe { :: std :: mem :: transmute ( immediate ) } ; immediate as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let attribute : u8 = unsafe { :: std :: mem :: transmute ( attribute ) } ; attribute as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 2u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let write_bit : u8 = unsafe { :: std :: mem :: transmute ( write_bit ) } ; write_bit as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let read_bit : u8 = unsafe { :: std :: mem :: transmute ( read_bit ) } ; read_bit as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let final_bit : u8 = unsafe { :: std :: mem :: transmute ( final_bit ) } ; final_bit as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_scsi_resp { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub response : u8 , pub status : u8 , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub res4 : [ u8 ; 8usize ] , pub itt : u32 , pub snacktag : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub exp_data_sn : u32 , pub bi_read_res_cnt : u32 , pub res_cnt : u32 , } impl iscsi_bhs_scsi_resp { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_data_in { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : u8 , pub status : u8 , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub data_sn : u32 , pub buffer_offset : u32 , pub res_cnt : u32 , } impl iscsi_bhs_data_in { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_data_out { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub res3 : u32 , pub exp_stat_sn : u32 , pub res4 : u32 , pub data_sn : u32 , pub buffer_offset : u32 , pub res5 : u32 , } impl iscsi_bhs_data_out { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_snack_req { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub res5 : u32 , pub exp_stat_sn : u32 , pub res6 : [ u8 ; 8usize ] , pub beg_run : u32 , pub run_len : u32 , } impl iscsi_bhs_snack_req { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_task_req { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ref_task_tag : u32 , pub cmd_sn : u32 , pub exp_stat_sn : u32 , pub ref_cmd_sn : u32 , pub exp_data_sn : u32 , pub res5 : [ u8 ; 8usize ] , } impl iscsi_bhs_task_req { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn immediate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_immediate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , immediate : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let immediate : u8 = unsafe { :: std :: mem :: transmute ( immediate ) } ; immediate as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_task_resp { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub response : u8 , pub res : u8 , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub res2 : [ u8 ; 8usize ] , pub itt : u32 , pub res3 : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub res4 : [ u8 ; 12usize ] , } impl iscsi_bhs_task_resp { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_text_req { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub cmd_sn : u32 , pub exp_stat_sn : u32 , pub res3 : [ u8 ; 16usize ] , } impl iscsi_bhs_text_req { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn immediate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_immediate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , immediate : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let immediate : u8 = unsafe { :: std :: mem :: transmute ( immediate ) } ; immediate as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iscsi_bhs_text_resp { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub flags : u8 , pub res : [ u8 ; 2usize ] , pub total_ahs_len : u8 , pub data_segment_len : [ u8 ; 3usize ] , pub lun : u64 , pub itt : u32 , pub ttt : u32 , pub stat_sn : u32 , pub exp_cmd_sn : u32 , pub max_cmd_sn : u32 , pub res4 : [ u8 ; 12usize ] , } impl iscsi_bhs_text_resp { # [ inline ] pub fn opcode ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_opcode ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opcode : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let opcode : u8 = unsafe { :: std :: mem :: transmute ( opcode ) } ; opcode as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct iscsi_ahs { pub ahs_len : [ u8 ; 2usize ] , pub ahs_type : u8 , pub ahs_specific1 : u8 , pub ahs_specific2 : __IncompleteArrayField < u8 > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_jsonrpc_server { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_jsonrpc_request { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_jsonrpc_client { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_jsonrpc_client_request { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_jsonrpc_client_response { pub version : * mut spdk_json_val , pub id : * mut spdk_json_val , pub result : * mut spdk_json_val , pub error : * mut spdk_json_val , } impl Default for spdk_jsonrpc_client_response { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// User callback to handle a single JSON-RPC request.
///
/// The user should respond by calling one of spdk_jsonrpc_begin_result() or
/// spdk_jsonrpc_send_error_response().
///
/// \param request JSON-RPC request to handle.
/// \param method Function to handle the request.
/// \param param Parameters passed to the function 'method'. 
 pub type spdk_jsonrpc_handle_request_fn = :: std :: option :: Option < unsafe extern "C" fn ( request : * mut spdk_jsonrpc_request , method : * const spdk_json_val , params : * const spdk_json_val ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_jsonrpc_server_conn { _unused : [ u8 ; 0 ] , } pub type spdk_jsonrpc_conn_closed_fn = :: std :: option :: Option < unsafe extern "C" fn ( conn : * mut spdk_jsonrpc_server_conn , arg : * mut libc :: c_void ) > ; 
 /// Function for specific RPC method response parsing handlers.
///
/// \param parser_ctx context where analysis are put.
/// \param result json values responsed to this method.
///
/// \return 0 on success.
///         SPDK_JSON_PARSE_INVALID on failure. 
 pub type spdk_jsonrpc_client_response_parser = :: std :: option :: Option < unsafe extern "C" fn ( parser_ctx : * mut libc :: c_void , result : * const spdk_json_val ) -> libc :: c_int > ; extern "C" { 
 /// Create a JSON-RPC server listening on the required address.
///
/// \param domain Socket family.
/// \param protocol Protocol.
/// \param listen_addr Listening address.
/// \param addrlen Length of address.
/// \param handle_request User callback to handle a JSON-RPC request.
///
/// \return a pointer to the JSON-RPC server. 
 pub fn spdk_jsonrpc_server_listen ( domain : libc :: c_int , protocol : libc :: c_int , listen_addr : * mut sockaddr , addrlen : socklen_t , handle_request : spdk_jsonrpc_handle_request_fn ) -> * mut spdk_jsonrpc_server ; } extern "C" { 
 /// Poll the requests to the JSON-RPC server.
///
/// This function does accept, receive, handle the requests and reply to them.
///
/// \param server JSON-RPC server.
///
/// \return 0 on success. 
 pub fn spdk_jsonrpc_server_poll ( server : * mut spdk_jsonrpc_server ) -> libc :: c_int ; } extern "C" { 
 /// Shutdown the JSON-RPC server.
///
/// \param server JSON-RPC server. 
 pub fn spdk_jsonrpc_server_shutdown ( server : * mut spdk_jsonrpc_server ) ; } extern "C" { 
 /// Return connection associated to \c request
///
/// \param request JSON-RPC request
/// \return JSON RPC server connection 
 pub fn spdk_jsonrpc_get_conn ( request : * mut spdk_jsonrpc_request ) -> * mut spdk_jsonrpc_server_conn ; } extern "C" { 
 /// Add callback called when connection is closed. Pair of  \c cb and \c ctx must be unique or error is returned.
/// Registered callback is called only once and there is no need to call  \c spdk_jsonrpc_conn_del_close_cb
/// inside from \c cb.
///
/// \note Current implementation allow only one close callback per connection.
///
/// \param conn JSON RPC server connection
/// \param cb calback function
/// \param ctx argument for \c cb
///
/// \return 0 on success, or negated errno code:
///  -EEXIST \c cb and \c ctx is already registered
///  -ENOTCONN Callback can't be added because connection is closed.
///  -ENOSPC no more space to register callback. 
 pub fn spdk_jsonrpc_conn_add_close_cb ( conn : * mut spdk_jsonrpc_server_conn , cb : spdk_jsonrpc_conn_closed_fn , ctx : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Remove registered close callback.
///
/// \param conn JSON RPC server connection
/// \param cb calback function
/// \param ctx argument for \c cb
///
/// \return 0 on success, or negated errno code:
///  -ENOENT \c cb and \c ctx pair is not registered 
 pub fn spdk_jsonrpc_conn_del_close_cb ( conn : * mut spdk_jsonrpc_server_conn , cb : spdk_jsonrpc_conn_closed_fn , ctx : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Begin building a response to a JSON-RPC request.
///
/// If this function returns non-NULL, the user must call spdk_jsonrpc_end_result()
/// on the request after writing the desired response object to the spdk_json_write_ctx.
///
/// \param request JSON-RPC request to respond to.
///
/// \return JSON write context to write the response object to, or NULL if no
/// response is necessary. 
 pub fn spdk_jsonrpc_begin_result ( request : * mut spdk_jsonrpc_request ) -> * mut spdk_json_write_ctx ; } extern "C" { 
 /// Complete and send a JSON-RPC response.
///
/// \param request Request to complete the response for.
/// \param w JSON write context returned from spdk_jsonrpc_begin_result(). 
 pub fn spdk_jsonrpc_end_result ( request : * mut spdk_jsonrpc_request , w : * mut spdk_json_write_ctx ) ; } extern "C" { 
 /// Send an error response to a JSON-RPC request.
///
/// This is shorthand for spdk_jsonrpc_begin_result() + spdk_jsonrpc_end_result()
/// with an error object.
///
/// \param request JSON-RPC request to respond to.
/// \param error_code Integer error code to return (may be one of the
/// SPDK_JSONRPC_ERROR_ errors, or a custom error code).
/// \param msg String error message to return. 
 pub fn spdk_jsonrpc_send_error_response ( request : * mut spdk_jsonrpc_request , error_code : libc :: c_int , msg : * const libc :: c_char ) ; } extern "C" { 
 /// Send an error response to a JSON-RPC request.
///
/// This is shorthand for printf() + spdk_jsonrpc_send_error_response().
///
/// \param request JSON-RPC request to respond to.
/// \param error_code Integer error code to return (may be one of the
/// SPDK_JSONRPC_ERROR_ errors, or a custom error code).
/// \param fmt Printf-like format string. 
 pub fn spdk_jsonrpc_send_error_response_fmt ( request : * mut spdk_jsonrpc_request , error_code : libc :: c_int , fmt : * const libc :: c_char , ... ) ; } extern "C" { 
 /// Begin building a JSON-RPC request.
///
/// If this function returns non-NULL, the user must call spdk_jsonrpc_end_request()
/// on the request after writing the desired request object to the spdk_json_write_ctx.
///
/// \param request JSON-RPC request.
/// \param id ID index for the request. If < 0 skip ID.
/// \param method Name of the RPC method. If NULL caller will have to create "method" key.
///
/// \return JSON write context or NULL in case of error. 
 pub fn spdk_jsonrpc_begin_request ( request : * mut spdk_jsonrpc_client_request , id : i32 , method : * const libc :: c_char ) -> * mut spdk_json_write_ctx ; } extern "C" { 
 /// Complete a JSON-RPC request.
///
/// \param request JSON-RPC request.
/// \param w JSON write context returned from spdk_jsonrpc_begin_request(). 
 pub fn spdk_jsonrpc_end_request ( request : * mut spdk_jsonrpc_client_request , w : * mut spdk_json_write_ctx ) ; } extern "C" { 
 /// Connect to the specified RPC server.
///
/// \param addr RPC socket address.
/// \param addr_family Protocol families of address.
///
/// \return JSON-RPC client on success, NULL on failure and errno set to indicate
/// the cause of the error. 
 pub fn spdk_jsonrpc_client_connect ( addr : * const libc :: c_char , addr_family : libc :: c_int ) -> * mut spdk_jsonrpc_client ; } extern "C" { 
 /// Close JSON-RPC connection and free \c client object.
///
/// This function is not thread safe and should only be called from one thread at
/// a time while no other threads are actively \c client object.
///
/// \param client JSON-RPC client. 
 pub fn spdk_jsonrpc_client_close ( client : * mut spdk_jsonrpc_client ) ; } extern "C" { 
 /// Create one JSON-RPC request. Returned request must be passed to
/// \c spdk_jsonrpc_client_send_request when done or to \c spdk_jsonrpc_client_free_request
/// if discaded.
///
/// \return pointer to JSON-RPC request object. 
 pub fn spdk_jsonrpc_client_create_request ( ) -> * mut spdk_jsonrpc_client_request ; } extern "C" { 
 /// Free one JSON-RPC request.
///
/// \param req pointer to JSON-RPC request object. 
 pub fn spdk_jsonrpc_client_free_request ( req : * mut spdk_jsonrpc_client_request ) ; } extern "C" { 
 /// Send the JSON-RPC request in JSON-RPC client. Library takes ownership of the
/// request object and will free it when done.
///
/// This function is not thread safe and should only be called from one thread at
/// a time while no other threads are actively \c client object.
///
/// \param client JSON-RPC client.
/// \param req JSON-RPC request.
///
/// \return 0 on success or negative error code.
/// -ENOSPC - no space left to queue another request. Try again later. 
 pub fn spdk_jsonrpc_client_send_request ( client : * mut spdk_jsonrpc_client , req : * mut spdk_jsonrpc_client_request ) -> libc :: c_int ; } extern "C" { 
 /// Poll the JSON-RPC client. When any response is available use
/// \c spdk_jsonrpc_client_get_response to retrieve it.
///
/// This function is not thread safe and should only be called from one thread at
/// a time while no other threads are actively \c client object.
///
/// \param client JSON-RPC client.
/// \param timeout Time in miliseconds this function will block. -1 block forever, 0 don't block.
///
/// \return If no error occurred, this function returns a non-negative number indicating how
/// many ready responses can be retrieved. If an error occurred, this function returns one of
/// the following negated errno values:
///  -ENOTCONN - not connected yet. Try again later.
///  -EINVAL - response is detected to be invalid. Client connection should be terminated.
///  -ENOSPC - no space to receive another response. User need to retrieve waiting responses.
///  -EIO - connection terminated (or other critical error). Client connection should be terminated.
///  -ENOMEM - out of memory 
 pub fn spdk_jsonrpc_client_poll ( client : * mut spdk_jsonrpc_client , timeout : libc :: c_int ) -> libc :: c_int ; } extern "C" { 
 /// Return JSON RPC response object representing next available response from client connection.
/// Returned pointer must be freed using \c spdk_jsonrpc_client_free_response
///
/// This function is not thread safe and should only be called from one thread at
/// a time while no other threads are actively \c client object.
///
/// \param client
/// \return pointer to JSON RPC response object or NULL if no response available. 
 pub fn spdk_jsonrpc_client_get_response ( client : * mut spdk_jsonrpc_client ) -> * mut spdk_jsonrpc_client_response ; } extern "C" { 
 /// Free response object obtained from \c spdk_jsonrpc_client_get_response
///
/// \param resp pointer to JSON RPC response object. If NULL no operation is performed. 
 pub fn spdk_jsonrpc_client_free_response ( resp : * mut spdk_jsonrpc_client_response ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_lvol_store { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_lvol { _unused : [ u8 ; 0 ] , } pub const lvol_clear_method_LVOL_CLEAR_WITH_DEFAULT : lvol_clear_method = 0 ; pub const lvol_clear_method_LVOL_CLEAR_WITH_NONE : lvol_clear_method = 1 ; pub const lvol_clear_method_LVOL_CLEAR_WITH_UNMAP : lvol_clear_method = 2 ; pub const lvol_clear_method_LVOL_CLEAR_WITH_WRITE_ZEROES : lvol_clear_method = 3 ; pub type lvol_clear_method = u32 ; 
 /// Parameters for lvolstore initialization. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_lvs_opts { pub cluster_sz : u32 , pub name : [ libc :: c_char ; 64usize ] , } impl Default for spdk_lvs_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Initialize an spdk_lvs_opts structure to the defaults.
///
/// \param opts Pointer to the spdk_lvs_opts structure to initialize. 
 pub fn spdk_lvs_opts_init ( opts : * mut spdk_lvs_opts ) ; } 
 /// Callback definition for lvolstore operations, including handle to lvs.
///
/// \param cb_arg Custom arguments
/// \param lvol_store Handle to lvol_store or NULL when lvserrno is set
/// \param lvserrno Error 
 pub type spdk_lvs_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , lvol_store : * mut spdk_lvol_store , lvserrno : libc :: c_int ) > ; 
 /// Callback definition for lvolstore operations without handle.
///
/// \param cb_arg Custom arguments
/// \param lvserrno Error 
 pub type spdk_lvs_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , lvserrno : libc :: c_int ) > ; 
 /// Callback definition for lvol operations with handle to lvol.
///
/// \param cb_arg Custom arguments
/// \param lvol Handle to lvol or NULL when lvserrno is set
/// \param lvolerrno Error 
 pub type spdk_lvol_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , lvol : * mut spdk_lvol , lvolerrno : libc :: c_int ) > ; 
 /// Callback definition for lvol operations without handle to lvol.
///
/// \param cb_arg Custom arguments
/// \param lvolerrno Error 
 pub type spdk_lvol_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , lvolerrno : libc :: c_int ) > ; extern "C" { 
 /// Initialize lvolstore on given bs_bdev.
///
/// \param bs_dev This is created on the given bdev by using spdk_bdev_create_bs_dev()
/// beforehand.
/// \param o Options for lvolstore.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_lvs_init ( bs_dev : * mut spdk_bs_dev , o : * mut spdk_lvs_opts , cb_fn : spdk_lvs_op_with_handle_complete , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Rename the given lvolstore.
///
/// \param lvs Pointer to lvolstore.
/// \param new_name New name of lvs.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments. 
 pub fn spdk_lvs_rename ( lvs : * mut spdk_lvol_store , new_name : * const libc :: c_char , cb_fn : spdk_lvs_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Unload lvolstore.
///
/// All lvols have to be closed beforehand, when doing unload.
///
/// \param lvol_store Handle to lvolstore.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_lvs_unload ( lvol_store : * mut spdk_lvol_store , cb_fn : spdk_lvs_op_complete , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Destroy lvolstore.
///
/// All lvols have to be closed beforehand, when doing destroy.
///
/// \param lvol_store Handle to lvolstore.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_lvs_destroy ( lvol_store : * mut spdk_lvol_store , cb_fn : spdk_lvs_op_complete , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Create lvol on given lvolstore with specified size.
///
/// \param lvs Handle to lvolstore.
/// \param name Name of lvol.
/// \param sz size of lvol in bytes.
/// \param thin_provisioned Enables thin provisioning.
/// \param clear_method Changes default data clusters clear method
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments.
///
/// \return 0 on success, negative errno on failure. 
 pub fn spdk_lvol_create ( lvs : * mut spdk_lvol_store , name : * const libc :: c_char , sz : u64 , thin_provisioned : bool , clear_method : lvol_clear_method , cb_fn : spdk_lvol_op_with_handle_complete , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Create snapshot of given lvol.
///
/// \param lvol Handle to lvol.
/// \param snapshot_name Name of created snapshot.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments. 
 pub fn spdk_lvol_create_snapshot ( lvol : * mut spdk_lvol , snapshot_name : * const libc :: c_char , cb_fn : spdk_lvol_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Create clone of given snapshot.
///
/// \param lvol Handle to lvol snapshot.
/// \param clone_name Name of created clone.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments. 
 pub fn spdk_lvol_create_clone ( lvol : * mut spdk_lvol , clone_name : * const libc :: c_char , cb_fn : spdk_lvol_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Rename lvol with new_name.
///
/// \param lvol Handle to lvol.
/// \param new_name new name for lvol.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments. 
 pub fn spdk_lvol_rename ( lvol : * mut spdk_lvol , new_name : * const libc :: c_char , cb_fn : spdk_lvol_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// \brief Returns if it is possible to delete an lvol (i.e. lvol is not a snapshot that have at least one clone).
/// \param lvol Handle to lvol 
 pub fn spdk_lvol_deletable ( lvol : * mut spdk_lvol ) -> bool ; } extern "C" { 
 /// Close lvol and remove information about lvol from its lvolstore.
///
/// \param lvol Handle to lvol.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments. 
 pub fn spdk_lvol_destroy ( lvol : * mut spdk_lvol , cb_fn : spdk_lvol_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Close lvol, but information is kept on lvolstore.
///
/// \param lvol Handle to lvol.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments. 
 pub fn spdk_lvol_close ( lvol : * mut spdk_lvol , cb_fn : spdk_lvol_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Get I/O channel of bdev associated with specified lvol.
///
/// \param lvol Handle to lvol.
///
/// \return a pointer to the I/O channel. 
 pub fn spdk_lvol_get_io_channel ( lvol : * mut spdk_lvol ) -> * mut spdk_io_channel ; } extern "C" { 
 /// Load lvolstore from the given blobstore device.
///
/// \param bs_dev Pointer to the blobstore device.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments. 
 pub fn spdk_lvs_load ( bs_dev : * mut spdk_bs_dev , cb_fn : spdk_lvs_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Open a lvol.
///
/// \param lvol Handle to lvol.
/// \param cb_fn Completion callback.
/// \param cb_arg Completion callback custom arguments. 
 pub fn spdk_lvol_open ( lvol : * mut spdk_lvol , cb_fn : spdk_lvol_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Inflate lvol
///
/// \param lvol Handle to lvol
/// \param cb_fn Completion callback
/// \param cb_arg Completion callback custom arguments 
 pub fn spdk_lvol_inflate ( lvol : * mut spdk_lvol , cb_fn : spdk_lvol_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Decouple parent of lvol
///
/// \param lvol Handle to lvol
/// \param cb_fn Completion callback
/// \param cb_arg Completion callback custom arguments 
 pub fn spdk_lvol_decouple_parent ( lvol : * mut spdk_lvol , cb_fn : spdk_lvol_op_complete , cb_arg : * mut libc :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nbd_disk { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Initialize the network block device layer.
///
/// \return 0 on success. 
 pub fn spdk_nbd_init ( ) -> libc :: c_int ; } extern "C" { 
 /// Stop and close all the running network block devices. 
 pub fn spdk_nbd_fini ( ) ; } 
 /// Called when an NBD device has been started. 
 pub type spdk_nbd_start_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , nbd : * mut spdk_nbd_disk , rc : libc :: c_int ) > ; extern "C" { 
 /// Start a network block device backed by the bdev.
///
/// \param bdev_name Name of bdev exposed as a network block device.
/// \param nbd_path Path to the registered network block device.
/// \param cb_fn Called when the device has been started.
/// \param cb_arg Passed to cb_fn.
///
/// \return A negated error number is passed to cb_fn on failure. 
 pub fn spdk_nbd_start ( bdev_name : * const libc :: c_char , nbd_path : * const libc :: c_char , cb_fn : spdk_nbd_start_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Stop the running network block device safely.
///
/// \param nbd A pointer to the network block device to stop. 
 pub fn spdk_nbd_stop ( nbd : * mut spdk_nbd_disk ) ; } extern "C" { 
 /// Get the local filesystem path used for the network block device. 
 pub fn spdk_nbd_get_path ( nbd : * mut spdk_nbd_disk ) -> * const libc :: c_char ; } extern "C" { 
 /// Write NBD subsystem configuration into provided JSON context.
///
/// \param w JSON write context 
 pub fn spdk_nbd_write_config_json ( w : * mut spdk_json_write_ctx ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_sock { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_net_framework { pub name : * const libc :: c_char , pub init : :: std :: option :: Option < unsafe extern "C" fn ( ) > , pub fini : :: std :: option :: Option < unsafe extern "C" fn ( ) > , pub link : spdk_net_framework__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_net_framework__bindgen_ty_1 { pub stqe_next : * mut spdk_net_framework , } impl Default for spdk_net_framework__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_net_framework { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Register a net framework.
///
/// \param frame Net framework to register. 
 pub fn spdk_net_framework_register ( frame : * mut spdk_net_framework ) ; } extern "C" { 
 /// Initialize the network interfaces by getting information through netlink socket.
///
/// \return 0 on success, 1 on failure. 
 pub fn spdk_interface_init ( ) -> libc :: c_int ; } extern "C" { 
 /// Destroy the network interfaces. 
 pub fn spdk_interface_destroy ( ) ; } 
 /// Net framework initialization callback.
///
/// \param cb_arg Callback argument.
/// \param rc 0 if net framework initialized successfully or negative errno if it failed. 
 pub type spdk_net_init_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , rc : libc :: c_int ) > ; 
 /// Net framework finish callback.
///
/// \param cb_arg Callback argument. 
 pub type spdk_net_fini_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void ) > ; extern "C" { pub fn spdk_net_framework_init_next ( rc : libc :: c_int ) ; } extern "C" { 
 /// Start all registered frameworks.
///
/// \return 0 on success. 
 pub fn spdk_net_framework_start ( cb_fn : spdk_net_init_cb , cb_arg : * mut libc :: c_void ) ; } extern "C" { pub fn spdk_net_framework_fini_next ( ) ; } extern "C" { 
 /// Stop all registered frameworks. 
 pub fn spdk_net_framework_fini ( cb_fn : spdk_net_fini_cb , cb_arg : * mut libc :: c_void ) ; } pub const spdk_nvme_intel_feat_SPDK_NVME_INTEL_FEAT_MAX_LBA : spdk_nvme_intel_feat = 193 ; pub const spdk_nvme_intel_feat_SPDK_NVME_INTEL_FEAT_NATIVE_MAX_LBA : spdk_nvme_intel_feat = 194 ; pub const spdk_nvme_intel_feat_SPDK_NVME_INTEL_FEAT_POWER_GOVERNOR_SETTING : spdk_nvme_intel_feat = 198 ; pub const spdk_nvme_intel_feat_SPDK_NVME_INTEL_FEAT_SMBUS_ADDRESS : spdk_nvme_intel_feat = 200 ; pub const spdk_nvme_intel_feat_SPDK_NVME_INTEL_FEAT_LED_PATTERN : spdk_nvme_intel_feat = 201 ; pub const spdk_nvme_intel_feat_SPDK_NVME_INTEL_FEAT_RESET_TIMED_WORKLOAD_COUNTERS : spdk_nvme_intel_feat = 213 ; pub const spdk_nvme_intel_feat_SPDK_NVME_INTEL_FEAT_LATENCY_TRACKING : spdk_nvme_intel_feat = 226 ; pub type spdk_nvme_intel_feat = u32 ; pub const spdk_nvme_intel_set_max_lba_command_status_code_SPDK_NVME_INTEL_EXCEEDS_AVAILABLE_CAPACITY : spdk_nvme_intel_set_max_lba_command_status_code = 192 ; pub const spdk_nvme_intel_set_max_lba_command_status_code_SPDK_NVME_INTEL_SMALLER_THAN_MIN_LIMIT : spdk_nvme_intel_set_max_lba_command_status_code = 193 ; pub const spdk_nvme_intel_set_max_lba_command_status_code_SPDK_NVME_INTEL_SMALLER_THAN_NS_REQUIREMENTS : spdk_nvme_intel_set_max_lba_command_status_code = 194 ; pub type spdk_nvme_intel_set_max_lba_command_status_code = u32 ; pub const spdk_nvme_intel_log_page_SPDK_NVME_INTEL_LOG_PAGE_DIRECTORY : spdk_nvme_intel_log_page = 192 ; pub const spdk_nvme_intel_log_page_SPDK_NVME_INTEL_LOG_READ_CMD_LATENCY : spdk_nvme_intel_log_page = 193 ; pub const spdk_nvme_intel_log_page_SPDK_NVME_INTEL_LOG_WRITE_CMD_LATENCY : spdk_nvme_intel_log_page = 194 ; pub const spdk_nvme_intel_log_page_SPDK_NVME_INTEL_LOG_TEMPERATURE : spdk_nvme_intel_log_page = 197 ; pub const spdk_nvme_intel_log_page_SPDK_NVME_INTEL_LOG_SMART : spdk_nvme_intel_log_page = 202 ; pub const spdk_nvme_intel_log_page_SPDK_NVME_INTEL_MARKETING_DESCRIPTION : spdk_nvme_intel_log_page = 221 ; pub type spdk_nvme_intel_log_page = u32 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_PROGRAM_FAIL_COUNT : spdk_nvme_intel_smart_attribute_code = 171 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_ERASE_FAIL_COUNT : spdk_nvme_intel_smart_attribute_code = 172 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_WEAR_LEVELING_COUNT : spdk_nvme_intel_smart_attribute_code = 173 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_E2E_ERROR_COUNT : spdk_nvme_intel_smart_attribute_code = 184 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_CRC_ERROR_COUNT : spdk_nvme_intel_smart_attribute_code = 199 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_MEDIA_WEAR : spdk_nvme_intel_smart_attribute_code = 226 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_HOST_READ_PERCENTAGE : spdk_nvme_intel_smart_attribute_code = 227 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_TIMER : spdk_nvme_intel_smart_attribute_code = 228 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_THERMAL_THROTTLE_STATUS : spdk_nvme_intel_smart_attribute_code = 234 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_RETRY_BUFFER_OVERFLOW_COUNTER : spdk_nvme_intel_smart_attribute_code = 240 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_PLL_LOCK_LOSS_COUNT : spdk_nvme_intel_smart_attribute_code = 243 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_NAND_BYTES_WRITTEN : spdk_nvme_intel_smart_attribute_code = 244 ; pub const spdk_nvme_intel_smart_attribute_code_SPDK_NVME_INTEL_SMART_HOST_BYTES_WRITTEN : spdk_nvme_intel_smart_attribute_code = 245 ; pub type spdk_nvme_intel_smart_attribute_code = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_intel_log_page_directory { pub version : [ u8 ; 2usize ] , pub reserved : [ u8 ; 384usize ] , pub read_latency_log_len : u8 , pub reserved2 : u8 , pub write_latency_log_len : u8 , pub reserved3 : [ u8 ; 5usize ] , pub temperature_statistics_log_len : u8 , pub reserved4 : [ u8 ; 9usize ] , pub smart_log_len : u8 , pub reserved5 : [ u8 ; 37usize ] , pub marketing_description_log_len : u8 , pub reserved6 : [ u8 ; 69usize ] , } impl Default for spdk_nvme_intel_log_page_directory { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_rw_latency_page { pub major_revison : u16 , pub minor_revison : u16 , pub buckets_32us : [ u32 ; 32usize ] , pub buckets_1ms : [ u32 ; 31usize ] , pub buckets_32ms : [ u32 ; 31usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_temperature_page { pub current_temperature : u64 , pub shutdown_flag_last : u64 , pub shutdown_flag_life : u64 , pub highest_temperature : u64 , pub lowest_temperature : u64 , pub reserved : [ u64 ; 5usize ] , pub specified_max_op_temperature : u64 , pub reserved2 : u64 , pub specified_min_op_temperature : u64 , pub estimated_offset : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_smart_attribute { pub code : u8 , pub reserved : [ u8 ; 2usize ] , pub normalized_value : u8 , pub reserved2 : u8 , pub raw_value : [ u8 ; 6usize ] , pub reserved3 : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_smart_information_page { pub attributes : [ spdk_nvme_intel_smart_attribute ; 13usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_intel_feat_power_governor { pub raw : u32 , pub bits : spdk_nvme_intel_feat_power_governor__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_feat_power_governor__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_intel_feat_power_governor__bindgen_ty_1 { # [ inline ] pub fn power_governor_setting ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_power_governor_setting ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( power_governor_setting : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let power_governor_setting : u32 = unsafe { :: std :: mem :: transmute ( power_governor_setting ) } ; power_governor_setting as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_intel_feat_power_governor { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_intel_feat_smbus_address { pub raw : u32 , pub bits : spdk_nvme_intel_feat_smbus_address__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_feat_smbus_address__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_intel_feat_smbus_address__bindgen_ty_1 { # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn smbus_controller_address ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_smbus_controller_address ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 23u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 23u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( reserved : u32 , smbus_controller_address : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 8u8 , { let smbus_controller_address : u32 = unsafe { :: std :: mem :: transmute ( smbus_controller_address ) } ; smbus_controller_address as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 23u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_intel_feat_smbus_address { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_intel_feat_led_pattern { pub raw : u32 , pub bits : spdk_nvme_intel_feat_led_pattern__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_feat_led_pattern__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_intel_feat_led_pattern__bindgen_ty_1 { # [ inline ] pub fn feature_options ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_feature_options ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 24u8 , val as u64 ) } } # [ inline ] pub fn value ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_value ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( feature_options : u32 , value : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 24u8 , { let feature_options : u32 = unsafe { :: std :: mem :: transmute ( feature_options ) } ; feature_options as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let value : u32 = unsafe { :: std :: mem :: transmute ( value ) } ; value as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_intel_feat_led_pattern { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_intel_feat_reset_timed_workload_counters { pub raw : u32 , pub bits : spdk_nvme_intel_feat_reset_timed_workload_counters__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_feat_reset_timed_workload_counters__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_intel_feat_reset_timed_workload_counters__bindgen_ty_1 { # [ inline ] pub fn reset ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_reset ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( reset : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let reset : u32 = unsafe { :: std :: mem :: transmute ( reset ) } ; reset as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_intel_feat_reset_timed_workload_counters { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_intel_feat_latency_tracking { pub raw : u32 , pub bits : spdk_nvme_intel_feat_latency_tracking__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_intel_feat_latency_tracking__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } impl spdk_nvme_intel_feat_latency_tracking__bindgen_ty_1 { # [ inline ] pub fn enable ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 32u8 ) as u32 ) } } # [ inline ] pub fn set_enable ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 32u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( enable : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 32u8 , { let enable : u32 = unsafe { :: std :: mem :: transmute ( enable ) } ; enable as u64 } ) ; __bindgen_bitfield_unit } } impl Default for spdk_nvme_intel_feat_latency_tracking { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_intel_marketing_description_page { pub marketing_product : [ u8 ; 512usize ] , } impl Default for spdk_nvme_intel_marketing_description_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type FCNVME_BE64 = u64 ; pub type FCNVME_BE32 = u32 ; pub type FCNVME_BE16 = u16 ; pub const FCNVME_LS_RSVD : _bindgen_ty_36 = 0 ; pub const FCNVME_LS_RJT : _bindgen_ty_36 = 1 ; pub const FCNVME_LS_ACC : _bindgen_ty_36 = 2 ; pub const FCNVME_LS_CREATE_ASSOCIATION : _bindgen_ty_36 = 3 ; pub const FCNVME_LS_CREATE_CONNECTION : _bindgen_ty_36 = 4 ; pub const FCNVME_LS_DISCONNECT : _bindgen_ty_36 = 5 ; pub type _bindgen_ty_36 = u32 ; pub const FCNVME_LSDESC_RSVD : _bindgen_ty_37 = 0 ; pub const FCNVME_LSDESC_RQST : _bindgen_ty_37 = 1 ; pub const FCNVME_LSDESC_RJT : _bindgen_ty_37 = 2 ; pub const FCNVME_LSDESC_CREATE_ASSOC_CMD : _bindgen_ty_37 = 3 ; pub const FCNVME_LSDESC_CREATE_CONN_CMD : _bindgen_ty_37 = 4 ; pub const FCNVME_LSDESC_DISCONN_CMD : _bindgen_ty_37 = 5 ; pub const FCNVME_LSDESC_CONN_ID : _bindgen_ty_37 = 6 ; pub const FCNVME_LSDESC_ASSOC_ID : _bindgen_ty_37 = 7 ; pub type _bindgen_ty_37 = u32 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_NONE : fcnvme_ls_rjt_reason = 0 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_INVAL : fcnvme_ls_rjt_reason = 1 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_LOGIC : fcnvme_ls_rjt_reason = 3 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_UNAB : fcnvme_ls_rjt_reason = 9 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_UNSUP : fcnvme_ls_rjt_reason = 11 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_INPROG : fcnvme_ls_rjt_reason = 14 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_INV_ASSOC : fcnvme_ls_rjt_reason = 64 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_INV_CONN : fcnvme_ls_rjt_reason = 65 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_INV_PARAM : fcnvme_ls_rjt_reason = 66 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_INSUFF_RES : fcnvme_ls_rjt_reason = 67 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_INV_HOST : fcnvme_ls_rjt_reason = 68 ; pub const fcnvme_ls_rjt_reason_FCNVME_RJT_RC_VENDOR : fcnvme_ls_rjt_reason = 255 ; pub type fcnvme_ls_rjt_reason = u32 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_NONE : fcnvme_ls_rjt_explan = 0 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_OXID_RXID : fcnvme_ls_rjt_explan = 23 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_UNAB_DATA : fcnvme_ls_rjt_explan = 42 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_INV_LEN : fcnvme_ls_rjt_explan = 45 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_INV_ESRP : fcnvme_ls_rjt_explan = 64 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_INV_CTL_ID : fcnvme_ls_rjt_explan = 65 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_INV_Q_ID : fcnvme_ls_rjt_explan = 66 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_SQ_SIZE : fcnvme_ls_rjt_explan = 67 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_INV_HOST_ID : fcnvme_ls_rjt_explan = 68 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_INV_HOSTNQN : fcnvme_ls_rjt_explan = 69 ; pub const fcnvme_ls_rjt_explan_FCNVME_RJT_EXP_INV_SUBNQN : fcnvme_ls_rjt_explan = 70 ; pub type fcnvme_ls_rjt_explan = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fc_cmnd_iu { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , pub conn_id : u64 , pub cmnd_seq_num : u32 , pub data_len : u32 , pub cmd : spdk_nvme_cmd , pub rsvd1 : [ u32 ; 2usize ] , } impl Default for spdk_nvmf_fc_cmnd_iu { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvmf_fc_cmnd_iu { # [ inline ] pub fn scsi_id ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_scsi_id ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn fc_id ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_fc_id ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn cmnd_iu_len ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_cmnd_iu_len ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn rsvd0 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_rsvd0 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 24u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( scsi_id : u32 , fc_id : u32 , cmnd_iu_len : u32 , rsvd0 : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let scsi_id : u32 = unsafe { :: std :: mem :: transmute ( scsi_id ) } ; scsi_id as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let fc_id : u32 = unsafe { :: std :: mem :: transmute ( fc_id ) } ; fc_id as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let cmnd_iu_len : u32 = unsafe { :: std :: mem :: transmute ( cmnd_iu_len ) } ; cmnd_iu_len as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 24u8 , { let rsvd0 : u32 = unsafe { :: std :: mem :: transmute ( rsvd0 ) } ; rsvd0 as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 8u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ersp_iu { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub response_seq_no : u32 , pub transferred_data_len : u32 , pub rsvd1 : u32 , pub rsp : spdk_nvme_cpl , } impl spdk_nvmf_fc_ersp_iu { # [ inline ] pub fn status_code ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_status_code ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn rsvd0 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_rsvd0 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn ersp_len ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ersp_len ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( status_code : u32 , rsvd0 : u32 , ersp_len : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let status_code : u32 = unsafe { :: std :: mem :: transmute ( status_code ) } ; status_code as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let rsvd0 : u32 = unsafe { :: std :: mem :: transmute ( rsvd0 ) } ; rsvd0 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let ersp_len : u32 = unsafe { :: std :: mem :: transmute ( ersp_len ) } ; ersp_len as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_xfer_rdy_iu { pub relative_offset : u32 , pub burst_len : u32 , pub rsvd : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_frame_hdr { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 20usize ] , u32 > , pub parameter : FCNVME_BE32 , } impl spdk_nvmf_fc_frame_hdr { # [ inline ] pub fn r_ctl ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_r_ctl ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn d_id ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_d_id ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn cs_ctl ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_cs_ctl ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 8u8 , val as u64 ) } } # [ inline ] pub fn s_id ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 40usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_s_id ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 40usize , 24u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 64usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_type ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 64usize , 8u8 , val as u64 ) } } # [ inline ] pub fn f_ctl ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 72usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_f_ctl ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 72usize , 24u8 , val as u64 ) } } # [ inline ] pub fn seq_id ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 96usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_seq_id ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 96usize , 8u8 , val as u64 ) } } # [ inline ] pub fn df_ctl ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 104usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_df_ctl ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 104usize , 8u8 , val as u64 ) } } # [ inline ] pub fn seq_cnt ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 112usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_seq_cnt ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 112usize , 16u8 , val as u64 ) } } # [ inline ] pub fn ox_id ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 128usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ox_id ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 128usize , 16u8 , val as u64 ) } } # [ inline ] pub fn rx_id ( & self ) -> FCNVME_BE32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 144usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_rx_id ( & mut self , val : FCNVME_BE32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 144usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( r_ctl : FCNVME_BE32 , d_id : FCNVME_BE32 , cs_ctl : FCNVME_BE32 , s_id : FCNVME_BE32 , type_ : FCNVME_BE32 , f_ctl : FCNVME_BE32 , seq_id : FCNVME_BE32 , df_ctl : FCNVME_BE32 , seq_cnt : FCNVME_BE32 , ox_id : FCNVME_BE32 , rx_id : FCNVME_BE32 ) -> __BindgenBitfieldUnit < [ u8 ; 20usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 20usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let r_ctl : u32 = unsafe { :: std :: mem :: transmute ( r_ctl ) } ; r_ctl as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let d_id : u32 = unsafe { :: std :: mem :: transmute ( d_id ) } ; d_id as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 8u8 , { let cs_ctl : u32 = unsafe { :: std :: mem :: transmute ( cs_ctl ) } ; cs_ctl as u64 } ) ; __bindgen_bitfield_unit . set ( 40usize , 24u8 , { let s_id : u32 = unsafe { :: std :: mem :: transmute ( s_id ) } ; s_id as u64 } ) ; __bindgen_bitfield_unit . set ( 64usize , 8u8 , { let type_ : u32 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit . set ( 72usize , 24u8 , { let f_ctl : u32 = unsafe { :: std :: mem :: transmute ( f_ctl ) } ; f_ctl as u64 } ) ; __bindgen_bitfield_unit . set ( 96usize , 8u8 , { let seq_id : u32 = unsafe { :: std :: mem :: transmute ( seq_id ) } ; seq_id as u64 } ) ; __bindgen_bitfield_unit . set ( 104usize , 8u8 , { let df_ctl : u32 = unsafe { :: std :: mem :: transmute ( df_ctl ) } ; df_ctl as u64 } ) ; __bindgen_bitfield_unit . set ( 112usize , 16u8 , { let seq_cnt : u32 = unsafe { :: std :: mem :: transmute ( seq_cnt ) } ; seq_cnt as u64 } ) ; __bindgen_bitfield_unit . set ( 128usize , 16u8 , { let ox_id : u32 = unsafe { :: std :: mem :: transmute ( ox_id ) } ; ox_id as u64 } ) ; __bindgen_bitfield_unit . set ( 144usize , 16u8 , { let rx_id : u32 = unsafe { :: std :: mem :: transmute ( rx_id ) } ; rx_id as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_rqst_w0 { pub ls_cmd : u8 , pub zeros : [ u8 ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_lsdesc_rqst { pub desc_tag : FCNVME_BE32 , pub desc_len : FCNVME_BE32 , pub w0 : spdk_nvmf_fc_ls_rqst_w0 , pub rsvd12 : FCNVME_BE32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_acc_hdr { pub w0 : spdk_nvmf_fc_ls_rqst_w0 , pub desc_list_len : FCNVME_BE32 , pub rqst : spdk_nvmf_fc_lsdesc_rqst , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_lsdesc_conn_id { pub desc_tag : FCNVME_BE32 , pub desc_len : FCNVME_BE32 , pub connection_id : FCNVME_BE64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_lsdesc_assoc_id { pub desc_tag : FCNVME_BE32 , pub desc_len : FCNVME_BE32 , pub association_id : FCNVME_BE64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fc_lsdesc_cr_assoc_cmd { pub desc_tag : FCNVME_BE32 , pub desc_len : FCNVME_BE32 , pub ersp_ratio : FCNVME_BE16 , pub rsvd10 : FCNVME_BE16 , pub rsvd12 : [ FCNVME_BE32 ; 9usize ] , pub cntlid : FCNVME_BE16 , pub sqsize : FCNVME_BE16 , pub rsvd52 : FCNVME_BE32 , pub hostid : [ u8 ; 16usize ] , pub hostnqn : [ u8 ; 256usize ] , pub subnqn : [ u8 ; 256usize ] , pub rsvd584 : [ u8 ; 432usize ] , } impl Default for spdk_nvmf_fc_lsdesc_cr_assoc_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_cr_assoc_rqst { pub w0 : spdk_nvmf_fc_ls_rqst_w0 , pub desc_list_len : FCNVME_BE32 , pub assoc_cmd : spdk_nvmf_fc_lsdesc_cr_assoc_cmd , } impl Default for spdk_nvmf_fc_ls_cr_assoc_rqst { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_cr_assoc_acc { pub hdr : spdk_nvmf_fc_ls_acc_hdr , pub assoc_id : spdk_nvmf_fc_lsdesc_assoc_id , pub conn_id : spdk_nvmf_fc_lsdesc_conn_id , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_lsdesc_cr_conn_cmd { pub desc_tag : FCNVME_BE32 , pub desc_len : FCNVME_BE32 , pub ersp_ratio : FCNVME_BE16 , pub rsvd10 : FCNVME_BE16 , pub rsvd12 : [ FCNVME_BE32 ; 9usize ] , pub qid : FCNVME_BE16 , pub sqsize : FCNVME_BE16 , pub rsvd52 : FCNVME_BE32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_cr_conn_rqst { pub w0 : spdk_nvmf_fc_ls_rqst_w0 , pub desc_list_len : FCNVME_BE32 , pub assoc_id : spdk_nvmf_fc_lsdesc_assoc_id , pub connect_cmd : spdk_nvmf_fc_lsdesc_cr_conn_cmd , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_cr_conn_acc { pub hdr : spdk_nvmf_fc_ls_acc_hdr , pub conn_id : spdk_nvmf_fc_lsdesc_conn_id , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_lsdesc_disconn_cmd { pub desc_tag : FCNVME_BE32 , pub desc_len : FCNVME_BE32 , pub rsvd8 : FCNVME_BE32 , pub rsvd12 : FCNVME_BE32 , pub rsvd16 : FCNVME_BE32 , pub rsvd20 : FCNVME_BE32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_disconnect_rqst { pub w0 : spdk_nvmf_fc_ls_rqst_w0 , pub desc_list_len : FCNVME_BE32 , pub assoc_id : spdk_nvmf_fc_lsdesc_assoc_id , pub disconn_cmd : spdk_nvmf_fc_lsdesc_disconn_cmd , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_disconnect_acc { pub hdr : spdk_nvmf_fc_ls_acc_hdr , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_lsdesc_rjt { pub desc_tag : FCNVME_BE32 , pub desc_len : FCNVME_BE32 , pub rsvd8 : u8 , pub reason_code : u8 , pub reason_explanation : u8 , pub vendor : u8 , pub rsvd12 : FCNVME_BE32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fc_ls_rjt { pub w0 : spdk_nvmf_fc_ls_rqst_w0 , pub desc_list_len : FCNVME_BE32 , pub rqst : spdk_nvmf_fc_lsdesc_rqst , pub rjt : spdk_nvmf_fc_lsdesc_rjt , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_tgt { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_subsystem { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_ctrlr { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_qpair { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_request { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_host { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_listener { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_poll_group { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_transport { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_transport_opts { pub max_queue_depth : u16 , pub max_qpairs_per_ctrlr : u16 , pub in_capsule_data_size : u32 , pub max_io_size : u32 , pub io_unit_size : u32 , pub max_aq_depth : u32 , pub num_shared_buffers : u32 , pub buf_cache_size : u32 , } extern "C" { 
 /// Construct an NVMe-oF target.
///
/// \param max_subsystems the maximum number of subsystems allowed by the target.
///
/// \return a pointer to a NVMe-oF target on success, or NULL on failure. 
 pub fn spdk_nvmf_tgt_create ( max_subsystems : u32 ) -> * mut spdk_nvmf_tgt ; } pub type spdk_nvmf_tgt_destroy_done_fn = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , status : libc :: c_int ) > ; extern "C" { 
 /// Destroy an NVMe-oF target.
///
/// \param tgt The target to destroy. This releases all resources.
/// \param cb_fn A callback that will be called once the target is destroyed
/// \param cb_arg A context argument passed to cb_fn. 
 pub fn spdk_nvmf_tgt_destroy ( tgt : * mut spdk_nvmf_tgt , cb_fn : spdk_nvmf_tgt_destroy_done_fn , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Write NVMe-oF target configuration into provided JSON context.
/// \param w JSON write context
/// \param tgt The NVMe-oF target 
 pub fn spdk_nvmf_tgt_write_config_json ( w : * mut spdk_json_write_ctx , tgt : * mut spdk_nvmf_tgt ) ; } 
 /// Function to be called once the target is listening.
///
/// \param ctx Context argument passed to this function.
/// \param status 0 if it completed successfully, or negative errno if it failed. 
 pub type spdk_nvmf_tgt_listen_done_fn = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , status : libc :: c_int ) > ; extern "C" { 
 /// Begin accepting new connections at the address provided.
///
/// The connections will be matched with a subsystem, which may or may not allow
/// the connection based on a subsystem-specific whitelist. See
/// spdk_nvmf_subsystem_add_host() and spdk_nvmf_subsystem_add_listener()
///
/// \param tgt The target associated with this listen address.
/// \param trid The address to listen at.
/// \param cb_fn A callback that will be called once the target is listening
/// \param cb_arg A context argument passed to cb_fn.
///
/// \return void. The callback status argument will be 0 on success
///	   or a negated errno on failure. 
 pub fn spdk_nvmf_tgt_listen ( tgt : * mut spdk_nvmf_tgt , trid : * mut spdk_nvme_transport_id , cb_fn : spdk_nvmf_tgt_listen_done_fn , cb_arg : * mut libc :: c_void ) ; } 
 /// Function to be called for each newly discovered qpair.
///
/// \param qpair The newly discovered qpair. 
 pub type new_qpair_fn = :: std :: option :: Option < unsafe extern "C" fn ( qpair : * mut spdk_nvmf_qpair ) > ; extern "C" { 
 /// Poll the target for incoming connections.
///
/// The new_qpair_fn cb_fn will be called for each newly discovered
/// qpair. The user is expected to add that qpair to a poll group
/// to establish the connection.
///
/// \param tgt The target associated with the listen address.
/// \param cb_fn Called for each newly discovered qpair. 
 pub fn spdk_nvmf_tgt_accept ( tgt : * mut spdk_nvmf_tgt , cb_fn : new_qpair_fn ) ; } extern "C" { 
 /// Create a poll group.
///
/// \param tgt The target to create a poll group.
///
/// \return a poll group on success, or NULL on failure. 
 pub fn spdk_nvmf_poll_group_create ( tgt : * mut spdk_nvmf_tgt ) -> * mut spdk_nvmf_poll_group ; } extern "C" { 
 /// Destroy a poll group.
///
/// \param group The poll group to destroy. 
 pub fn spdk_nvmf_poll_group_destroy ( group : * mut spdk_nvmf_poll_group ) ; } extern "C" { 
 /// Add the given qpair to the poll group.
///
/// \param group The group to add qpair to.
/// \param qpair The qpair to add.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_nvmf_poll_group_add ( group : * mut spdk_nvmf_poll_group , qpair : * mut spdk_nvmf_qpair ) -> libc :: c_int ; } pub type nvmf_qpair_disconnect_cb = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void ) > ; extern "C" { 
 /// Disconnect an NVMe-oF qpair
///
/// \param qpair The NVMe-oF qpair to disconnect.
/// \param cb_fn The function to call upon completion of the disconnect.
/// \param ctx The context to pass to the callback function.
///
/// \return 0 upon success.
/// \return -ENOMEM if the function specific context could not be allocated. 
 pub fn spdk_nvmf_qpair_disconnect ( qpair : * mut spdk_nvmf_qpair , cb_fn : nvmf_qpair_disconnect_cb , ctx : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Get the peer's transport ID for this queue pair.
///
/// \param qpair The NVMe-oF qpair
/// \param trid Output parameter that will contain the transport id.
///
/// \return 0 for success.
/// \return -EINVAL if the qpair is not connected. 
 pub fn spdk_nvmf_qpair_get_peer_trid ( qpair : * mut spdk_nvmf_qpair , trid : * mut spdk_nvme_transport_id ) -> libc :: c_int ; } extern "C" { 
 /// Get the local transport ID for this queue pair.
///
/// \param qpair The NVMe-oF qpair
/// \param trid Output parameter that will contain the transport id.
///
/// \return 0 for success.
/// \return -EINVAL if the qpair is not connected. 
 pub fn spdk_nvmf_qpair_get_local_trid ( qpair : * mut spdk_nvmf_qpair , trid : * mut spdk_nvme_transport_id ) -> libc :: c_int ; } extern "C" { 
 /// Get the associated listener transport ID for this queue pair.
///
/// \param qpair The NVMe-oF qpair
/// \param trid Output parameter that will contain the transport id.
///
/// \return 0 for success.
/// \return -EINVAL if the qpair is not connected. 
 pub fn spdk_nvmf_qpair_get_listen_trid ( qpair : * mut spdk_nvmf_qpair , trid : * mut spdk_nvme_transport_id ) -> libc :: c_int ; } extern "C" { 
 /// Create an NVMe-oF subsystem.
///
/// Subsystems are in one of three states: Inactive, Active, Paused. This
/// state affects which operations may be performed on the subsystem. Upon
/// creation, the subsystem will be in the Inactive state and may be activated
/// by calling spdk_nvmf_subsystem_start(). No I/O will be processed in the Inactive
/// or Paused states, but changes to the state of the subsystem may be made.
///
/// \param tgt The NVMe-oF target that will own this subsystem.
/// \param nqn The NVMe qualified name of this subsystem.
/// \param type Whether this subsystem is an I/O subsystem or a Discovery subsystem.
/// \param num_ns The number of namespaces this subsystem contains.
///
/// \return a pointer to a NVMe-oF subsystem on success, or NULL on failure. 
 pub fn spdk_nvmf_subsystem_create ( tgt : * mut spdk_nvmf_tgt , nqn : * const libc :: c_char , type_ : spdk_nvmf_subtype , num_ns : u32 ) -> * mut spdk_nvmf_subsystem ; } extern "C" { 
 /// Destroy an NVMe-oF subsystem. A subsystem may only be destroyed when in
/// the Inactive state. See spdk_nvmf_subsystem_stop().
///
/// \param subsystem The NVMe-oF subsystem to destroy. 
 pub fn spdk_nvmf_subsystem_destroy ( subsystem : * mut spdk_nvmf_subsystem ) ; } 
 /// Function to be called once the subsystem has changed state.
///
/// \param subsytem NVMe-oF subsystem that has changed state.
/// \param cb_arg Argument passed to callback function.
/// \param status 0 if it completed successfully, or negative errno if it failed. 
 pub type spdk_nvmf_subsystem_state_change_done = :: std :: option :: Option < unsafe extern "C" fn ( subsystem : * mut spdk_nvmf_subsystem , cb_arg : * mut libc :: c_void , status : libc :: c_int ) > ; extern "C" { 
 /// Transition an NVMe-oF subsystem from Inactive to Active state.
///
/// \param subsystem The NVMe-oF subsystem.
/// \param cb_fn A function that will be called once the subsystem has changed state.
/// \param cb_arg Argument passed to cb_fn.
///
/// \return 0 on success, or negated errno on failure. The callback provided will only
/// be called on success. 
 pub fn spdk_nvmf_subsystem_start ( subsystem : * mut spdk_nvmf_subsystem , cb_fn : spdk_nvmf_subsystem_state_change_done , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Transition an NVMe-oF subsystem from Active to Inactive state.
///
/// \param subsystem The NVMe-oF subsystem.
/// \param cb_fn A function that will be called once the subsystem has changed state.
/// \param cb_arg Argument passed to cb_fn.
///
/// \return 0 on success, or negated errno on failure. The callback provided will only
/// be called on success. 
 pub fn spdk_nvmf_subsystem_stop ( subsystem : * mut spdk_nvmf_subsystem , cb_fn : spdk_nvmf_subsystem_state_change_done , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Transition an NVMe-oF subsystem from Active to Paused state.
///
/// \param subsystem The NVMe-oF subsystem.
/// \param cb_fn A function that will be called once the subsystem has changed state.
/// \param cb_arg Argument passed to cb_fn.
///
/// \return 0 on success, or negated errno on failure. The callback provided will only
/// be called on success. 
 pub fn spdk_nvmf_subsystem_pause ( subsystem : * mut spdk_nvmf_subsystem , cb_fn : spdk_nvmf_subsystem_state_change_done , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Transition an NVMe-oF subsystem from Paused to Active state.
///
/// \param subsystem The NVMe-oF subsystem.
/// \param cb_fn A function that will be called once the subsystem has changed state.
/// \param cb_arg Argument passed to cb_fn.
///
/// \return 0 on success, or negated errno on failure. The callback provided will only
/// be called on success. 
 pub fn spdk_nvmf_subsystem_resume ( subsystem : * mut spdk_nvmf_subsystem , cb_fn : spdk_nvmf_subsystem_state_change_done , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Search the target for a subsystem with the given NQN.
///
/// \param tgt The NVMe-oF target to search from.
/// \param subnqn NQN of the subsystem.
///
/// \return a pointer to the NVMe-oF subsystem on success, or NULL on failure. 
 pub fn spdk_nvmf_tgt_find_subsystem ( tgt : * mut spdk_nvmf_tgt , subnqn : * const libc :: c_char ) -> * mut spdk_nvmf_subsystem ; } extern "C" { 
 /// Begin iterating over all known subsystems. If no subsystems are present, return NULL.
///
/// \param tgt The NVMe-oF target to iterate.
///
/// \return a pointer to the first NVMe-oF subsystem on success, or NULL on failure. 
 pub fn spdk_nvmf_subsystem_get_first ( tgt : * mut spdk_nvmf_tgt ) -> * mut spdk_nvmf_subsystem ; } extern "C" { 
 /// Continue iterating over all known subsystems. If no additional subsystems, return NULL.
///
/// \param subsystem Previous subsystem returned from \ref spdk_nvmf_subsystem_get_first or
///                  \ref spdk_nvmf_subsystem_get_next.
///
/// \return a pointer to the next NVMe-oF subsystem on success, or NULL on failure. 
 pub fn spdk_nvmf_subsystem_get_next ( subsystem : * mut spdk_nvmf_subsystem ) -> * mut spdk_nvmf_subsystem ; } extern "C" { 
 /// Allow the given host NQN to connect to the given subsystem.
///
/// May only be performed on subsystems in the PAUSED or INACTIVE states.
///
/// \param subsystem Subsystem to add host to.
/// \param hostnqn The NQN for the host.
///
/// \return 0 on success, or negated errno value on failure. 
 pub fn spdk_nvmf_subsystem_add_host ( subsystem : * mut spdk_nvmf_subsystem , hostnqn : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Remove the given host NQN from the allowed hosts whitelist.
///
/// May only be performed on subsystems in the PAUSED or INACTIVE states.
///
/// \param subsystem Subsystem to remove host from.
/// \param hostnqn The NQN for the host.
///
/// \return 0 on success, or negated errno value on failure. 
 pub fn spdk_nvmf_subsystem_remove_host ( subsystem : * mut spdk_nvmf_subsystem , hostnqn : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Set whether a subsystem should allow any host or only hosts in the allowed list.
///
/// May only be performed on subsystems in the PAUSED or INACTIVE states.
///
/// \param subsystem Subsystem to modify.
/// \param allow_any_host true to allow any host to connect to this subsystem,
/// or false to enforce the whitelist configured with spdk_nvmf_subsystem_add_host().
///
/// \return 0 on success, or negated errno value on failure. 
 pub fn spdk_nvmf_subsystem_set_allow_any_host ( subsystem : * mut spdk_nvmf_subsystem , allow_any_host : bool ) -> libc :: c_int ; } extern "C" { 
 /// Check whether a subsystem should allow any host or only hosts in the allowed list.
///
/// \param subsystem Subsystem to modify.
///
/// \return true if any host is allowed to connect to this subsystem, or false if
/// connecting hosts must be in the whitelist configured with spdk_nvmf_subsystem_add_host(). 
 pub fn spdk_nvmf_subsystem_get_allow_any_host ( subsystem : * const spdk_nvmf_subsystem ) -> bool ; } extern "C" { 
 /// Check if the given host is allowed to connect to the subsystem.
///
/// \param subsystem The subsystem to query.
/// \param hostnqn The NQN of the host.
///
/// \return true if allowed, false if not. 
 pub fn spdk_nvmf_subsystem_host_allowed ( subsystem : * mut spdk_nvmf_subsystem , hostnqn : * const libc :: c_char ) -> bool ; } extern "C" { 
 /// Get the first allowed host in a subsystem.
///
/// \param subsystem Subsystem to query.
///
/// \return first allowed host in this subsystem, or NULL if none allowed. 
 pub fn spdk_nvmf_subsystem_get_first_host ( subsystem : * mut spdk_nvmf_subsystem ) -> * mut spdk_nvmf_host ; } extern "C" { 
 /// Get the next allowed host in a subsystem.
///
/// \param subsystem Subsystem to query.
/// \param prev_host Previous host returned from this function.
///
/// \return next allowed host in this subsystem, or NULL if prev_host was the last host. 
 pub fn spdk_nvmf_subsystem_get_next_host ( subsystem : * mut spdk_nvmf_subsystem , prev_host : * mut spdk_nvmf_host ) -> * mut spdk_nvmf_host ; } extern "C" { 
 /// Get a host's NQN.
///
/// \param host Host to query.
///
/// \return NQN of host. 
 pub fn spdk_nvmf_host_get_nqn ( host : * mut spdk_nvmf_host ) -> * const libc :: c_char ; } extern "C" { 
 /// Accept new connections on the address provided.
///
/// May only be performed on subsystems in the PAUSED or INACTIVE states.
///
/// \param subsystem Subsystem to add listener to.
/// \param trid The address to accept connections from.
///
/// \return 0 on success, or negated errno value on failure. 
 pub fn spdk_nvmf_subsystem_add_listener ( subsystem : * mut spdk_nvmf_subsystem , trid : * mut spdk_nvme_transport_id ) -> libc :: c_int ; } extern "C" { 
 /// Stop accepting new connections on the address provided
///
/// May only be performed on subsystems in the PAUSED or INACTIVE states.
///
/// \param subsystem Subsystem to remove listener from.
/// \param trid The address to no longer accept connections from.
///
/// \return 0 on success, or negated errno value on failure. 
 pub fn spdk_nvmf_subsystem_remove_listener ( subsystem : * mut spdk_nvmf_subsystem , trid : * const spdk_nvme_transport_id ) -> libc :: c_int ; } extern "C" { 
 /// Check if connections originated from the given address are allowed to connect
/// to the subsystem.
///
/// \param subsystem The subsystem to query.
/// \param trid The listen address.
///
/// \return true if allowed, or false if not. 
 pub fn spdk_nvmf_subsystem_listener_allowed ( subsystem : * mut spdk_nvmf_subsystem , trid : * mut spdk_nvme_transport_id ) -> bool ; } extern "C" { 
 /// Get the first allowed listen address in the subsystem.
///
/// \param subsystem Subsystem to query.
///
/// \return first allowed listen address in this subsystem, or NULL if none allowed. 
 pub fn spdk_nvmf_subsystem_get_first_listener ( subsystem : * mut spdk_nvmf_subsystem ) -> * mut spdk_nvmf_listener ; } extern "C" { 
 /// Get the next allowed listen address in a subsystem.
///
/// \param subsystem Subsystem to query.
/// \param prev_listener Previous listen address for this subsystem.
///
/// \return next allowed listen address in this subsystem, or NULL if prev_listener
/// was the last address. 
 pub fn spdk_nvmf_subsystem_get_next_listener ( subsystem : * mut spdk_nvmf_subsystem , prev_listener : * mut spdk_nvmf_listener ) -> * mut spdk_nvmf_listener ; } extern "C" { 
 /// Get a listen address' transport ID
///
/// \param listener This listener.
///
/// \return the transport ID for this listener. 
 pub fn spdk_nvmf_listener_get_trid ( listener : * mut spdk_nvmf_listener ) -> * const spdk_nvme_transport_id ; } 
 /// NVMe-oF target namespace creation options 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_ns_opts { 
 /// Namespace ID
    ///
    /// Set to 0 to automatically assign a free NSID. 
 pub nsid : u32 , 
 /// Namespace Globally Unique Identifier
    ///
    /// Fill with 0s if not specified. 
 pub nguid : [ u8 ; 16usize ] , 
 /// IEEE Extended Unique Identifier
    ///
    /// Fill with 0s if not specified. 
 pub eui64 : [ u8 ; 8usize ] , 
 /// Namespace UUID
    ///
    /// Fill with 0s if not specified. 
 pub uuid : spdk_uuid , } impl Default for spdk_nvmf_ns_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Get default namespace creation options.
///
/// \param opts Namespace options to fill with defaults.
/// \param opts_size sizeof(struct spdk_nvmf_ns_opts) 
 pub fn spdk_nvmf_ns_opts_get_defaults ( opts : * mut spdk_nvmf_ns_opts , opts_size : usize ) ; } extern "C" { 
 /// Add a namespace to a subsytem.
///
/// May only be performed on subsystems in the PAUSED or INACTIVE states.
///
/// \param subsystem Subsystem to add namespace to.
/// \param bdev Block device to add as a namespace.
/// \param opts Namespace options, or NULL to use defaults.
/// \param opts_size sizeof(*opts)
///
/// \return newly added NSID on success, or 0 on failure. 
 pub fn spdk_nvmf_subsystem_add_ns ( subsystem : * mut spdk_nvmf_subsystem , bdev : * mut spdk_bdev , opts : * const spdk_nvmf_ns_opts , opts_size : usize ) -> u32 ; } extern "C" { 
 /// Remove a namespace from a subsytem.
///
/// May only be performed on subsystems in the PAUSED or INACTIVE states.
///
/// \param subsystem Subsystem the namespace belong to.
/// \param nsid Namespace ID to be removed.
/// \param cb_fn Function to call when all thread local ns information has been updated
/// \param cb_arg Context for the above cb_fn
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_nvmf_subsystem_remove_ns ( subsystem : * mut spdk_nvmf_subsystem , nsid : u32 , cb_fn : spdk_nvmf_subsystem_state_change_done , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvmf_ns { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Get the first allocated namespace in a subsystem.
///
/// \param subsystem Subsystem to query.
///
/// \return first allocated namespace in this subsystem, or NULL if this subsystem
/// has no namespaces. 
 pub fn spdk_nvmf_subsystem_get_first_ns ( subsystem : * mut spdk_nvmf_subsystem ) -> * mut spdk_nvmf_ns ; } extern "C" { 
 /// Get the next allocated namespace in a subsystem.
///
/// \param subsystem Subsystem to query.
/// \param prev_ns Previous ns returned from this function.
///
/// \return next allocated namespace in this subsystem, or NULL if prev_ns was the
/// last namespace. 
 pub fn spdk_nvmf_subsystem_get_next_ns ( subsystem : * mut spdk_nvmf_subsystem , prev_ns : * mut spdk_nvmf_ns ) -> * mut spdk_nvmf_ns ; } extern "C" { 
 /// Get a namespace in a subsystem by NSID.
///
/// \param subsystem Subsystem to search.
/// \param nsid Namespace ID to find.
///
/// \return namespace matching nsid, or NULL if nsid was not found. 
 pub fn spdk_nvmf_subsystem_get_ns ( subsystem : * mut spdk_nvmf_subsystem , nsid : u32 ) -> * mut spdk_nvmf_ns ; } extern "C" { 
 /// Get the maximum number of namespaces allowed in a subsystem.
///
/// \param subsystem Subsystem to query.
///
/// \return Maximum number of namespaces allowed in the subsystem, or 0 for unlimited. 
 pub fn spdk_nvmf_subsystem_get_max_namespaces ( subsystem : * const spdk_nvmf_subsystem ) -> u32 ; } extern "C" { 
 /// Get a namespace's NSID.
///
/// \param ns Namespace to query.
///
/// \return NSID of ns. 
 pub fn spdk_nvmf_ns_get_id ( ns : * const spdk_nvmf_ns ) -> u32 ; } extern "C" { 
 /// Get a namespace's associated bdev.
///
/// \param ns Namespace to query.
///
/// \return backing bdev of ns. 
 pub fn spdk_nvmf_ns_get_bdev ( ns : * mut spdk_nvmf_ns ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the options specified for a namespace.
///
/// \param ns Namespace to query.
/// \param opts Output parameter for options.
/// \param opts_size sizeof(*opts) 
 pub fn spdk_nvmf_ns_get_opts ( ns : * const spdk_nvmf_ns , opts : * mut spdk_nvmf_ns_opts , opts_size : usize ) ; } extern "C" { 
 /// Get the serial number of the specified subsystem.
///
/// \param subsystem Subsystem to query.
///
/// \return serial number of the specified subsystem. 
 pub fn spdk_nvmf_subsystem_get_sn ( subsystem : * const spdk_nvmf_subsystem ) -> * const libc :: c_char ; } extern "C" { 
 /// Set the serial number for the specified subsystem.
///
/// \param subsystem Subsystem to set for.
/// \param sn serial number to set.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_nvmf_subsystem_set_sn ( subsystem : * mut spdk_nvmf_subsystem , sn : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Get the NQN of the specified subsystem.
///
/// \param subsystem Subsystem to query.
///
/// \return NQN of the specified subsystem. 
 pub fn spdk_nvmf_subsystem_get_nqn ( subsystem : * mut spdk_nvmf_subsystem ) -> * const libc :: c_char ; } extern "C" { 
 /// Get the type of the specified subsystem.
///
/// \param subsystem Subsystem to query.
///
/// \return the type of the specified subsystem. 
 pub fn spdk_nvmf_subsystem_get_type ( subsystem : * mut spdk_nvmf_subsystem ) -> spdk_nvmf_subtype ; } extern "C" { 
 /// Initialize transport options
///
/// \param type The transport type to create
/// \param opts The transport options (e.g. max_io_size)
///
/// \return bool. true if successful, false if transport type
///	   not found. 
 pub fn spdk_nvmf_transport_opts_init ( type_ : spdk_nvme_transport_type , opts : * mut spdk_nvmf_transport_opts ) -> bool ; } extern "C" { 
 /// Create a protocol transport
///
/// \param type The transport type to create
/// \param opts The transport options (e.g. max_io_size)
///
/// \return new transport or NULL if create fails 
 pub fn spdk_nvmf_transport_create ( type_ : spdk_nvme_transport_type , opts : * mut spdk_nvmf_transport_opts ) -> * mut spdk_nvmf_transport ; } extern "C" { 
 /// Destroy a protocol transport
///
/// \param transport The transport to destory
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_nvmf_transport_destroy ( transport : * mut spdk_nvmf_transport ) -> libc :: c_int ; } extern "C" { 
 /// Get an existing transport from the target
///
/// \param tgt The NVMe-oF target
/// \param type The transport type to get
///
/// \return the transport or NULL if not found 
 pub fn spdk_nvmf_tgt_get_transport ( tgt : * mut spdk_nvmf_tgt , type_ : spdk_nvme_transport_type ) -> * mut spdk_nvmf_transport ; } extern "C" { 
 /// Get the first transport registered with the given target
///
/// \param tgt The NVMe-oF target
///
/// \return The first transport registered on the target 
 pub fn spdk_nvmf_transport_get_first ( tgt : * mut spdk_nvmf_tgt ) -> * mut spdk_nvmf_transport ; } extern "C" { 
 /// Get the next transport in a target's list.
///
/// \param transport A handle to a transport object
///
/// \return The next transport associated with the NVMe-oF target 
 pub fn spdk_nvmf_transport_get_next ( transport : * mut spdk_nvmf_transport ) -> * mut spdk_nvmf_transport ; } extern "C" { 
 /// Get the opts for a given transport.
///
/// \param transport The transport to query
///
/// \return The opts associated with the given transport 
 pub fn spdk_nvmf_get_transport_opts ( transport : * mut spdk_nvmf_transport ) -> * const spdk_nvmf_transport_opts ; } extern "C" { 
 /// Get the transport type for a given transport.
///
/// \param transport The transport to query
///
/// \return the transport type for the given transport 
 pub fn spdk_nvmf_get_transport_type ( transport : * mut spdk_nvmf_transport ) -> spdk_nvme_transport_type_t ; } 
 /// Function to be called once transport add is complete
///
/// \param cb_arg Callback argument passed to this function.
/// \param status 0 if it completed successfully, or negative errno if it failed. 
 pub type spdk_nvmf_tgt_add_transport_done_fn = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , status : libc :: c_int ) > ; extern "C" { 
 /// Add a transport to a target
///
/// \param tgt The NVMe-oF target
/// \param transport The transport to add
/// \param cb_fn A callback that will be called once the transport is created
/// \param cb_arg A context argument passed to cb_fn.
///
/// \return void. The callback status argument will be 0 on success
///	   or a negated errno on failure. 
 pub fn spdk_nvmf_tgt_add_transport ( tgt : * mut spdk_nvmf_tgt , transport : * mut spdk_nvmf_transport , cb_fn : spdk_nvmf_tgt_add_transport_done_fn , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Add listener to transport and begin accepting new connections.
///
/// \param transport The transport to add listener to
/// \param trid Address to listen at
///
/// \return int. 0 if it completed successfully, or negative errno if it failed. 
 pub fn spdk_nvmf_transport_listen ( transport : * mut spdk_nvmf_transport , trid : * const spdk_nvme_transport_id ) -> libc :: c_int ; } extern "C" { 
 /// Write NVMe-oF target's transport configurations into provided JSON context.
/// \param w JSON write context
/// \param tgt The NVMe-oF target 
 pub fn spdk_nvmf_tgt_transport_write_config_json ( w : * mut spdk_json_write_ctx , tgt : * mut spdk_nvmf_tgt ) ; } 
 /// Describes the parameters of an spdk_reduce_vol. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_reduce_vol_params { pub uuid : spdk_uuid , 
 /// Size in bytes of the IO unit for the backing device.  This
    ///  is the unit in which space is allocated from the backing
    ///  device, and the unit in which data is read from of written
    ///  to the backing device.  Must be greater than 0. 
 pub backing_io_unit_size : u32 , 
 /// Size in bytes of a logical block.  This is the unit in
    ///  which users read or write data to the compressed volume.
    ///  Must be greater than 0. 
 pub logical_block_size : u32 , 
 /// Size in bytes of a chunk on the compressed volume.  This
    ///  is the unit in which data is compressed.  Must be an even
    ///  multiple of backing_io_unit_size and logical_block_size.
    ///  Must be greater than 0. 
 pub chunk_size : u32 , 
 /// Total size in bytes of the compressed volume.  During
    ///  initialization, the size is calculated from the size of
    ///  backing device size, so this must be set to 0 in the
    ///  structure passed to spdk_reduce_vol_init().  After
    ///  initialization, or a successful load, this field will
    ///  contain the total size which will be an even multiple
    ///  of the chunk size. 
 pub vol_size : u64 , } impl Default for spdk_reduce_vol_params { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_reduce_vol { _unused : [ u8 ; 0 ] , } pub type spdk_reduce_vol_op_complete = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , reduce_errno : libc :: c_int ) > ; pub type spdk_reduce_vol_op_with_handle_complete = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut libc :: c_void , vol : * mut spdk_reduce_vol , reduce_errno : libc :: c_int ) > ; pub type spdk_reduce_dev_cpl = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut libc :: c_void , reduce_errno : libc :: c_int ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_reduce_vol_cb_args { pub cb_fn : spdk_reduce_dev_cpl , pub cb_arg : * mut libc :: c_void , } impl Default for spdk_reduce_vol_cb_args { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_reduce_backing_dev { pub readv : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_reduce_backing_dev , iov : * mut iovec , iovcnt : libc :: c_int , lba : u64 , lba_count : u32 , args : * mut spdk_reduce_vol_cb_args ) > , pub writev : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_reduce_backing_dev , iov : * mut iovec , iovcnt : libc :: c_int , lba : u64 , lba_count : u32 , args : * mut spdk_reduce_vol_cb_args ) > , pub unmap : :: std :: option :: Option < unsafe extern "C" fn ( dev : * mut spdk_reduce_backing_dev , lba : u64 , lba_count : u32 , args : * mut spdk_reduce_vol_cb_args ) > , pub blockcnt : u64 , pub blocklen : u32 , } impl Default for spdk_reduce_backing_dev { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Get the UUID for a libreduce compressed volume.
///
/// \param vol Previously loaded or initialized compressed volume.
/// \return UUID for the compressed volume. 
 pub fn spdk_reduce_vol_get_uuid ( vol : * mut spdk_reduce_vol ) -> * const spdk_uuid ; } extern "C" { 
 /// Initialize a new libreduce compressed volume.
///
/// \param params Parameters for the new volume.
/// \param backing_dev Structure describing the backing device to use for the new volume.
/// \param pm_file_dir Directory to use for creation of the persistent memory file to
///                    use for the new volume.  This function will append the UUID as
///		      the filename to create in this directory.
/// \param cb_fn Callback function to signal completion of the initialization process.
/// \param cb_arg Argument to pass to the callback function. 
 pub fn spdk_reduce_vol_init ( params : * mut spdk_reduce_vol_params , backing_dev : * mut spdk_reduce_backing_dev , pm_file_dir : * const libc :: c_char , cb_fn : spdk_reduce_vol_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Load an existing libreduce compressed volume.
///
/// \param backing_dev Structure describing the backing device containing the compressed volume.
/// \param cb_fn Callback function to signal completion of the loading process.
/// \param cb_arg Argument to pass to the callback function. 
 pub fn spdk_reduce_vol_load ( backing_dev : * mut spdk_reduce_backing_dev , cb_fn : spdk_reduce_vol_op_with_handle_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Unload a previously initialized or loaded libreduce compressed volume.
///
/// \param vol Volume to unload.
/// \param cb_fn Callback function to signal completion of the unload process.
/// \param cb_arg Argument to pass to the callback function. 
 pub fn spdk_reduce_vol_unload ( vol : * mut spdk_reduce_vol , cb_fn : spdk_reduce_vol_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Destroy an existing libreduce compressed volume.
///
/// This will zero the metadata region on the backing device and delete the associated
/// pm metadata file.  If the backing device does not contain a compressed volume, the
/// cb_fn will be called with error status without modifying the backing device nor
/// deleting a pm file.
///
/// \param backing_dev Structure describing the backing device containing the compressed volume.
/// \param cb_fn Callback function to signal completion of the destruction process.
/// \param cb_arg Argument to pass to the callback function. 
 pub fn spdk_reduce_vol_destroy ( backing_dev : * mut spdk_reduce_backing_dev , cb_fn : spdk_reduce_vol_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Read data from a libreduce compressed volume.
///
/// This function will only read from logical blocks on the comparessed volume that
/// fall within the same chunk.
///
/// \param vol Volume to read data.
/// \param iov iovec array describing the data to be read
/// \param iovcnt Number of elements in the iovec array
/// \param offset Offset (in logical blocks) to read the data on the compressed volume
/// \param length Length (in logical blocks) of the data to read
/// \param cb_fn Callback function to signal completion of the readv operation.
/// \param cb_arg Argument to pass to the callback function. 
 pub fn spdk_reduce_vol_readv ( vol : * mut spdk_reduce_vol , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , length : u64 , cb_fn : spdk_reduce_vol_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Write data to a libreduce compressed volume.
///
/// This function will only write to logical blocks on the comparessed volume that
/// fall within the same chunk.
///
/// \param vol Volume to write data.
/// \param iov iovec array describing the data to be written
/// \param iovcnt Number of elements in the iovec array
/// \param offset Offset (in logical blocks) to write the data on the compressed volume
/// \param length Length (in logical blocks) of the data to write
/// \param cb_fn Callback function to signal completion of the writev operation.
/// \param cb_arg Argument to pass to the callback function. 
 pub fn spdk_reduce_vol_writev ( vol : * mut spdk_reduce_vol , iov : * mut iovec , iovcnt : libc :: c_int , offset : u64 , length : u64 , cb_fn : spdk_reduce_vol_op_complete , cb_arg : * mut libc :: c_void ) ; } extern "C" { 
 /// Start listening for RPC connections.
///
/// \param listen_addr Listening address.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_rpc_listen ( listen_addr : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Poll the RPC server. 
 pub fn spdk_rpc_accept ( ) ; } extern "C" { 
 /// Stop listening for RPC connections. 
 pub fn spdk_rpc_close ( ) ; } 
 /// Function signature for RPC request handlers.
///
/// \param request RPC request to handle.
/// \param params Parameters associated with the RPC request. 
 pub type spdk_rpc_method_handler = :: std :: option :: Option < unsafe extern "C" fn ( request : * mut spdk_jsonrpc_request , params : * const spdk_json_val ) > ; extern "C" { 
 /// Register an RPC method.
///
/// \param method Name for the registered method.
/// \param func Function registered for this method to handle the RPC request.
/// \param state_mask State mask of the registered method. If the bit of the state of
/// the RPC server is set in the state_mask, the method is allowed. Otherwise, it is rejected. 
 pub fn spdk_rpc_register_method ( method : * const libc :: c_char , func : spdk_rpc_method_handler , state_mask : u32 ) ; } extern "C" { 
 /// Check if \c method is allowed for \c state_mask
///
/// \param method Method name
/// \param state_mask state mask to check against
/// \return 0 if method is allowed or negative error code:
/// -EPERM method is not allowed
/// -ENOENT method not found 
 pub fn spdk_rpc_is_method_allowed ( method : * const libc :: c_char , state_mask : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Set the state mask of the RPC server. Any RPC method whose state mask is
/// equal to the state of the RPC server is allowed.
///
/// \param state_mask New state mask of the RPC server. 
 pub fn spdk_rpc_set_state ( state_mask : u32 ) ; } extern "C" { 
 /// Get the current state of the RPC server.
///
/// \return The current state of the RPC server. 
 pub fn spdk_rpc_get_state ( ) -> u32 ; } pub const spdk_scsi_data_dir_SPDK_SCSI_DIR_NONE : spdk_scsi_data_dir = 0 ; pub const spdk_scsi_data_dir_SPDK_SCSI_DIR_TO_DEV : spdk_scsi_data_dir = 1 ; pub const spdk_scsi_data_dir_SPDK_SCSI_DIR_FROM_DEV : spdk_scsi_data_dir = 2 ; pub type spdk_scsi_data_dir = u32 ; pub const spdk_scsi_task_func_SPDK_SCSI_TASK_FUNC_ABORT_TASK : spdk_scsi_task_func = 0 ; pub const spdk_scsi_task_func_SPDK_SCSI_TASK_FUNC_ABORT_TASK_SET : spdk_scsi_task_func = 1 ; pub const spdk_scsi_task_func_SPDK_SCSI_TASK_FUNC_CLEAR_TASK_SET : spdk_scsi_task_func = 2 ; pub const spdk_scsi_task_func_SPDK_SCSI_TASK_FUNC_LUN_RESET : spdk_scsi_task_func = 3 ; pub type spdk_scsi_task_func = u32 ; pub const spdk_scsi_task_mgmt_resp_SPDK_SCSI_TASK_MGMT_RESP_COMPLETE : spdk_scsi_task_mgmt_resp = 0 ; pub const spdk_scsi_task_mgmt_resp_SPDK_SCSI_TASK_MGMT_RESP_SUCCESS : spdk_scsi_task_mgmt_resp = 1 ; pub const spdk_scsi_task_mgmt_resp_SPDK_SCSI_TASK_MGMT_RESP_REJECT : spdk_scsi_task_mgmt_resp = 2 ; pub const spdk_scsi_task_mgmt_resp_SPDK_SCSI_TASK_MGMT_RESP_INVALID_LUN : spdk_scsi_task_mgmt_resp = 3 ; pub const spdk_scsi_task_mgmt_resp_SPDK_SCSI_TASK_MGMT_RESP_TARGET_FAILURE : spdk_scsi_task_mgmt_resp = 4 ; pub const spdk_scsi_task_mgmt_resp_SPDK_SCSI_TASK_MGMT_RESP_REJECT_FUNC_NOT_SUPPORTED : spdk_scsi_task_mgmt_resp = 5 ; pub type spdk_scsi_task_mgmt_resp = u32 ; pub type spdk_scsi_task_cpl = :: std :: option :: Option < unsafe extern "C" fn ( task : * mut spdk_scsi_task ) > ; pub type spdk_scsi_task_free = :: std :: option :: Option < unsafe extern "C" fn ( task : * mut spdk_scsi_task ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_scsi_task { pub status : u8 , pub function : u8 , pub response : u8 , pub lun : * mut spdk_scsi_lun , pub target_port : * mut spdk_scsi_port , pub initiator_port : * mut spdk_scsi_port , pub cpl_fn : spdk_scsi_task_cpl , pub free_fn : spdk_scsi_task_free , pub ref_ : u32 , pub transfer_len : u32 , pub dxfer_dir : u32 , pub length : u32 , 
 /// Amount of data actually transferred.  Can be less than requested
    ///  transfer_len - i.e. SCSI INQUIRY. 
 pub data_transferred : u32 , pub offset : u64 , pub cdb : * mut u8 , 
 /// \internal
    /// Size of internal buffer or zero when iov.iov_base is not internally managed. 
 pub alloc_len : u32 , 
 /// \internal
    /// iov is internal buffer. Use iovs to access elements of IO. 
 pub iov : iovec , pub iovs : * mut iovec , pub iovcnt : u16 , pub sense_data : [ u8 ; 32usize ] , pub sense_data_len : usize , pub bdev_io : * mut libc :: c_void , pub scsi_link : spdk_scsi_task__bindgen_ty_1 , pub abort_id : u32 , pub bdev_io_wait : spdk_bdev_io_wait_entry , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_scsi_task__bindgen_ty_1 { pub tqe_next : * mut spdk_scsi_task , pub tqe_prev : * mut * mut spdk_scsi_task , } impl Default for spdk_scsi_task__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl Default for spdk_scsi_task { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_scsi_port { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_scsi_dev { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_scsi_lun { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_scsi_desc { _unused : [ u8 ; 0 ] , } pub type spdk_scsi_remove_cb_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut spdk_scsi_lun , arg2 : * mut libc :: c_void ) > ; extern "C" { 
 /// Initialize SCSI layer.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_scsi_init ( ) -> libc :: c_int ; } extern "C" { 
 /// Stop and clean the SCSI layer. 
 pub fn spdk_scsi_fini ( ) ; } extern "C" { 
 /// Get the LUN id of the given logical unit.
///
/// \param lun Logical unit.
///
/// \return LUN id of the logical unit. 
 pub fn spdk_scsi_lun_get_id ( lun : * const spdk_scsi_lun ) -> libc :: c_int ; } extern "C" { 
 /// Get the name of the bdev associated with the given logical unit.
///
/// \param lun Logical unit.
///
/// \return the name of the bdev associated with the logical unit. 
 pub fn spdk_scsi_lun_get_bdev_name ( lun : * const spdk_scsi_lun ) -> * const libc :: c_char ; } extern "C" { 
 /// Get the SCSI device associated with the given logical unit.
///
/// \param lun Logical unit.
///
/// \return the SCSI device associated with the logical unit. 
 pub fn spdk_scsi_lun_get_dev ( lun : * const spdk_scsi_lun ) -> * const spdk_scsi_dev ; } extern "C" { 
 /// Check if the logical unit is hot removing.
///
/// \param lun Logical unit
///
/// \return true if removing, false otherwise. 
 pub fn spdk_scsi_lun_is_removing ( lun : * const spdk_scsi_lun ) -> bool ; } extern "C" { 
 /// Get the name of the given SCSI device.
///
/// \param dev SCSI device.
///
/// \return the name of the SCSI device on success, or NULL on failure. 
 pub fn spdk_scsi_dev_get_name ( dev : * const spdk_scsi_dev ) -> * const libc :: c_char ; } extern "C" { 
 /// Get the id of the given SCSI device.
///
/// \param dev SCSI device.
///
/// \return the id of the SCSI device. 
 pub fn spdk_scsi_dev_get_id ( dev : * const spdk_scsi_dev ) -> libc :: c_int ; } extern "C" { 
 /// Get the logical unit of the given SCSI device whose id is lun_id.
///
/// \param dev SCSI device.
/// \param lun_id Id of the logical unit.
///
/// \return the logical unit on success, or NULL on failure. 
 pub fn spdk_scsi_dev_get_lun ( dev : * mut spdk_scsi_dev , lun_id : libc :: c_int ) -> * mut spdk_scsi_lun ; } extern "C" { 
 /// Check whether the SCSI device has any pending task.
///
/// \param dev SCSI device.
///
/// \return true if the SCSI device has any pending task, or false otherwise. 
 pub fn spdk_scsi_dev_has_pending_tasks ( dev : * const spdk_scsi_dev ) -> bool ; } extern "C" { 
 /// Destruct the SCSI decice.
///
/// \param dev SCSI device. 
 pub fn spdk_scsi_dev_destruct ( dev : * mut spdk_scsi_dev ) ; } extern "C" { 
 /// Execute the SCSI management task.
///
/// The task can be constructed by the function spdk_scsi_task_construct().
/// Code of task management function to be executed is set before calling this API.
///
/// \param dev SCSI device.
/// \param task SCSI task to be executed. 
 pub fn spdk_scsi_dev_queue_mgmt_task ( dev : * mut spdk_scsi_dev , task : * mut spdk_scsi_task ) ; } extern "C" { 
 /// Execute the SCSI task.
///
/// The task can be constructed by the function spdk_scsi_task_construct().
///
/// \param dev SCSI device.
/// \param task Task to be executed. 
 pub fn spdk_scsi_dev_queue_task ( dev : * mut spdk_scsi_dev , task : * mut spdk_scsi_task ) ; } extern "C" { 
 /// Add a new port to the given SCSI device.
///
/// \param dev SCSI device.
/// \param id Port id.
/// \param name Port name.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_scsi_dev_add_port ( dev : * mut spdk_scsi_dev , id : u64 , name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Delete a specified port of the given SCSI device.
///
/// \param dev SCSI device.
/// \param id Port id.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_scsi_dev_delete_port ( dev : * mut spdk_scsi_dev , id : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Get the port of the given SCSI device whose port ID is id.
///
/// \param dev SCSI device.
/// \param id Port id.
///
/// \return the port of the SCSI device on success, or NULL on failure. 
 pub fn spdk_scsi_dev_find_port_by_id ( dev : * mut spdk_scsi_dev , id : u64 ) -> * mut spdk_scsi_port ; } extern "C" { 
 /// Allocate I/O channels for all LUNs of the given SCSI device.
///
/// \param dev SCSI device.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_scsi_dev_allocate_io_channels ( dev : * mut spdk_scsi_dev ) -> libc :: c_int ; } extern "C" { 
 /// Free I/O channels from all LUNs of the given SCSI device. 
 pub fn spdk_scsi_dev_free_io_channels ( dev : * mut spdk_scsi_dev ) ; } extern "C" { 
 /// Construct a SCSI device object using the given parameters.
///
/// \param name Name for the SCSI device.
/// \param bdev_name_list List of bdev names to attach to the LUNs for this SCSI
/// device.
/// \param lun_id_list List of LUN IDs for the LUN in this SCSI device. Caller is
/// responsible for managing the memory containing this list. lun_id_list[x] is
/// the LUN ID for lun_list[x].
/// \param num_luns Number of entries in lun_list and lun_id_list.
/// \param protocol_id SCSI SPC protocol identifier to report in INQUIRY data
/// \param hotremove_cb Callback to lun hotremoval. Will be called once hotremove
/// is first triggered.
/// \param hotremove_ctx Additional argument to hotremove_cb.
///
/// \return the constructed spdk_scsi_dev object. 
 pub fn spdk_scsi_dev_construct ( name : * const libc :: c_char , bdev_name_list : * mut * const libc :: c_char , lun_id_list : * mut libc :: c_int , num_luns : libc :: c_int , protocol_id : u8 , hotremove_cb : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const spdk_scsi_lun , arg2 : * mut libc :: c_void ) > , hotremove_ctx : * mut libc :: c_void ) -> * mut spdk_scsi_dev ; } extern "C" { 
 /// Delete a logical unit of the given SCSI device.
///
/// \param dev SCSI device.
/// \param lun Logical unit to delete. 
 pub fn spdk_scsi_dev_delete_lun ( dev : * mut spdk_scsi_dev , lun : * mut spdk_scsi_lun ) ; } extern "C" { 
 /// Add a new logical unit to the given SCSI device.
///
/// \param dev SCSI device.
/// \param bdev_name Name of the bdev attached to the logical unit.
/// \param lun_id LUN id for the new logical unit.
/// \param hotremove_cb Callback to lun hotremoval. Will be called once hotremove
/// is first triggered.
/// \param hotremove_ctx Additional argument to hotremove_cb. 
 pub fn spdk_scsi_dev_add_lun ( dev : * mut spdk_scsi_dev , bdev_name : * const libc :: c_char , lun_id : libc :: c_int , hotremove_cb : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const spdk_scsi_lun , arg2 : * mut libc :: c_void ) > , hotremove_ctx : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Create a new SCSI port.
///
/// \param id Port id.
/// \param index Port index.
/// \param name Port Name.
///
/// \return a pointer to the created SCSI port on success, or NULL on failure. 
 pub fn spdk_scsi_port_create ( id : u64 , index : u16 , name : * const libc :: c_char ) -> * mut spdk_scsi_port ; } extern "C" { 
 /// Free the SCSI port.
///
/// \param pport SCSI port to free. 
 pub fn spdk_scsi_port_free ( pport : * mut * mut spdk_scsi_port ) ; } extern "C" { 
 /// Get the name of the SCSI port.
///
/// \param port SCSI port to query.
///
/// \return the name of the SCSI port. 
 pub fn spdk_scsi_port_get_name ( port : * const spdk_scsi_port ) -> * const libc :: c_char ; } extern "C" { 
 /// Construct a new SCSI task.
///
/// \param task SCSI task to consturct.
/// \param cpl_fn Called when the task is completed.
/// \param free_fn Called when the task is freed 
 pub fn spdk_scsi_task_construct ( task : * mut spdk_scsi_task , cpl_fn : spdk_scsi_task_cpl , free_fn : spdk_scsi_task_free ) ; } extern "C" { 
 /// Put the SCSI task.
///
/// \param task SCSI task to put. 
 pub fn spdk_scsi_task_put ( task : * mut spdk_scsi_task ) ; } extern "C" { 
 /// Set internal buffer to given one. Caller is owner of that buffer.
///
/// \param task SCSI task.
/// \param data Pointer to buffer.
/// \param len Buffer length. 
 pub fn spdk_scsi_task_set_data ( task : * mut spdk_scsi_task , data : * mut libc :: c_void , len : u32 ) ; } extern "C" { 
 /// Single buffer -> vector of buffers.
///
/// \param task SCSI task.
/// \param src A pointer to the data buffer read from.
/// \param len Length of the data buffer read from.
///
/// \return the total length of the vector of buffers written into on success, or
/// -1 on failure. 
 pub fn spdk_scsi_task_scatter_data ( task : * mut spdk_scsi_task , src : * const libc :: c_void , len : usize ) -> libc :: c_int ; } extern "C" { 
 /// Vector of buffers -> single buffer.
///
/// \param task SCSI task,
/// \param len Length of the buffer allocated and written into.
///
/// \return a pointer to the buffer allocated and written into. 
 pub fn spdk_scsi_task_gather_data ( task : * mut spdk_scsi_task , len : * mut libc :: c_int ) -> * mut libc :: c_void ; } extern "C" { 
 /// Build sense data for the SCSI task.
///
/// \param task SCSI task.
/// \param sk Sense key.
/// \param asc Additional sense code.
/// \param ascq Additional sense code qualifier. 
 pub fn spdk_scsi_task_build_sense_data ( task : * mut spdk_scsi_task , sk : libc :: c_int , asc : libc :: c_int , ascq : libc :: c_int ) ; } extern "C" { 
 /// Set SCSI status code to the SCSI task. When the status code is CHECK CONDITION,
/// sense data is build too.
///
/// \param task SCSI task.
/// \param sc Sense code
/// \param sk Sense key.
/// \param asc Additional sense code.
/// \param ascq Additional sense code qualifier. 
 pub fn spdk_scsi_task_set_status ( task : * mut spdk_scsi_task , sc : libc :: c_int , sk : libc :: c_int , asc : libc :: c_int , ascq : libc :: c_int ) ; } extern "C" { 
 /// Copy SCSI status.
///
/// \param dst SCSI task whose status is written to.
/// \param src SCSI task whose status is read from. 
 pub fn spdk_scsi_task_copy_status ( dst : * mut spdk_scsi_task , src : * mut spdk_scsi_task ) ; } extern "C" { 
 /// Process the SCSI task when no LUN is attached.
///
/// \param task SCSI task. 
 pub fn spdk_scsi_task_process_null_lun ( task : * mut spdk_scsi_task ) ; } extern "C" { 
 /// Process the aborted SCSI task.
///
/// \param task SCSI task. 
 pub fn spdk_scsi_task_process_abort ( task : * mut spdk_scsi_task ) ; } extern "C" { 
 /// Open a logical unit for I/O operations.
///
/// The registered callback function must get all tasks from the upper layer
///  (e.g. iSCSI) to the LUN done, free the IO channel of the LUN if allocated,
///  and then close the LUN.
///
/// \param lun Logical unit to open.
/// \param hotremove_cb Callback function for hot removal of the logical unit.
/// \param hotremove_ctx Param for hot removal callback function.
/// \param desc Output parameter for the descriptor when operation is successful.
/// \return 0 if operation is successful, suitable errno value otherwise 
 pub fn spdk_scsi_lun_open ( lun : * mut spdk_scsi_lun , hotremove_cb : spdk_scsi_remove_cb_t , hotremove_ctx : * mut libc :: c_void , desc : * mut * mut spdk_scsi_desc ) -> libc :: c_int ; } extern "C" { 
 /// Close an opened logical unit.
///
/// \param desc Descriptor of the logical unit. 
 pub fn spdk_scsi_lun_close ( desc : * mut spdk_scsi_desc ) ; } extern "C" { 
 /// Allocate I/O channel for the LUN
///
/// \param desc Descriptor of the logical unit.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_scsi_lun_allocate_io_channel ( desc : * mut spdk_scsi_desc ) -> libc :: c_int ; } extern "C" { 
 /// Free I/O channel from the logical unit
///
/// \param desc Descriptor of the logical unit. 
 pub fn spdk_scsi_lun_free_io_channel ( desc : * mut spdk_scsi_desc ) ; } extern "C" { 
 /// Set iSCSI Initiator port TransportID
///
/// \param port SCSI initiator port.
/// \param iscsi_name Initiator name.
/// \param isid Session ID. 
 pub fn spdk_scsi_port_set_iscsi_transport_id ( port : * mut spdk_scsi_port , iscsi_name : * mut libc :: c_char , isid : u64 ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_sock_group { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Get client and server addresses of the given socket.
///
/// \param sock Socket to get address.
/// \param saddr A pointer to the buffer to hold the address of server.
/// \param slen Length of the buffer 'saddr'.
/// \param sport A pointer(May be NULL) to the buffer to hold the port info of server.
/// \param caddr A pointer to the buffer to hold the address of client.
/// \param clen Length of the buffer 'caddr'.
/// \param cport A pointer(May be NULL) to the buffer to hold the port info of server.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_getaddr ( sock : * mut spdk_sock , saddr : * mut libc :: c_char , slen : libc :: c_int , sport : * mut u16 , caddr : * mut libc :: c_char , clen : libc :: c_int , cport : * mut u16 ) -> libc :: c_int ; } extern "C" { 
 /// Create a socket, connect the socket to the specified address and port (of the
/// server), and then return the socket. This function is used by client.
///
/// \param ip IP address of the server.
/// \param port Port number of the server.
///
/// \return a pointer to the connected socket on success, or NULL on failure. 
 pub fn spdk_sock_connect ( ip : * const libc :: c_char , port : libc :: c_int ) -> * mut spdk_sock ; } extern "C" { 
 /// Create a socket, bind the socket to the specified address and port and listen
/// on the socket, and then return the socket. This function is used by server.
///
/// \param ip IP address to listen on.
/// \param port Port number.
///
/// \return a pointer to the listened socket on success, or NULL on failure. 
 pub fn spdk_sock_listen ( ip : * const libc :: c_char , port : libc :: c_int ) -> * mut spdk_sock ; } extern "C" { 
 /// Accept a new connection from a client on the specified socket and return a
/// socket structure which holds the connection.
///
/// \param sock Listening socket.
///
/// \return a pointer to the accepted socket on success, or NULL on failure. 
 pub fn spdk_sock_accept ( sock : * mut spdk_sock ) -> * mut spdk_sock ; } extern "C" { 
 /// Close a socket.
///
/// \param sock Socket to close.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_close ( sock : * mut * mut spdk_sock ) -> libc :: c_int ; } extern "C" { 
 /// Receive a message from the given socket.
///
/// \param sock Socket to receive message.
/// \param buf Pointer to a buffer to hold the data.
/// \param len Length of the buffer.
///
/// \return the length of the received message on success, -1 on failure. 
 pub fn spdk_sock_recv ( sock : * mut spdk_sock , buf : * mut libc :: c_void , len : usize ) -> isize ; } extern "C" { 
 /// Write message to the given socket from the I/O vector array.
///
/// \param sock Socket to write to.
/// \param iov I/O vector.
/// \param iovcnt Number of I/O vectors in the array.
///
/// \return the length of written message on success, -1 on failure. 
 pub fn spdk_sock_writev ( sock : * mut spdk_sock , iov : * mut iovec , iovcnt : libc :: c_int ) -> isize ; } extern "C" { 
 /// Set the value used to specify the low water mark (in bytes) for this socket.
///
/// \param sock Socket to set for.
/// \param nbytes Value for recvlowat.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_set_recvlowat ( sock : * mut spdk_sock , nbytes : libc :: c_int ) -> libc :: c_int ; } extern "C" { 
 /// Set receive buffer size for the given socket.
///
/// \param sock Socket to set buffer size for.
/// \param sz Buffer size in bytes.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_set_recvbuf ( sock : * mut spdk_sock , sz : libc :: c_int ) -> libc :: c_int ; } extern "C" { 
 /// Set send buffer size for the given socket.
///
/// \param sock Socket to set buffer size for.
/// \param sz Buffer size in bytes.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_set_sendbuf ( sock : * mut spdk_sock , sz : libc :: c_int ) -> libc :: c_int ; } extern "C" { 
 /// Check whether the address of socket is ipv6.
///
/// \param sock Socket to check.
///
/// \return true if the address of socket is ipv6, or false otherwise. 
 pub fn spdk_sock_is_ipv6 ( sock : * mut spdk_sock ) -> bool ; } extern "C" { 
 /// Check whether the address of socket is ipv4.
///
/// \param sock Socket to check.
///
/// \return true if the address of socket is ipv4, or false otherwise. 
 pub fn spdk_sock_is_ipv4 ( sock : * mut spdk_sock ) -> bool ; } 
 /// Callback function for spdk_sock_group_add_sock().
///
/// \param arg Argument for the callback function.
/// \param group Socket group.
/// \param sock Socket. 
 pub type spdk_sock_cb = :: std :: option :: Option < unsafe extern "C" fn ( arg : * mut libc :: c_void , group : * mut spdk_sock_group , sock : * mut spdk_sock ) > ; extern "C" { 
 /// Create a new socket group.
///
/// \return a pointer to the created group on success, or NULL on failure. 
 pub fn spdk_sock_group_create ( ) -> * mut spdk_sock_group ; } extern "C" { 
 /// Add a socket to the group.
///
/// \param group Socket group.
/// \param sock Socket to add.
/// \param cb_fn Called when the operation completes.
/// \param cb_arg Argument passed to the callback function.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_group_add_sock ( group : * mut spdk_sock_group , sock : * mut spdk_sock , cb_fn : spdk_sock_cb , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Remove a socket from the group.
///
/// \param group Socket group.
/// \param sock Socket to remove.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_group_remove_sock ( group : * mut spdk_sock_group , sock : * mut spdk_sock ) -> libc :: c_int ; } extern "C" { 
 /// Poll incoming events for each registered socket.
///
/// \param group Group to poll.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_group_poll ( group : * mut spdk_sock_group ) -> libc :: c_int ; } extern "C" { 
 /// Poll incoming events up to max_events for each registered socket.
///
/// \param group Group to poll.
/// \param max_events Number of maximum events to poll for each socket.
///
/// \return the number of events on success, -1 on failure. 
 pub fn spdk_sock_group_poll_count ( group : * mut spdk_sock_group , max_events : libc :: c_int ) -> libc :: c_int ; } extern "C" { 
 /// Close all registered sockets of the group and then remove the group.
///
/// \param group Group to close.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_sock_group_close ( group : * mut * mut spdk_sock_group ) -> libc :: c_int ; } extern "C" { 
 /// sprintf with automatic buffer allocation.
///
/// The return value is the formatted string, which should be passed to free()
/// when no longer needed.
///
/// \param format Format for the string to print.
///
/// \return the formatted string on success, or NULL on failure. 
 pub fn spdk_sprintf_alloc ( format : * const libc :: c_char , ... ) -> * mut libc :: c_char ; } extern "C" { 
 /// vsprintf with automatic buffer allocation.
///
/// The return value is the formatted string, which should be passed to free()
/// when no longer needed.
///
/// \param format Format for the string to print.
/// \param args A value that identifies a variable arguments list.
///
/// \return the formatted string on success, or NULL on failure. 
 pub fn spdk_vsprintf_alloc ( format : * const libc :: c_char , args : * mut __va_list_tag ) -> * mut libc :: c_char ; } extern "C" { 
 /// Append string using vsprintf with automatic buffer re-allocation.
///
/// The return value is the formatted string, in which the original string in
/// buffer is unchanged and the specified formatted string is appended.
///
/// The returned string should be passed to free() when no longer needed.
///
/// If buffer is NULL, the call is equivalent to spdk_sprintf_alloc().
/// If the call fails, the original buffer is left untouched.
///
/// \param buffer Buffer which has a formatted string.
/// \param format Format for the string to print.
///
/// \return the formatted string on success, or NULL on failure. 
 pub fn spdk_sprintf_append_realloc ( buffer : * mut libc :: c_char , format : * const libc :: c_char , ... ) -> * mut libc :: c_char ; } extern "C" { 
 /// Append string using vsprintf with automatic buffer re-allocation.
/// The return value is the formatted string, in which the original string in
/// buffer is unchanged and the specified formatted string is appended.
///
/// The returned string should be passed to free() when no longer needed.
///
/// If buffer is NULL, the call is equivalent to spdk_sprintf_alloc().
/// If the call fails, the original buffer is left untouched.
///
/// \param buffer Buffer which has a formatted string.
/// \param format Format for the string to print.
/// \param args A value that identifies a variable arguments list.
///
/// \return the formatted string on success, or NULL on failure. 
 pub fn spdk_vsprintf_append_realloc ( buffer : * mut libc :: c_char , format : * const libc :: c_char , args : * mut __va_list_tag ) -> * mut libc :: c_char ; } extern "C" { 
 /// Convert string to lowercase in place.
///
/// \param s String to convert to lowercase.
///
/// \return the converted string. 
 pub fn spdk_strlwr ( s : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { 
 /// Parse a delimited string with quote handling.
///
/// Note that the string will be modified in place to add the string terminator
/// to each field.
///
/// \param stringp Pointer to starting location in string. *stringp will be updated
/// to point to the start of the next field, or NULL if the end of the string has
/// been reached.
/// \param delim Null-terminated string containing the list of accepted delimiters.
///
/// \return a pointer to beginning of the current field. 
 pub fn spdk_strsepq ( stringp : * mut * mut libc :: c_char , delim : * const libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { 
 /// Trim whitespace from a string in place.
///
/// \param s String to trim.
///
/// \return the trimmed string. 
 pub fn spdk_str_trim ( s : * mut libc :: c_char ) -> * mut libc :: c_char ; } extern "C" { 
 /// Copy the string version of an error into the user supplied buffer
///
/// \param errnum Error code.
/// \param buf Pointer to a buffer in which to place the error message.
/// \param buflen The size of the buffer in bytes. 
 pub fn spdk_strerror_r ( errnum : libc :: c_int , buf : * mut libc :: c_char , buflen : usize ) ; } extern "C" { 
 /// Return the string version of an error from a static, thread-local buffer. This
/// function is thread safe.
///
/// \param errnum Error code.
///
/// \return a pointer to buffer upon success. 
 pub fn spdk_strerror ( errnum : libc :: c_int ) -> * const libc :: c_char ; } extern "C" { 
 /// Remove trailing newlines from the end of a string in place.
///
/// Any sequence of trailing \\r and \\n characters is removed from the end of the
/// string.
///
/// \param s String to remove newline from.
///
/// \return the number of characters removed. 
 pub fn spdk_str_chomp ( s : * mut libc :: c_char ) -> usize ; } extern "C" { 
 /// Copy a string into a fixed-size buffer, padding extra bytes with a specific
/// character.
///
/// If src is longer than size, only size bytes will be copied.
///
/// \param dst Pointer to destination fixed-size buffer to fill.
/// \param src Pointer to source null-terminated string to copy into dst.
/// \param size Number of bytes to fill in dst.
/// \param pad Character to pad extra space in dst beyond the size of src. 
 pub fn spdk_strcpy_pad ( dst : * mut libc :: c_void , src : * const libc :: c_char , size : usize , pad : libc :: c_int ) ; } extern "C" { 
 /// Find the length of a string that has been padded with a specific byte.
///
/// \param str Right-padded string to find the length of.
/// \param size Size of the full string pointed to by str, including padding.
/// \param pad Character that was used to pad str up to size.
///
/// \return the length of the non-padded portion of str. 
 pub fn spdk_strlen_pad ( str : * const libc :: c_void , size : usize , pad : libc :: c_int ) -> usize ; } extern "C" { 
 /// Parse an IP address into its hostname and port components. This modifies the
/// IP address in place.
///
/// \param ip A null terminated IP address, including port. Both IPv4 and IPv6
/// are supported.
/// \param host Will point to the start of the hostname within ip. The string will
/// be null terminated.
/// \param port Will point to the start of the port within ip. The string will be
/// null terminated.
///
/// \return 0 on success. -EINVAL on failure. 
 pub fn spdk_parse_ip_addr ( ip : * mut libc :: c_char , host : * mut * mut libc :: c_char , port : * mut * mut libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Parse a string representing a number possibly followed by a binary prefix.
///
/// The string can contain a trailing "B" (KB,MB,GB) but it's not necessary.
/// "128K" = 128 * 1024; "2G" = 2 * 1024 * 1024; "2GB" = 2 * 1024 * 1024;
/// Additionally, lowercase "k", "m", "g" are parsed as well. They are processed
/// the same as their uppercase equivalents.
///
/// \param cap_str Null terminated string.
/// \param cap Pointer where the parsed capacity (in bytes) will be put.
/// \param has_prefix Pointer to a flag that will be set to describe whether given
/// string contains a binary prefix.
///
/// \return 0 on success, or negative errno on failure. 
 pub fn spdk_parse_capacity ( cap_str : * const libc :: c_char , cap : * mut u64 , has_prefix : * mut bool ) -> libc :: c_int ; } extern "C" { 
 /// Check if a buffer is all zero (0x00) bytes or not.
///
/// \param data Buffer to check.
/// \param size Size of data in bytes.
///
/// \return true if data consists entirely of zeroes, or false if any byte in data
/// is not zero. 
 pub fn spdk_mem_all_zero ( data : * const libc :: c_void , size : usize ) -> bool ; } extern "C" { 
 /// Convert the string in nptr to a long integer value according to the given base.
///
/// spdk_strtol() does the additional error checking and allows only strings that
/// contains only numbers and is positive number or zero. The caller only has to check
/// if the return value is not negative.
///
/// \param nptr String containing numbers.
/// \param base Base which must be between 2 and 32 inclusive, or be the special value 0.
///
/// \return positive number or zero on success, or negative errno on failure. 
 pub fn spdk_strtol ( nptr : * const libc :: c_char , base : libc :: c_int ) -> libc :: c_long ; } extern "C" { 
 /// Convert the string in nptr to a long long integer value according to the given base.
///
/// spdk_strtoll() does the additional error checking and allows only strings that
/// contains only numbers and is positive number or zero. The caller only has to check
/// if the return value is not negative.
///
/// \param nptr String containing numbers.
/// \param base Base which must be between 2 and 32 inclusive, or be the special value 0.
///
/// \return positive number or zero on success, or negative errno on failure. 
 pub fn spdk_strtoll ( nptr : * const libc :: c_char , base : libc :: c_int ) -> libc :: c_longlong ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_trace_entry { pub tsc : u64 , pub tpoint_id : u16 , pub poller_id : u16 , pub size : u32 , pub object_id : u64 , pub arg1 : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_trace_owner { pub type_ : u8 , pub id_prefix : libc :: c_char , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_trace_object { pub type_ : u8 , pub id_prefix : libc :: c_char , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_trace_tpoint { pub name : [ libc :: c_char ; 44usize ] , pub short_name : [ libc :: c_char ; 4usize ] , pub tpoint_id : u16 , pub owner_type : u8 , pub object_type : u8 , pub new_object : u8 , pub arg1_is_ptr : u8 , pub reserved : u8 , pub arg1_name : [ libc :: c_char ; 8usize ] , } impl Default for spdk_trace_tpoint { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] pub struct spdk_trace_history { 
 /// Logical core number associated with this structure instance. 
 pub lcore : libc :: c_int , 
 /// Number of trace_entries contained in each trace_history. 
 pub num_entries : u64 , 
 /// Running count of number of occurrences of each tracepoint on this
    ///  lcore.  Debug tools can use this to easily count tracepoints such as
    ///  number of SCSI tasks completed or PDUs read. 
 pub tpoint_count : [ u64 ; 1024usize ] , 
 /// Index to next spdk_trace_entry to fill. 
 pub next_entry : u64 , 
 /// Circular buffer of spdk_trace_entry structures for tracing
    ///  tpoints on this core.  Debug tool spdk_trace reads this
    ///  buffer from shared memory to post-process the tpoint entries and
    ///  display in a human-readable format. 
 pub entries : __IncompleteArrayField < spdk_trace_entry > , } impl Default for spdk_trace_history { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_trace_flags { pub tsc_rate : u64 , pub tpoint_mask : [ u64 ; 16usize ] , pub owner : [ spdk_trace_owner ; 256usize ] , pub object : [ spdk_trace_object ; 256usize ] , pub tpoint : [ spdk_trace_tpoint ; 1024usize ] , 
 /// Offset of each trace_history from the beginning of this data structure.
    /// The last one is the offset of the file end. 
 pub lcore_history_offsets : [ u64 ; 129usize ] , } impl Default for spdk_trace_flags { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] pub struct spdk_trace_histories { pub flags : spdk_trace_flags , 
 /// struct spdk_trace_history has a dynamic size determined by num_entries
    /// in spdk_trace_init. Mark array size of per_lcore_history to be 0 in uint8_t
    /// as a reminder that each per_lcore_history pointer should be gotten by
    /// proper API, instead of directly referencing by struct element. 
 pub per_lcore_history : __IncompleteArrayField < u8 > , } impl Default for spdk_trace_histories { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { pub fn _spdk_trace_record ( tsc : u64 , tpoint_id : u16 , poller_id : u16 , size : u32 , object_id : u64 , arg1 : u64 ) ; } extern "C" { 
 /// Get the current tpoint mask of the given tpoint group.
///
/// \param group_id Tpoint group id associated with the tpoint mask.
///
/// \return current tpoint mask. 
 pub fn spdk_trace_get_tpoint_mask ( group_id : u32 ) -> u64 ; } extern "C" { 
 /// Add the specified tpoints to the current tpoint mask for the given tpoint group.
///
/// \param group_id Tpoint group id associated with the tpoint mask.
/// \param tpoint_mask Tpoint mask which indicates which tpoints to add to the
/// current tpoint mask. 
 pub fn spdk_trace_set_tpoints ( group_id : u32 , tpoint_mask : u64 ) ; } extern "C" { 
 /// Clear the specified tpoints from the current tpoint mask for the given tpoint group.
///
/// \param group_id Tpoint group id associated with the tpoint mask.
/// \param tpoint_mask Tpoint mask which indicates which tpoints to clear from
/// the current tpoint mask. 
 pub fn spdk_trace_clear_tpoints ( group_id : u32 , tpoint_mask : u64 ) ; } extern "C" { 
 /// Get a mask of all tracepoint groups which have at least one tracepoint enabled.
///
/// \return a mask of all tracepoint groups. 
 pub fn spdk_trace_get_tpoint_group_mask ( ) -> u64 ; } extern "C" { 
 /// For each tpoint group specified in the group mask, enable all of its tpoints.
///
/// \param tpoint_group_mask Tpoint group mask that indicates which tpoints to enable. 
 pub fn spdk_trace_set_tpoint_group_mask ( tpoint_group_mask : u64 ) ; } extern "C" { 
 /// For each tpoint group specified in the group mask, disable all of its tpoints.
///
/// \param tpoint_group_mask Tpoint group mask that indicates which tpoints to disable. 
 pub fn spdk_trace_clear_tpoint_group_mask ( tpoint_group_mask : u64 ) ; } extern "C" { 
 /// Initialize the trace environment. Debug tool can read the information from
/// the given shared memory to post-process the tpoint entries and display in a
/// human-readable format.
///
/// \param shm_name Name of shared memory.
/// \param num_entries Number of trace entries per lcore.
/// \return 0 on success, else non-zero indicates a failure. 
 pub fn spdk_trace_init ( shm_name : * const libc :: c_char , num_entries : u64 ) -> libc :: c_int ; } extern "C" { 
 /// Unmap global trace memory structs. 
 pub fn spdk_trace_cleanup ( ) ; } extern "C" { 
 /// Initialize trace flags. 
 pub fn spdk_trace_flags_init ( ) ; } extern "C" { 
 /// Register the trace owner.
///
/// \param type Type of the trace owner.
/// \param id_prefix Prefix of id for the trace owner. 
 pub fn spdk_trace_register_owner ( type_ : u8 , id_prefix : libc :: c_char ) ; } extern "C" { 
 /// Register the trace object.
///
/// \param type Type of the trace object.
/// \param id_prefix Prefix of id for the trace object. 
 pub fn spdk_trace_register_object ( type_ : u8 , id_prefix : libc :: c_char ) ; } extern "C" { 
 /// Register the description for the tpoint.
///
/// \param name Name for the tpoint.
/// \param short_name Short name for the tpoint.
/// \param tpoint_id Id for the tpoint.
/// \param owner_type Owner type for the tpoint.
/// \param object_type Object type for the tpoint.
/// \param new_object New object for the tpoint.
/// \param arg1_is_ptr This argument indicates whether argument1 is a pointer.
/// \param arg1_name Name of argument. 
 pub fn spdk_trace_register_description ( name : * const libc :: c_char , short_name : * const libc :: c_char , tpoint_id : u16 , owner_type : u8 , object_type : u8 , new_object : u8 , arg1_is_ptr : u8 , arg1_name : * const libc :: c_char ) ; } extern "C" { pub fn spdk_trace_get_first_register_fn ( ) -> * mut spdk_trace_register_fn ; } extern "C" { pub fn spdk_trace_get_next_register_fn ( register_fn : * mut spdk_trace_register_fn ) -> * mut spdk_trace_register_fn ; } extern "C" { 
 /// Enable trace on specific tpoint group
///
/// \param group_name Name of group to enable, "all" for enabling all groups.
/// \return 0 on success, else non-zero indicates a failure. 
 pub fn spdk_trace_enable_tpoint_group ( group_name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Disable trace on specific tpoint group
///
/// \param group_name Name of group to disable, "all" for disabling all groups.
/// \return 0 on success, else non-zero indicates a failure. 
 pub fn spdk_trace_disable_tpoint_group ( group_name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Show trace mask and its usage.
///
/// \param f File to hold the mask's information.
/// \param tmask_arg Command line option to set the trace group mask. 
 pub fn spdk_trace_mask_usage ( f : * mut FILE , tmask_arg : * const libc :: c_char ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_trace_register_fn { pub name : * const libc :: c_char , pub tgroup_id : u8 , pub reg_fn : :: std :: option :: Option < unsafe extern "C" fn ( ) > , pub next : * mut spdk_trace_register_fn , } impl Default for spdk_trace_register_fn { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Add new trace register function.
///
/// \param reg_fn Trace register function to add. 
 pub fn spdk_trace_add_register_fn ( reg_fn : * mut spdk_trace_register_fn ) ; } 
 /// Callback funcion for spdk_vhost_fini(). 
 pub type spdk_vhost_fini_cb = :: std :: option :: Option < unsafe extern "C" fn ( ) > ; extern "C" { 
 /// Set the path to the directory where vhost sockets will be created.
///
/// This function must be called before spdk_vhost_init().
///
/// \param basename Path to vhost socket directory
///
/// \return 0 on success, negative errno on error. 
 pub fn spdk_vhost_set_socket_path ( basename : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Init vhost environment.
///
/// \return 0 on success, -1 on failure. 
 pub fn spdk_vhost_init ( ) -> libc :: c_int ; } extern "C" { 
 /// Clean up the environment of vhost after finishing the vhost application.
///
/// \param fini_cb Called when the cleanup operation completes. 
 pub fn spdk_vhost_fini ( fini_cb : spdk_vhost_fini_cb ) ; } extern "C" { 
 /// Write vhost subsystem configuration into provided JSON context.
///
/// \param w JSON write context
/// \param done_ev call this event when done. 
 pub fn spdk_vhost_config_json ( w : * mut spdk_json_write_ctx , done_ev : * mut spdk_event ) ; } extern "C" { 
 /// Deinit vhost application. This is called once by SPDK app layer. 
 pub fn spdk_vhost_shutdown_cb ( ) ; } 
 /// SPDK vhost device (vdev).  An equivalent of Virtio device.
/// Both virtio-blk and virtio-scsi devices are represented by this
/// struct. For virtio-scsi a single vhost device (also called SCSI
/// controller) may contain multiple SCSI targets (devices), each of
/// which may contain multiple logical units (SCSI LUNs). For now
/// only one LUN per target is available.
///
/// All vdev-changing functions operate directly on this object.
/// Note that \c spdk_vhost_dev cannot be acquired. This object is
/// only accessible as a callback parameter via \c
/// spdk_vhost_call_external_event and it's derivatives. This ensures
/// that all access to the vdev is piped through a single,
/// thread-safe API. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_vhost_dev { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Lock the global vhost mutex, which synchronizes all the vhost device accesses. 
 pub fn spdk_vhost_lock ( ) ; } extern "C" { 
 /// Unlock the global vhost mutex. 
 pub fn spdk_vhost_unlock ( ) ; } extern "C" { 
 /// Find a vhost device by name.
///
/// \return vhost device or NULL 
 pub fn spdk_vhost_dev_find ( name : * const libc :: c_char ) -> * mut spdk_vhost_dev ; } extern "C" { 
 /// Get the next vhost device. If there's no more devices to iterate
/// through, NULL will be returned.
///
/// \param vdev vhost device. If NULL, this function will return the
/// very first device.
/// \return vdev vhost device or NULL 
 pub fn spdk_vhost_dev_next ( vdev : * mut spdk_vhost_dev ) -> * mut spdk_vhost_dev ; } 
 /// Synchronized vhost event used for user callbacks.
///
/// \param vdev vhost device.
/// \param arg user-provided parameter.
///
/// \return 0 on success, -1 on failure. 
 pub type spdk_vhost_event_fn = :: std :: option :: Option < unsafe extern "C" fn ( vdev : * mut spdk_vhost_dev , arg : * mut libc :: c_void ) -> libc :: c_int > ; extern "C" { 
 /// Get the name of the vhost device.  This is equal to the filename
/// of socket file. The name is constant throughout the lifetime of
/// a vdev.
///
/// \param vdev vhost device.
///
/// \return name of the vdev. 
 pub fn spdk_vhost_dev_get_name ( vdev : * mut spdk_vhost_dev ) -> * const libc :: c_char ; } extern "C" { 
 /// Get cpuset of the vhost device.  The cpuset is constant throughout the lifetime
/// of a vdev. It is a subset of SPDK app cpuset vhost was started with.
///
/// \param vdev vhost device.
///
/// \return cpuset of the vdev. 
 pub fn spdk_vhost_dev_get_cpumask ( vdev : * mut spdk_vhost_dev ) -> * const spdk_cpuset ; } extern "C" { 
 /// By default, events are generated when asked, but for high queue depth and
/// high IOPS this prove to be inefficient both for guest kernel that have to
/// handle a lot more IO completions and for SPDK vhost that need to make more
/// syscalls. If enabled, limit amount of events (IRQs) sent to initiator by SPDK
/// vhost effectively coalescing couple of completions. This of cource introduce
/// IO latency penalty proportional to event delay time.
///
/// Actual events delay time when is calculated according to below formula:
/// if (delay_base == 0 || IOPS < iops_threshold) {
///   delay = 0;
/// } else if (IOPS < iops_threshold) {
///   delay = delay_base * (iops - iops_threshold) / iops_threshold;
/// }
///
/// \param vdev vhost device.
/// \param delay_base_us Base delay time in microseconds. If 0, coalescing is disabled.
/// \param iops_threshold IOPS threshold when coalescing is activated. 
 pub fn spdk_vhost_set_coalescing ( vdev : * mut spdk_vhost_dev , delay_base_us : u32 , iops_threshold : u32 ) -> libc :: c_int ; } extern "C" { 
 /// Get coalescing parameters.
///
/// \see spdk_vhost_set_coalescing
///
/// \param vdev vhost device.
/// \param delay_base_us Optional pointer to store base delay time.
/// \param iops_threshold Optional pointer to store IOPS threshold. 
 pub fn spdk_vhost_get_coalescing ( vdev : * mut spdk_vhost_dev , delay_base_us : * mut u32 , iops_threshold : * mut u32 ) ; } extern "C" { 
 /// Construct an empty vhost SCSI device.  This will create a
/// Unix domain socket together with a vhost-user slave server waiting
/// for a connection on this socket. Creating the vdev does not
/// start any I/O pollers and does not hog the CPU. I/O processing
/// starts after receiving proper message on the created socket.
/// See QEMU's vhost-user documentation for details.
/// All physical devices have to be separately attached to this
/// vdev via \c spdk_vhost_scsi_dev_add_tgt().
///
/// This function is thread-safe.
///
/// \param name name of the vhost device. The name will also be used
/// for socket name, which is exactly \c socket_base_dir/name
/// \param cpumask string containing cpumask in hex. The leading *0x*
/// is allowed but not required. The mask itself can be constructed as:
/// ((1 << cpu0) | (1 << cpu1) | ... | (1 << cpuN)).
///
/// \return 0 on success, negative errno on error. 
 pub fn spdk_vhost_scsi_dev_construct ( name : * const libc :: c_char , cpumask : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Construct and attach new SCSI target to the vhost SCSI device
/// on given (unoccupied) slot.  The device will be created with a single
/// LUN0 associated with given SPDK bdev. Currently only one LUN per
/// device is supported.
///
/// If the vhost SCSI device has an active connection and has negotiated
/// \c VIRTIO_SCSI_F_HOTPLUG feature,  the new SCSI target should be
/// automatically detected by the other side.
///
/// \param vdev vhost SCSI device.
/// \param scsi_tgt_num slot to attach to or negative value to use first free.
/// \param bdev_name name of the SPDK bdev to associate with SCSI LUN0.
///
/// \return value >= 0 on success - the SCSI target ID, negative errno code:
/// -EINVAL - one of the arguments is invalid:
///   - vdev is not vhost SCSI device
///   - SCSI target ID is out of range
///   - bdev name is NULL
///   - can't create SCSI LUN because of other errors e.g.: bdev does not exist
/// -ENOSPC - scsi_tgt_num is -1 and maximum targets in vhost SCSI device reached
/// -EEXIST - SCSI target ID already exists 
 pub fn spdk_vhost_scsi_dev_add_tgt ( vdev : * mut spdk_vhost_dev , scsi_tgt_num : libc :: c_int , bdev_name : * const libc :: c_char ) -> libc :: c_int ; } extern "C" { 
 /// Get SCSI target from vhost SCSI device on given slot. Max
/// number of available slots is defined by.
/// \c SPDK_VHOST_SCSI_CTRLR_MAX_DEVS.
///
/// \param vdev vhost SCSI device.
/// \param num slot id.
///
/// \return SCSI device on given slot or NULL. 
 pub fn spdk_vhost_scsi_dev_get_tgt ( vdev : * mut spdk_vhost_dev , num : u8 ) -> * mut spdk_scsi_dev ; } extern "C" { 
 /// Detach and destruct SCSI target from a vhost SCSI device.
///
/// The device will be deleted after all pending I/O is finished.
/// If the driver supports VIRTIO_SCSI_F_HOTPLUG, then a hotremove
/// notification will be sent.
///
/// \param vdev vhost SCSI device
/// \param scsi_tgt_num slot id to delete target from
/// \param cb_fn callback to be fired once target has been successfully
/// deleted. The first parameter of callback function is the vhost SCSI
/// device, the second is user provided argument *cb_arg*.
/// \param cb_arg parameter to be passed to *cb_fn*.
///
/// \return 0 on success, negative errno on error. 
 pub fn spdk_vhost_scsi_dev_remove_tgt ( vdev : * mut spdk_vhost_dev , scsi_tgt_num : libc :: c_uint , cb_fn : spdk_vhost_event_fn , cb_arg : * mut libc :: c_void ) -> libc :: c_int ; } extern "C" { 
 /// Construct a vhost blk device.  This will create a Unix domain
/// socket together with a vhost-user slave server waiting for a
/// connection on this socket. Creating the vdev does not start
/// any I/O pollers and does not hog the CPU. I/O processing starts
/// after receiving proper message on the created socket.
/// See QEMU's vhost-user documentation for details. Vhost blk
/// device is tightly associated with given SPDK bdev. Given
/// bdev can not be changed, unless it has been hotremoved. This
/// would result in all I/O failing with virtio \c VIRTIO_BLK_S_IOERR
/// error code.
///
/// This function is thread-safe.
///
/// \param name name of the vhost blk device. The name will also be
/// used for socket name, which is exactly \c socket_base_dir/name
/// \param cpumask string containing cpumask in hex. The leading *0x*
/// is allowed but not required. The mask itself can be constructed as:
/// ((1 << cpu0) | (1 << cpu1) | ... | (1 << cpuN)).
/// \param dev_name bdev name to associate with this vhost device
/// \param readonly if set, all writes to the device will fail with
/// \c VIRTIO_BLK_S_IOERR error code.
///
/// \return 0 on success, negative errno on error. 
 pub fn spdk_vhost_blk_construct ( name : * const libc :: c_char , cpumask : * const libc :: c_char , dev_name : * const libc :: c_char , readonly : bool ) -> libc :: c_int ; } extern "C" { 
 /// Remove a vhost device. The device must not have any open connections on it's socket.
///
/// \param vdev vhost blk device.
///
/// \return 0 on success, negative errno on error. 
 pub fn spdk_vhost_dev_remove ( vdev : * mut spdk_vhost_dev ) -> libc :: c_int ; } extern "C" { 
 /// Get underlying SPDK bdev from vhost blk device. The bdev might be NULL, as it
/// could have been hotremoved.
///
/// \param ctrlr vhost blk device.
///
/// \return SPDK bdev associated with given vdev. 
 pub fn spdk_vhost_blk_get_dev ( ctrlr : * mut spdk_vhost_dev ) -> * mut spdk_bdev ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : libc :: c_uint , pub fp_offset : libc :: c_uint , pub overflow_arg_area : * mut libc :: c_void , pub reg_save_area : * mut libc :: c_void , } impl Default for __va_list_tag { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iface { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct io_device { pub _address : u8 , } 
 /// Quality of service parameters 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_qos { pub _address : u8 , } 
 /// The bdev I/O channel that this was handled on. 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_channel { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_pci_driver { pub _address : u8 , }