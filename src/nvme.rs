/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_env_opts {
    pub name: *const ::std::os::raw::c_char,
    pub core_mask: *const ::std::os::raw::c_char,
    pub shm_id: ::std::os::raw::c_int,
    pub mem_channel: ::std::os::raw::c_int,
    pub master_core: ::std::os::raw::c_int,
    pub mem_size: ::std::os::raw::c_int,
    pub no_pci: bool,
    pub hugepage_single_segments: bool,
    pub unlink_hugepage: bool,
    pub num_pci_addr: usize,
    pub pci_blacklist: *mut spdk_pci_addr,
    pub pci_whitelist: *mut spdk_pci_addr,
    pub env_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spdk_env_opts() {
    assert_eq!(
        ::std::mem::size_of::<spdk_env_opts>(),
        72usize,
        concat!("Size of: ", stringify!(spdk_env_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_env_opts>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_env_opts))
    );
}
impl Default for spdk_env_opts {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn spdk_env_opts_init(opts: *mut spdk_env_opts);
}
extern "C" {
    pub fn spdk_env_init(opts: *const spdk_env_opts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spdk_dma_malloc(
        size: usize,
        align: usize,
        phys_addr: *mut u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn spdk_dma_malloc_socket(
        size: usize,
        align: usize,
        phys_addr: *mut u64,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn spdk_dma_zmalloc(
        size: usize,
        align: usize,
        phys_addr: *mut u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn spdk_dma_zmalloc_socket(
        size: usize,
        align: usize,
        phys_addr: *mut u64,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn spdk_dma_realloc(
        buf: *mut ::std::os::raw::c_void,
        size: usize,
        align: usize,
        phys_addr: *mut u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn spdk_dma_free(buf: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_mempool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn spdk_mempool_create(
        name: *const ::std::os::raw::c_char,
        count: usize,
        ele_size: usize,
        cache_size: usize,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut spdk_mempool;
}
pub type spdk_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut spdk_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
extern "C" {
    pub fn spdk_mempool_create_ctor(
        name: *const ::std::os::raw::c_char,
        count: usize,
        ele_size: usize,
        cache_size: usize,
        socket_id: ::std::os::raw::c_int,
        obj_init: spdk_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
    ) -> *mut spdk_mempool;
}
extern "C" {
    pub fn spdk_mempool_get_name(mp: *mut spdk_mempool) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn spdk_mempool_free(mp: *mut spdk_mempool);
}
extern "C" {
    pub fn spdk_mempool_get(mp: *mut spdk_mempool) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn spdk_mempool_get_bulk(
        mp: *mut spdk_mempool,
        ele_arr: *mut *mut ::std::os::raw::c_void,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spdk_mempool_put(mp: *mut spdk_mempool, ele: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn spdk_mempool_put_bulk(
        mp: *mut spdk_mempool,
        ele_arr: *mut *mut ::std::os::raw::c_void,
        count: usize,
    );
}
extern "C" {
    pub fn spdk_mempool_count(pool: *const spdk_mempool) -> usize;
}
extern "C" {
    pub fn spdk_env_get_core_count() -> u32;
}
extern "C" {
    pub fn spdk_env_get_current_core() -> u32;
}
extern "C" {
    pub fn spdk_env_get_first_core() -> u32;
}
extern "C" {
    pub fn spdk_env_get_last_core() -> u32;
}
extern "C" {
    pub fn spdk_env_get_next_core(prev_core: u32) -> u32;
}
extern "C" {
    pub fn spdk_env_get_socket_id(core: u32) -> u32;
}
pub type thread_start_fn = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn spdk_env_thread_launch_pinned(
        core: u32,
        fn_: thread_start_fn,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spdk_env_thread_wait_all();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_pci_addr {
    pub domain: u32,
    pub bus: u8,
    pub dev: u8,
    pub func: u8,
}
#[test]
fn bindgen_test_layout_spdk_pci_addr() {
    assert_eq!(
        ::std::mem::size_of::<spdk_pci_addr>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_pci_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_pci_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_pci_addr))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cap_register {
    pub raw: u64,
    pub bits: spdk_nvme_cap_register__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_cap_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cap_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cap_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cap_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cap_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cap_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cap_register__bindgen_ty_1 {
    #[inline]
    pub fn mqes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_mqes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cqr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ams(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ams(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn to(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_to(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dstrd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dstrd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nssrs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nssrs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn css(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_css(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn bps(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mpsmin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mpsmin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mpsmax(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mpsmax(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mqes: u32,
        cqr: u32,
        ams: u32,
        reserved1: u32,
        to: u32,
        dstrd: u32,
        nssrs: u32,
        css: u32,
        bps: u32,
        reserved2: u32,
        mpsmin: u32,
        mpsmax: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let mqes: u32 = unsafe { ::std::mem::transmute(mqes) };
            mqes as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let cqr: u32 = unsafe { ::std::mem::transmute(cqr) };
            cqr as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let ams: u32 = unsafe { ::std::mem::transmute(ams) };
            ams as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let to: u32 = unsafe { ::std::mem::transmute(to) };
            to as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let dstrd: u32 = unsafe { ::std::mem::transmute(dstrd) };
            dstrd as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let nssrs: u32 = unsafe { ::std::mem::transmute(nssrs) };
            nssrs as u64
        });
        __bindgen_bitfield_unit.set(37usize, 8u8, {
            let css: u32 = unsafe { ::std::mem::transmute(css) };
            css as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let bps: u32 = unsafe { ::std::mem::transmute(bps) };
            bps as u64
        });
        __bindgen_bitfield_unit.set(46usize, 2u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let mpsmin: u32 = unsafe { ::std::mem::transmute(mpsmin) };
            mpsmin as u64
        });
        __bindgen_bitfield_unit.set(52usize, 4u8, {
            let mpsmax: u32 = unsafe { ::std::mem::transmute(mpsmax) };
            mpsmax as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cap_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cap_register>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_cap_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cap_register>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cap_register))
    );
}
impl Default for spdk_nvme_cap_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_cc_css_SPDK_NVME_CC_CSS_NVM: spdk_nvme_cc_css = 0;
pub type spdk_nvme_cc_css = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cc_register {
    pub raw: u32,
    pub bits: spdk_nvme_cc_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_cc_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cc_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cc_register__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cc_register__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cc_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cc_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cc_register__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn css(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_css(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mps(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ams(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ams(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn shn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn iosqes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_iosqes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn iocqes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_iocqes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        en: u32,
        reserved1: u32,
        css: u32,
        mps: u32,
        ams: u32,
        shn: u32,
        iosqes: u32,
        iocqes: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::std::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let css: u32 = unsafe { ::std::mem::transmute(css) };
            css as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let mps: u32 = unsafe { ::std::mem::transmute(mps) };
            mps as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let ams: u32 = unsafe { ::std::mem::transmute(ams) };
            ams as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let shn: u32 = unsafe { ::std::mem::transmute(shn) };
            shn as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let iosqes: u32 = unsafe { ::std::mem::transmute(iosqes) };
            iosqes as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let iocqes: u32 = unsafe { ::std::mem::transmute(iocqes) };
            iocqes as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cc_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cc_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cc_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cc_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cc_register))
    );
}
impl Default for spdk_nvme_cc_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_shn_value_SPDK_NVME_SHN_NORMAL: spdk_nvme_shn_value = 1;
pub const spdk_nvme_shn_value_SPDK_NVME_SHN_ABRUPT: spdk_nvme_shn_value = 2;
pub type spdk_nvme_shn_value = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_csts_register {
    pub raw: u32,
    pub bits: spdk_nvme_csts_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_csts_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_csts_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_csts_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_csts_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_csts_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_csts_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_csts_register__bindgen_ty_1 {
    #[inline]
    pub fn rdy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cfs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cfs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn nssro(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nssro(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdy: u32,
        cfs: u32,
        shst: u32,
        nssro: u32,
        pp: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rdy: u32 = unsafe { ::std::mem::transmute(rdy) };
            rdy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cfs: u32 = unsafe { ::std::mem::transmute(cfs) };
            cfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let shst: u32 = unsafe { ::std::mem::transmute(shst) };
            shst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nssro: u32 = unsafe { ::std::mem::transmute(nssro) };
            nssro as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pp: u32 = unsafe { ::std::mem::transmute(pp) };
            pp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_csts_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_csts_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_csts_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_csts_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_csts_register))
    );
}
impl Default for spdk_nvme_csts_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_shst_value_SPDK_NVME_SHST_NORMAL: spdk_nvme_shst_value = 0;
pub const spdk_nvme_shst_value_SPDK_NVME_SHST_OCCURRING: spdk_nvme_shst_value = 1;
pub const spdk_nvme_shst_value_SPDK_NVME_SHST_COMPLETE: spdk_nvme_shst_value = 2;
pub type spdk_nvme_shst_value = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_aqa_register {
    pub raw: u32,
    pub bits: spdk_nvme_aqa_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_aqa_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_aqa_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_aqa_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_aqa_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_aqa_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_aqa_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_aqa_register__bindgen_ty_1 {
    #[inline]
    pub fn asqs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_asqs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn acqs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_acqs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        asqs: u32,
        reserved1: u32,
        acqs: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let asqs: u32 = unsafe { ::std::mem::transmute(asqs) };
            asqs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let acqs: u32 = unsafe { ::std::mem::transmute(acqs) };
            acqs as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_aqa_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_aqa_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_aqa_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_aqa_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_aqa_register))
    );
}
impl Default for spdk_nvme_aqa_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_vs_register {
    pub raw: u32,
    pub bits: spdk_nvme_vs_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_vs_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_vs_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_vs_register__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_vs_register__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_vs_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_vs_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_vs_register__bindgen_ty_1 {
    #[inline]
    pub fn ter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mnr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mnr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mjr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_mjr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ter: u32,
        mnr: u32,
        mjr: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ter: u32 = unsafe { ::std::mem::transmute(ter) };
            ter as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let mnr: u32 = unsafe { ::std::mem::transmute(mnr) };
            mnr as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let mjr: u32 = unsafe { ::std::mem::transmute(mjr) };
            mjr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_vs_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_vs_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_vs_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_vs_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_vs_register))
    );
}
impl Default for spdk_nvme_vs_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmbloc_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbloc_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_cmbloc_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbloc_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbloc_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cmbloc_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbloc_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmbloc_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cmbloc_register__bindgen_ty_1 {
    #[inline]
    pub fn bir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn ofst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_ofst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bir: u32,
        reserved1: u32,
        ofst: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let bir: u32 = unsafe { ::std::mem::transmute(bir) };
            bir as u64
        });
        __bindgen_bitfield_unit.set(3usize, 9u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let ofst: u32 = unsafe { ::std::mem::transmute(ofst) };
            ofst as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbloc_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbloc_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmbloc_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbloc_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmbloc_register))
    );
}
impl Default for spdk_nvme_cmbloc_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmbsz_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbsz_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_cmbsz_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsz_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbsz_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cmbsz_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbsz_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmbsz_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cmbsz_register__bindgen_ty_1 {
    #[inline]
    pub fn sqs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sqs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cqs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lists(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lists(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rds(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rds(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wds(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wds(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn szu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_szu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sqs: u32,
        cqs: u32,
        lists: u32,
        rds: u32,
        wds: u32,
        reserved1: u32,
        szu: u32,
        sz: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sqs: u32 = unsafe { ::std::mem::transmute(sqs) };
            sqs as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cqs: u32 = unsafe { ::std::mem::transmute(cqs) };
            cqs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lists: u32 = unsafe { ::std::mem::transmute(lists) };
            lists as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rds: u32 = unsafe { ::std::mem::transmute(rds) };
            rds as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wds: u32 = unsafe { ::std::mem::transmute(wds) };
            wds as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let szu: u32 = unsafe { ::std::mem::transmute(szu) };
            szu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let sz: u32 = unsafe { ::std::mem::transmute(sz) };
            sz as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsz_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbsz_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmbsz_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbsz_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmbsz_register))
    );
}
impl Default for spdk_nvme_cmbsz_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_bpinfo_register {
    pub raw: u32,
    pub bits: spdk_nvme_bpinfo_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_bpinfo_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_bpinfo_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_bpinfo_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_bpinfo_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_bpinfo_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_bpinfo_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_bpinfo_register__bindgen_ty_1 {
    #[inline]
    pub fn bpsz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_bpsz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn brs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_brs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn abpid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_abpid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bpsz: u32,
        reserved1: u32,
        brs: u32,
        reserved2: u32,
        abpid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let bpsz: u32 = unsafe { ::std::mem::transmute(bpsz) };
            bpsz as u64
        });
        __bindgen_bitfield_unit.set(15usize, 9u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let brs: u32 = unsafe { ::std::mem::transmute(brs) };
            brs as u64
        });
        __bindgen_bitfield_unit.set(26usize, 5u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let abpid: u32 = unsafe { ::std::mem::transmute(abpid) };
            abpid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_bpinfo_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_bpinfo_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_bpinfo_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_bpinfo_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_bpinfo_register))
    );
}
impl Default for spdk_nvme_bpinfo_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_bprsel_register {
    pub raw: u32,
    pub bits: spdk_nvme_bprsel_register__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_bprsel_register__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_bprsel_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_bprsel_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_bprsel_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_bprsel_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_bprsel_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_bprsel_register__bindgen_ty_1 {
    #[inline]
    pub fn bprsz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_bprsz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn bprof(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_bprof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bpid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bpid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bprsz: u32,
        bprof: u32,
        reserved: u32,
        bpid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let bprsz: u32 = unsafe { ::std::mem::transmute(bprsz) };
            bprsz as u64
        });
        __bindgen_bitfield_unit.set(10usize, 20u8, {
            let bprof: u32 = unsafe { ::std::mem::transmute(bprof) };
            bprof as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bpid: u32 = unsafe { ::std::mem::transmute(bpid) };
            bpid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_bprsel_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_bprsel_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_bprsel_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_bprsel_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_bprsel_register))
    );
}
impl Default for spdk_nvme_bprsel_register {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_registers {
    pub cap: spdk_nvme_cap_register,
    pub vs: spdk_nvme_vs_register,
    pub intms: u32,
    pub intmc: u32,
    pub cc: spdk_nvme_cc_register,
    pub reserved1: u32,
    pub csts: spdk_nvme_csts_register,
    pub nssr: u32,
    pub aqa: spdk_nvme_aqa_register,
    pub asq: u64,
    pub acq: u64,
    pub cmbloc: spdk_nvme_cmbloc_register,
    pub cmbsz: spdk_nvme_cmbsz_register,
    pub bpinfo: spdk_nvme_bpinfo_register,
    pub bprsel: spdk_nvme_bprsel_register,
    pub bpmbl: u64,
    pub reserved3: [u32; 1004usize],
    pub doorbell: [spdk_nvme_registers__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_registers__bindgen_ty_1 {
    pub sq_tdbl: u32,
    pub cq_hdbl: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_registers__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_registers__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_registers__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_registers__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_registers__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_spdk_nvme_registers() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_registers>(),
        4104usize,
        concat!("Size of: ", stringify!(spdk_nvme_registers))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_registers>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_registers))
    );
}
impl Default for spdk_nvme_registers {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_DATA_BLOCK:
    spdk_nvme_sgl_descriptor_type = 0;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_BIT_BUCKET:
    spdk_nvme_sgl_descriptor_type = 1;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_SEGMENT: spdk_nvme_sgl_descriptor_type =
    2;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_LAST_SEGMENT:
    spdk_nvme_sgl_descriptor_type = 3;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK:
    spdk_nvme_sgl_descriptor_type = 4;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_TRANSPORT_DATA_BLOCK:
    spdk_nvme_sgl_descriptor_type = 5;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC:
    spdk_nvme_sgl_descriptor_type = 15;
pub type spdk_nvme_sgl_descriptor_type = u32;
pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_ADDRESS:
    spdk_nvme_sgl_descriptor_subtype = 0;
pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_OFFSET:
    spdk_nvme_sgl_descriptor_subtype = 1;
pub type spdk_nvme_sgl_descriptor_subtype = u32;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_sgl_descriptor {
    pub address: u64,
    pub __bindgen_anon_1: spdk_nvme_sgl_descriptor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    pub generic: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1,
    pub unkeyed: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2,
    pub keyed: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub reserved: [u8; 7usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn subtype(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subtype: u8, type_: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let subtype: u8 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    pub length: u32,
    pub reserved: [u8; 3usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn subtype(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subtype: u8, type_: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let subtype: u8 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3)
        )
    );
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn length(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn key(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_key(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn subtype(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        length: u64,
        key: u64,
        subtype: u64,
        type_: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let length: u64 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(24usize, 32u8, {
            let key: u64 = unsafe { ::std::mem::transmute(key) };
            key as u64
        });
        __bindgen_bitfield_unit.set(56usize, 4u8, {
            let subtype: u64 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit.set(60usize, 4u8, {
            let type_: u64 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1)
        )
    );
}
impl Default for spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_sgl_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_sgl_descriptor))
    );
}
impl Default for spdk_nvme_sgl_descriptor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_PRP: spdk_nvme_psdt_value = 0;
pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_CONTIG: spdk_nvme_psdt_value = 1;
pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_SGL: spdk_nvme_psdt_value = 2;
pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_RESERVED: spdk_nvme_psdt_value = 3;
pub type spdk_nvme_psdt_value = u32;
pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_URGENT: spdk_nvme_qprio = 0;
pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_HIGH: spdk_nvme_qprio = 1;
pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_MEDIUM: spdk_nvme_qprio = 2;
pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_LOW: spdk_nvme_qprio = 3;
pub type spdk_nvme_qprio = u32;
pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_WRR: spdk_nvme_cap_ams = 1;
pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_VS: spdk_nvme_cap_ams = 2;
pub type spdk_nvme_cap_ams = u32;
pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_RR: spdk_nvme_cc_ams = 0;
pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_WRR: spdk_nvme_cc_ams = 1;
pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_VS: spdk_nvme_cc_ams = 7;
pub type spdk_nvme_cc_ams = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_cmd {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub cid: u16,
    pub nsid: u32,
    pub rsvd2: u32,
    pub rsvd3: u32,
    pub mptr: u64,
    pub dptr: spdk_nvme_cmd__bindgen_ty_1,
    pub cdw10: u32,
    pub cdw11: u32,
    pub cdw12: u32,
    pub cdw13: u32,
    pub cdw14: u32,
    pub cdw15: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmd__bindgen_ty_1 {
    pub prp: spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1,
    pub sgl1: spdk_nvme_sgl_descriptor,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub prp1: u64,
    pub prp2: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmd__bindgen_ty_1))
    );
}
impl Default for spdk_nvme_cmd__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd>(),
        64usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmd))
    );
}
impl Default for spdk_nvme_cmd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl spdk_nvme_cmd {
    #[inline]
    pub fn opc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn fuse(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_fuse(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn psdt(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_psdt(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        opc: u16,
        fuse: u16,
        rsvd1: u16,
        psdt: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let opc: u16 = unsafe { ::std::mem::transmute(opc) };
            opc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let fuse: u16 = unsafe { ::std::mem::transmute(fuse) };
            fuse as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let rsvd1: u16 = unsafe { ::std::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let psdt: u16 = unsafe { ::std::mem::transmute(psdt) };
            psdt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_status() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_status>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_status))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_status>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_status))
    );
}
impl spdk_nvme_status {
    #[inline]
    pub fn p(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_sc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sct(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_sct(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn m(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_m(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dnr(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dnr(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        p: u16,
        sc: u16,
        sct: u16,
        rsvd2: u16,
        m: u16,
        dnr: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 8u8, {
            let sc: u16 = unsafe { ::std::mem::transmute(sc) };
            sc as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let sct: u16 = unsafe { ::std::mem::transmute(sct) };
            sct as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let rsvd2: u16 = unsafe { ::std::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let m: u16 = unsafe { ::std::mem::transmute(m) };
            m as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dnr: u16 = unsafe { ::std::mem::transmute(dnr) };
            dnr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_cpl {
    pub cdw0: u32,
    pub rsvd1: u32,
    pub sqhd: u16,
    pub sqid: u16,
    pub cid: u16,
    pub status: spdk_nvme_status,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cpl() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cpl>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_cpl))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cpl>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cpl))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_dsm_range {
    pub attributes: spdk_nvme_dsm_range__bindgen_ty_1,
    pub length: u32,
    pub starting_lba: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_dsm_range__bindgen_ty_1 {
    pub bits: spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1,
    pub raw: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn af(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_af(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn al(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_al(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn access_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_access_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        af: u32,
        al: u32,
        reserved0: u32,
        sr: u32,
        sw: u32,
        wp: u32,
        reserved1: u32,
        access_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let af: u32 = unsafe { ::std::mem::transmute(af) };
            af as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let al: u32 = unsafe { ::std::mem::transmute(al) };
            al as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let sr: u32 = unsafe { ::std::mem::transmute(sr) };
            sr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw: u32 = unsafe { ::std::mem::transmute(sw) };
            sw as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wp: u32 = unsafe { ::std::mem::transmute(wp) };
            wp as u64
        });
        __bindgen_bitfield_unit.set(11usize, 13u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let access_size: u32 = unsafe { ::std::mem::transmute(access_size) };
            access_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_dsm_range__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_dsm_range__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_dsm_range__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_dsm_range__bindgen_ty_1)
        )
    );
}
impl Default for spdk_nvme_dsm_range__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_dsm_range>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_dsm_range))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_dsm_range>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_dsm_range))
    );
}
impl Default for spdk_nvme_dsm_range {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_GENERIC: spdk_nvme_status_code_type = 0;
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_COMMAND_SPECIFIC: spdk_nvme_status_code_type = 1;
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_MEDIA_ERROR: spdk_nvme_status_code_type = 2;
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_PATH: spdk_nvme_status_code_type = 3;
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_VENDOR_SPECIFIC: spdk_nvme_status_code_type = 7;
pub type spdk_nvme_status_code_type = u32;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SUCCESS:
    spdk_nvme_generic_command_status_code = 0;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_OPCODE:
    spdk_nvme_generic_command_status_code = 1;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_FIELD:
    spdk_nvme_generic_command_status_code = 2;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_ID_CONFLICT:
    spdk_nvme_generic_command_status_code = 3;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_TRANSFER_ERROR:
    spdk_nvme_generic_command_status_code = 4;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_POWER_LOSS:
    spdk_nvme_generic_command_status_code = 5;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INTERNAL_DEVICE_ERROR:
    spdk_nvme_generic_command_status_code = 6;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_BY_REQUEST:
    spdk_nvme_generic_command_status_code = 7;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_SQ_DELETION:
    spdk_nvme_generic_command_status_code = 8;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_FAILED_FUSED:
    spdk_nvme_generic_command_status_code = 9;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_MISSING_FUSED:
    spdk_nvme_generic_command_status_code = 10;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT:
    spdk_nvme_generic_command_status_code = 11;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR:
    spdk_nvme_generic_command_status_code = 12;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR:
    spdk_nvme_generic_command_status_code = 13;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS:
    spdk_nvme_generic_command_status_code = 14;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID:
    spdk_nvme_generic_command_status_code = 15;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID:
    spdk_nvme_generic_command_status_code = 16;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID:
    spdk_nvme_generic_command_status_code = 17;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF:
    spdk_nvme_generic_command_status_code = 18;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_PRP_OFFSET:
    spdk_nvme_generic_command_status_code = 19;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED:
    spdk_nvme_generic_command_status_code = 20;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_OPERATION_DENIED:
    spdk_nvme_generic_command_status_code = 21;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_OFFSET:
    spdk_nvme_generic_command_status_code = 22;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT:
    spdk_nvme_generic_command_status_code = 24;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_EXPIRED:
    spdk_nvme_generic_command_status_code = 25;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_INVALID:
    spdk_nvme_generic_command_status_code = 26;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_PREEMPT:
    spdk_nvme_generic_command_status_code = 27;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_FAILED:
    spdk_nvme_generic_command_status_code = 28;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_IN_PROGRESS:
    spdk_nvme_generic_command_status_code = 29;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID:
    spdk_nvme_generic_command_status_code = 30;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_INVALID_IN_CMB:
    spdk_nvme_generic_command_status_code = 31;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_LBA_OUT_OF_RANGE:
    spdk_nvme_generic_command_status_code = 128;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_CAPACITY_EXCEEDED:
    spdk_nvme_generic_command_status_code = 129;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_NAMESPACE_NOT_READY:
    spdk_nvme_generic_command_status_code = 130;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_RESERVATION_CONFLICT:
    spdk_nvme_generic_command_status_code = 131;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_FORMAT_IN_PROGRESS:
    spdk_nvme_generic_command_status_code = 132;
pub type spdk_nvme_generic_command_status_code = u32;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_COMPLETION_QUEUE_INVALID:
    spdk_nvme_command_specific_status_code = 0;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER:
    spdk_nvme_command_specific_status_code = 1;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED:
    spdk_nvme_command_specific_status_code = 2;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED:
    spdk_nvme_command_specific_status_code = 3;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED:
    spdk_nvme_command_specific_status_code = 5;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_SLOT:
    spdk_nvme_command_specific_status_code = 6;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE:
    spdk_nvme_command_specific_status_code = 7;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR:
    spdk_nvme_command_specific_status_code = 8;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_LOG_PAGE:
    spdk_nvme_command_specific_status_code = 9;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FORMAT:
    spdk_nvme_command_specific_status_code = 10;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET:
    spdk_nvme_command_specific_status_code = 11;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_DELETION:
    spdk_nvme_command_specific_status_code = 12;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE:
    spdk_nvme_command_specific_status_code = 13;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE:
    spdk_nvme_command_specific_status_code = 14;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC:
    spdk_nvme_command_specific_status_code = 15;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET:
    spdk_nvme_command_specific_status_code = 16;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_RESET:
    spdk_nvme_command_specific_status_code = 17;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION:
    spdk_nvme_command_specific_status_code = 18;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED:
    spdk_nvme_command_specific_status_code = 19;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_OVERLAPPING_RANGE:
    spdk_nvme_command_specific_status_code = 20;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY:
    spdk_nvme_command_specific_status_code = 21;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE:
    spdk_nvme_command_specific_status_code = 22;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED:
    spdk_nvme_command_specific_status_code = 24;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_IS_PRIVATE:
    spdk_nvme_command_specific_status_code = 25;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED:
    spdk_nvme_command_specific_status_code = 26;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED:
    spdk_nvme_command_specific_status_code = 27;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONTROLLER_LIST_INVALID:
    spdk_nvme_command_specific_status_code = 28;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_DEVICE_SELF_TEST_IN_PROGRESS:
    spdk_nvme_command_specific_status_code = 29;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_BOOT_PARTITION_WRITE_PROHIBITED:
    spdk_nvme_command_specific_status_code = 30;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_CTRLR_ID:
    spdk_nvme_command_specific_status_code = 31;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_SECONDARY_CTRLR_STATE:
    spdk_nvme_command_specific_status_code = 32;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_NUM_CTRLR_RESOURCES:
    spdk_nvme_command_specific_status_code = 33;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_RESOURCE_ID:
    spdk_nvme_command_specific_status_code = 34;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONFLICTING_ATTRIBUTES:
    spdk_nvme_command_specific_status_code = 128;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_PROTECTION_INFO:
    spdk_nvme_command_specific_status_code = 129;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE:
    spdk_nvme_command_specific_status_code = 130;
pub type spdk_nvme_command_specific_status_code = u32;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_WRITE_FAULTS:
    spdk_nvme_media_error_status_code = 128;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_UNRECOVERED_READ_ERROR:
    spdk_nvme_media_error_status_code = 129;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_GUARD_CHECK_ERROR:
    spdk_nvme_media_error_status_code = 130;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR:
    spdk_nvme_media_error_status_code = 131;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR:
    spdk_nvme_media_error_status_code = 132;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_COMPARE_FAILURE:
    spdk_nvme_media_error_status_code = 133;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_ACCESS_DENIED:
    spdk_nvme_media_error_status_code = 134;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK:
    spdk_nvme_media_error_status_code = 135;
pub type spdk_nvme_media_error_status_code = u32;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_INTERNAL_PATH_ERROR: spdk_nvme_path_status_code =
    0;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_CONTROLLER_PATH_ERROR:
    spdk_nvme_path_status_code = 96;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_HOST_PATH_ERROR: spdk_nvme_path_status_code = 112;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_ABORTED_BY_HOST: spdk_nvme_path_status_code = 113;
pub type spdk_nvme_path_status_code = u32;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_SQ: spdk_nvme_admin_opcode = 0;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_SQ: spdk_nvme_admin_opcode = 1;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_LOG_PAGE: spdk_nvme_admin_opcode = 2;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_CQ: spdk_nvme_admin_opcode = 4;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_CQ: spdk_nvme_admin_opcode = 5;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_IDENTIFY: spdk_nvme_admin_opcode = 6;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ABORT: spdk_nvme_admin_opcode = 8;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SET_FEATURES: spdk_nvme_admin_opcode = 9;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_FEATURES: spdk_nvme_admin_opcode = 10;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ASYNC_EVENT_REQUEST: spdk_nvme_admin_opcode = 12;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_MANAGEMENT: spdk_nvme_admin_opcode = 13;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_COMMIT: spdk_nvme_admin_opcode = 16;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD: spdk_nvme_admin_opcode = 17;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DEVICE_SELF_TEST: spdk_nvme_admin_opcode = 20;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_ATTACHMENT: spdk_nvme_admin_opcode = 21;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_KEEP_ALIVE: spdk_nvme_admin_opcode = 24;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_SEND: spdk_nvme_admin_opcode = 25;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_RECEIVE: spdk_nvme_admin_opcode = 26;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT: spdk_nvme_admin_opcode =
    28;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_SEND: spdk_nvme_admin_opcode = 29;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_RECEIVE: spdk_nvme_admin_opcode = 30;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG: spdk_nvme_admin_opcode = 124;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FORMAT_NVM: spdk_nvme_admin_opcode = 128;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_SEND: spdk_nvme_admin_opcode = 129;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_RECEIVE: spdk_nvme_admin_opcode = 130;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SANITIZE: spdk_nvme_admin_opcode = 132;
pub type spdk_nvme_admin_opcode = u32;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_FLUSH: spdk_nvme_nvm_opcode = 0;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE: spdk_nvme_nvm_opcode = 1;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_READ: spdk_nvme_nvm_opcode = 2;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_UNCORRECTABLE: spdk_nvme_nvm_opcode = 4;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_COMPARE: spdk_nvme_nvm_opcode = 5;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_ZEROES: spdk_nvme_nvm_opcode = 8;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_DATASET_MANAGEMENT: spdk_nvme_nvm_opcode = 9;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REGISTER: spdk_nvme_nvm_opcode = 13;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REPORT: spdk_nvme_nvm_opcode = 14;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_ACQUIRE: spdk_nvme_nvm_opcode = 17;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_RELEASE: spdk_nvme_nvm_opcode = 21;
pub type spdk_nvme_nvm_opcode = u32;
pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_NONE: spdk_nvme_data_transfer = 0;
pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_HOST_TO_CONTROLLER: spdk_nvme_data_transfer = 1;
pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_CONTROLLER_TO_HOST: spdk_nvme_data_transfer = 2;
pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_BIDIRECTIONAL: spdk_nvme_data_transfer = 3;
pub type spdk_nvme_data_transfer = u32;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_ARBITRATION: spdk_nvme_feat = 1;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_POWER_MANAGEMENT: spdk_nvme_feat = 2;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_LBA_RANGE_TYPE: spdk_nvme_feat = 3;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD: spdk_nvme_feat = 4;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_ERROR_RECOVERY: spdk_nvme_feat = 5;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE: spdk_nvme_feat = 6;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_NUMBER_OF_QUEUES: spdk_nvme_feat = 7;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_COALESCING: spdk_nvme_feat = 8;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION: spdk_nvme_feat = 9;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_WRITE_ATOMICITY: spdk_nvme_feat = 10;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION: spdk_nvme_feat = 11;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION: spdk_nvme_feat = 12;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_MEM_BUFFER: spdk_nvme_feat = 13;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_TIMESTAMP: spdk_nvme_feat = 14;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_KEEP_ALIVE_TIMER: spdk_nvme_feat = 15;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT: spdk_nvme_feat = 16;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG: spdk_nvme_feat = 17;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER: spdk_nvme_feat = 128;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_IDENTIFIER: spdk_nvme_feat = 129;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_MASK: spdk_nvme_feat = 130;
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_PERSIST: spdk_nvme_feat = 131;
pub type spdk_nvme_feat = u32;
pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_READ: spdk_nvme_dsm_attribute = 1;
pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE: spdk_nvme_dsm_attribute = 2;
pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_DEALLOCATE: spdk_nvme_dsm_attribute = 4;
pub type spdk_nvme_dsm_attribute = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_power_state {
    pub mp: u16,
    pub reserved1: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub enlat: u32,
    pub exlat: u32,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub reserved7: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_power_state() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_power_state>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvme_power_state))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_power_state>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_power_state))
    );
}
impl spdk_nvme_power_state {
    #[inline]
    pub fn mps(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nops(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nops(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mps: u8,
        nops: u8,
        reserved2: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mps: u8 = unsafe { ::std::mem::transmute(mps) };
            mps as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nops: u8 = unsafe { ::std::mem::transmute(nops) };
            nops as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved2: u8 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rrt(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rrt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rrl(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rrl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(13usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rwt(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rwt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(21usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rwl(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rwl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(29usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        rrt: u8,
        reserved3: u8,
        rrl: u8,
        reserved4: u8,
        rwt: u8,
        reserved5: u8,
        rwl: u8,
        reserved6: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let rrt: u8 = unsafe { ::std::mem::transmute(rrt) };
            rrt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved3: u8 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let rrl: u8 = unsafe { ::std::mem::transmute(rrl) };
            rrl as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let reserved4: u8 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rwt: u8 = unsafe { ::std::mem::transmute(rwt) };
            rwt as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let reserved5: u8 = unsafe { ::std::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let rwl: u8 = unsafe { ::std::mem::transmute(rwl) };
            rwl as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let reserved6: u8 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS: spdk_nvme_identify_cns = 0;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR: spdk_nvme_identify_cns = 1;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST: spdk_nvme_identify_cns = 2;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST: spdk_nvme_identify_cns =
    3;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST: spdk_nvme_identify_cns = 16;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ALLOCATED: spdk_nvme_identify_cns = 17;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST: spdk_nvme_identify_cns =
    18;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR_LIST: spdk_nvme_identify_cns = 19;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP: spdk_nvme_identify_cns = 20;
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST: spdk_nvme_identify_cns =
    21;
pub type spdk_nvme_identify_cns = u32;
pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_NOT_SUPPORTED: spdk_nvme_sgls_supported = 0;
pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED: spdk_nvme_sgls_supported = 1;
pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED_DWORD_ALIGNED:
    spdk_nvme_sgls_supported = 2;
pub type spdk_nvme_sgls_supported = u32;
pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_NOT_INDICATED:
    spdk_nvme_flush_broadcast = 0;
pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_NOT_SUPPORTED:
    spdk_nvme_flush_broadcast = 2;
pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_SUPPORTED: spdk_nvme_flush_broadcast =
    3;
pub type spdk_nvme_flush_broadcast = u32;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_ctrlr_data {
    pub vid: u16,
    pub ssvid: u16,
    pub sn: [i8; 20usize],
    pub mn: [i8; 40usize],
    pub fr: [u8; 8usize],
    pub rab: u8,
    pub ieee: [u8; 3usize],
    pub cmic: spdk_nvme_ctrlr_data__bindgen_ty_1,
    pub mdts: u8,
    pub cntlid: u16,
    pub ver: spdk_nvme_vs_register,
    pub rtd3r: u32,
    pub rtd3e: u32,
    pub oaes: spdk_nvme_ctrlr_data__bindgen_ty_2,
    pub ctratt: spdk_nvme_ctrlr_data__bindgen_ty_3,
    pub reserved_100: [u8; 12usize],
    pub fguid: [u8; 16usize],
    pub reserved_128: [u8; 128usize],
    pub oacs: spdk_nvme_ctrlr_data__bindgen_ty_4,
    pub acl: u8,
    pub aerl: u8,
    pub frmw: spdk_nvme_ctrlr_data__bindgen_ty_5,
    pub lpa: spdk_nvme_ctrlr_data__bindgen_ty_6,
    pub elpe: u8,
    pub npss: u8,
    pub avscc: spdk_nvme_ctrlr_data__bindgen_ty_7,
    pub apsta: spdk_nvme_ctrlr_data__bindgen_ty_8,
    pub wctemp: u16,
    pub cctemp: u16,
    pub mtfa: u16,
    pub hmpre: u32,
    pub hmmin: u32,
    pub tnvmcap: [u64; 2usize],
    pub unvmcap: [u64; 2usize],
    pub rpmbs: spdk_nvme_ctrlr_data__bindgen_ty_9,
    pub edstt: u16,
    pub dsto: spdk_nvme_ctrlr_data__bindgen_ty_10,
    pub fwug: u8,
    pub kas: u16,
    pub hctma: spdk_nvme_ctrlr_data__bindgen_ty_11,
    pub mntmt: u16,
    pub mxtmt: u16,
    pub sanicap: spdk_nvme_ctrlr_data__bindgen_ty_12,
    pub reserved3: [u8; 180usize],
    pub sqes: spdk_nvme_ctrlr_data__bindgen_ty_13,
    pub cqes: spdk_nvme_ctrlr_data__bindgen_ty_14,
    pub maxcmd: u16,
    pub nn: u32,
    pub oncs: spdk_nvme_ctrlr_data__bindgen_ty_15,
    pub fuses: u16,
    pub fna: spdk_nvme_ctrlr_data__bindgen_ty_16,
    pub vwc: spdk_nvme_ctrlr_data__bindgen_ty_17,
    pub awun: u16,
    pub awupf: u16,
    pub nvscc: u8,
    pub reserved531: u8,
    pub acwu: u16,
    pub reserved534: u16,
    pub sgls: spdk_nvme_ctrlr_data__bindgen_ty_18,
    pub reserved4: [u8; 228usize],
    pub subnqn: [u8; 256usize],
    pub reserved5: [u8; 768usize],
    pub nvmf_specific: spdk_nvme_ctrlr_data__bindgen_ty_19,
    pub psd: [spdk_nvme_power_state; 32usize],
    pub vs: [u8; 1024usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_1 {
    #[inline]
    pub fn multi_port(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_multi_port(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_host(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_multi_host(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sr_iov(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sr_iov(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_port: u8,
        multi_host: u8,
        sr_iov: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_port: u8 = unsafe { ::std::mem::transmute(multi_port) };
            multi_port as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let multi_host: u8 = unsafe { ::std::mem::transmute(multi_host) };
            multi_host as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sr_iov: u8 = unsafe { ::std::mem::transmute(sr_iov) };
            sr_iov as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_2)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_2 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ns_attribute_notices(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ns_attribute_notices(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fw_activation_notices(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fw_activation_notices(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: u32,
        ns_attribute_notices: u32,
        fw_activation_notices: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ns_attribute_notices: u32 = unsafe { ::std::mem::transmute(ns_attribute_notices) };
            ns_attribute_notices as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let fw_activation_notices: u32 =
                unsafe { ::std::mem::transmute(fw_activation_notices) };
            fw_activation_notices as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_3)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_3 {
    #[inline]
    pub fn host_id_exhid_supported(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_id_exhid_supported(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_operational_power_state_permissive_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_operational_power_state_permissive_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        host_id_exhid_supported: u32,
        non_operational_power_state_permissive_mode: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let host_id_exhid_supported: u32 =
                unsafe { ::std::mem::transmute(host_id_exhid_supported) };
            host_id_exhid_supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let non_operational_power_state_permissive_mode: u32 =
                unsafe { ::std::mem::transmute(non_operational_power_state_permissive_mode) };
            non_operational_power_state_permissive_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_4>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_4>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_4)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_4 {
    #[inline]
    pub fn security(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_security(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_format(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn firmware(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_firmware(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ns_manage(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ns_manage(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn device_self_test(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_device_self_test(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directives(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_directives(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nvme_mi(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_nvme_mi(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virtualization_management(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_virtualization_management(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn doorbell_buffer_config(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_doorbell_buffer_config(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oacs_rsvd(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_oacs_rsvd(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        security: u16,
        format: u16,
        firmware: u16,
        ns_manage: u16,
        device_self_test: u16,
        directives: u16,
        nvme_mi: u16,
        virtualization_management: u16,
        doorbell_buffer_config: u16,
        oacs_rsvd: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let security: u16 = unsafe { ::std::mem::transmute(security) };
            security as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let format: u16 = unsafe { ::std::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let firmware: u16 = unsafe { ::std::mem::transmute(firmware) };
            firmware as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ns_manage: u16 = unsafe { ::std::mem::transmute(ns_manage) };
            ns_manage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let device_self_test: u16 = unsafe { ::std::mem::transmute(device_self_test) };
            device_self_test as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let directives: u16 = unsafe { ::std::mem::transmute(directives) };
            directives as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let nvme_mi: u16 = unsafe { ::std::mem::transmute(nvme_mi) };
            nvme_mi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let virtualization_management: u16 =
                unsafe { ::std::mem::transmute(virtualization_management) };
            virtualization_management as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let doorbell_buffer_config: u16 =
                unsafe { ::std::mem::transmute(doorbell_buffer_config) };
            doorbell_buffer_config as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let oacs_rsvd: u16 = unsafe { ::std::mem::transmute(oacs_rsvd) };
            oacs_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_5 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_5>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_5)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_5 {
    #[inline]
    pub fn slot1_ro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot1_ro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_slots(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_num_slots(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn activation_without_reset(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_activation_without_reset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frmw_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_frmw_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slot1_ro: u8,
        num_slots: u8,
        activation_without_reset: u8,
        frmw_rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slot1_ro: u8 = unsafe { ::std::mem::transmute(slot1_ro) };
            slot1_ro as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let num_slots: u8 = unsafe { ::std::mem::transmute(num_slots) };
            num_slots as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let activation_without_reset: u8 =
                unsafe { ::std::mem::transmute(activation_without_reset) };
            activation_without_reset as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let frmw_rsvd: u8 = unsafe { ::std::mem::transmute(frmw_rsvd) };
            frmw_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_6 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_6>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_6)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_6 {
    #[inline]
    pub fn ns_smart(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ns_smart(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn celp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_celp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edlp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_edlp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn telemetry(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_telemetry(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lpa_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_lpa_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ns_smart: u8,
        celp: u8,
        edlp: u8,
        telemetry: u8,
        lpa_rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ns_smart: u8 = unsafe { ::std::mem::transmute(ns_smart) };
            ns_smart as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let celp: u8 = unsafe { ::std::mem::transmute(celp) };
            celp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let edlp: u8 = unsafe { ::std::mem::transmute(edlp) };
            edlp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let telemetry: u8 = unsafe { ::std::mem::transmute(telemetry) };
            telemetry as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let lpa_rsvd: u8 = unsafe { ::std::mem::transmute(lpa_rsvd) };
            lpa_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_7 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_7>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_7)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_7 {
    #[inline]
    pub fn spec_format(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_spec_format(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avscc_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_avscc_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        spec_format: u8,
        avscc_rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let spec_format: u8 = unsafe { ::std::mem::transmute(spec_format) };
            spec_format as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let avscc_rsvd: u8 = unsafe { ::std::mem::transmute(avscc_rsvd) };
            avscc_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_8 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_8>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_8>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_8)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_8 {
    #[inline]
    pub fn supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apsta_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_apsta_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supported: u8,
        apsta_rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supported: u8 = unsafe { ::std::mem::transmute(supported) };
            supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let apsta_rsvd: u8 = unsafe { ::std::mem::transmute(apsta_rsvd) };
            apsta_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_9 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub reserved2: u8,
    pub total_size: u8,
    pub access_size: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_9>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_9>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_9)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_9 {
    #[inline]
    pub fn num_rpmb_units(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_num_rpmb_units(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn auth_method(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_auth_method(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        num_rpmb_units: u8,
        auth_method: u8,
        reserved1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let num_rpmb_units: u8 = unsafe { ::std::mem::transmute(num_rpmb_units) };
            num_rpmb_units as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let auth_method: u8 = unsafe { ::std::mem::transmute(auth_method) };
            auth_method as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_10 {
    pub raw: u8,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn one_only(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_one_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(one_only: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let one_only: u8 = unsafe { ::std::mem::transmute(one_only) };
            one_only as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_10>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_10>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10)
        )
    );
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_10 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_11 {
    pub raw: u16,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn supported(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supported: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supported: u16 = unsafe { ::std::mem::transmute(supported) };
            supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_11>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_11>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11)
        )
    );
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_11 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_12 {
    pub raw: u32,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn crypto_erase(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_erase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn block_erase(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block_erase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overwrite(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overwrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        crypto_erase: u32,
        block_erase: u32,
        overwrite: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let crypto_erase: u32 = unsafe { ::std::mem::transmute(crypto_erase) };
            crypto_erase as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let block_erase: u32 = unsafe { ::std::mem::transmute(block_erase) };
            block_erase as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let overwrite: u32 = unsafe { ::std::mem::transmute(overwrite) };
            overwrite as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_12>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12)
        )
    );
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_12 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_13 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_13>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_13>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_13)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_13 {
    #[inline]
    pub fn min(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_min(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn max(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(min: u8, max: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let min: u8 = unsafe { ::std::mem::transmute(min) };
            min as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let max: u8 = unsafe { ::std::mem::transmute(max) };
            max as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_14 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_14>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_14>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_14)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_14 {
    #[inline]
    pub fn min(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_min(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn max(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(min: u8, max: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let min: u8 = unsafe { ::std::mem::transmute(min) };
            min as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let max: u8 = unsafe { ::std::mem::transmute(max) };
            max as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_15 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_15>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_15))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_15>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_15)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_15 {
    #[inline]
    pub fn compare(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_compare(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_unc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_write_unc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsm(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dsm(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_zeroes(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_write_zeroes(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_features_save(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_set_features_save(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservations(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reservations(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compare: u16,
        write_unc: u16,
        dsm: u16,
        write_zeroes: u16,
        set_features_save: u16,
        reservations: u16,
        timestamp: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compare: u16 = unsafe { ::std::mem::transmute(compare) };
            compare as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let write_unc: u16 = unsafe { ::std::mem::transmute(write_unc) };
            write_unc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dsm: u16 = unsafe { ::std::mem::transmute(dsm) };
            dsm as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write_zeroes: u16 = unsafe { ::std::mem::transmute(write_zeroes) };
            write_zeroes as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let set_features_save: u16 = unsafe { ::std::mem::transmute(set_features_save) };
            set_features_save as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let reservations: u16 = unsafe { ::std::mem::transmute(reservations) };
            reservations as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let timestamp: u16 = unsafe { ::std::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_16 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_16() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_16>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_16))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_16>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_16)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_16 {
    #[inline]
    pub fn format_all_ns(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_format_all_ns(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn erase_all_ns(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_erase_all_ns(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn crypto_erase_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_crypto_erase_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        format_all_ns: u8,
        erase_all_ns: u8,
        crypto_erase_supported: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let format_all_ns: u8 = unsafe { ::std::mem::transmute(format_all_ns) };
            format_all_ns as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let erase_all_ns: u8 = unsafe { ::std::mem::transmute(erase_all_ns) };
            erase_all_ns as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let crypto_erase_supported: u8 =
                unsafe { ::std::mem::transmute(crypto_erase_supported) };
            crypto_erase_supported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_17 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_17() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_17>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_17))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_17>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_17)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_17 {
    #[inline]
    pub fn present(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_present(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush_broadcast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_flush_broadcast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        present: u8,
        flush_broadcast: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let present: u8 = unsafe { ::std::mem::transmute(present) };
            present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let flush_broadcast: u8 = unsafe { ::std::mem::transmute(flush_broadcast) };
            flush_broadcast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_18 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_18() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_18>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_18))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_18>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_18)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_18 {
    #[inline]
    pub fn supported(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn keyed_sgl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keyed_sgl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_bucket_descriptor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bit_bucket_descriptor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn metadata_pointer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_pointer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oversized_sgl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oversized_sgl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn metadata_address(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_address(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgl_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgl_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transport_sgl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transport_sgl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supported: u32,
        keyed_sgl: u32,
        reserved1: u32,
        bit_bucket_descriptor: u32,
        metadata_pointer: u32,
        oversized_sgl: u32,
        metadata_address: u32,
        sgl_offset: u32,
        transport_sgl: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let supported: u32 = unsafe { ::std::mem::transmute(supported) };
            supported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let keyed_sgl: u32 = unsafe { ::std::mem::transmute(keyed_sgl) };
            keyed_sgl as u64
        });
        __bindgen_bitfield_unit.set(3usize, 13u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let bit_bucket_descriptor: u32 =
                unsafe { ::std::mem::transmute(bit_bucket_descriptor) };
            bit_bucket_descriptor as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let metadata_pointer: u32 = unsafe { ::std::mem::transmute(metadata_pointer) };
            metadata_pointer as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let oversized_sgl: u32 = unsafe { ::std::mem::transmute(oversized_sgl) };
            oversized_sgl as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let metadata_address: u32 = unsafe { ::std::mem::transmute(metadata_address) };
            metadata_address as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let sgl_offset: u32 = unsafe { ::std::mem::transmute(sgl_offset) };
            sgl_offset as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let transport_sgl: u32 = unsafe { ::std::mem::transmute(transport_sgl) };
            transport_sgl as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_19 {
    pub ioccsz: u32,
    pub iorcsz: u32,
    pub icdoff: u16,
    pub ctrattr: spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1,
    pub msdbd: u8,
    pub reserved: [u8; 244usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn ctrlr_model(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ctrlr_model(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ctrlr_model: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ctrlr_model: u8 = unsafe { ::std::mem::transmute(ctrlr_model) };
            ctrlr_model as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_19>(),
        256usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_19))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_19>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_19)
        )
    );
}
impl Default for spdk_nvme_ctrlr_data__bindgen_ty_19 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ctrlr_data))
    );
}
impl Default for spdk_nvme_ctrlr_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_primary_ctrl_capabilities {
    pub cntlid: u16,
    pub portid: u16,
    pub crt: spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1,
    pub reserved: [u8; 27usize],
    pub vqfrt: u32,
    pub vqrfa: u32,
    pub vqrfap: u16,
    pub vqprt: u16,
    pub vqfrsm: u16,
    pub vqgran: u16,
    pub reserved1: [u8; 16usize],
    pub vifrt: u32,
    pub virfa: u32,
    pub virfap: u16,
    pub viprt: u16,
    pub vifrsm: u16,
    pub vigran: u16,
    pub reserved2: [u8; 4016usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 {
    #[inline]
    pub fn vq_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vq_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vi_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vi_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vq_supported: u8,
        vi_supported: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vq_supported: u8 = unsafe { ::std::mem::transmute(vq_supported) };
            vq_supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let vi_supported: u8 = unsafe { ::std::mem::transmute(vi_supported) };
            vi_supported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_primary_ctrl_capabilities() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_primary_ctrl_capabilities>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_primary_ctrl_capabilities))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_primary_ctrl_capabilities>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_primary_ctrl_capabilities)
        )
    );
}
impl Default for spdk_nvme_primary_ctrl_capabilities {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_secondary_ctrl_entry {
    pub scid: u16,
    pub pcid: u16,
    pub scs: spdk_nvme_secondary_ctrl_entry__bindgen_ty_1,
    pub reserved: [u8; 3usize],
    pub vfn: u16,
    pub nvq: u16,
    pub nvi: u16,
    pub reserved1: [u8; 18usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_secondary_ctrl_entry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_secondary_ctrl_entry__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_secondary_ctrl_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_secondary_ctrl_entry__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_secondary_ctrl_entry__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 {
    #[inline]
    pub fn is_online(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_online(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_online: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_online: u8 = unsafe { ::std::mem::transmute(is_online) };
            is_online as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_secondary_ctrl_entry() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_secondary_ctrl_entry>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvme_secondary_ctrl_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_secondary_ctrl_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_secondary_ctrl_entry))
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_secondary_ctrl_list {
    pub number: u8,
    pub reserved: [u8; 31usize],
    pub entries: [spdk_nvme_secondary_ctrl_entry; 127usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_secondary_ctrl_list() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_secondary_ctrl_list>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_secondary_ctrl_list))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_secondary_ctrl_list>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_secondary_ctrl_list))
    );
}
impl Default for spdk_nvme_secondary_ctrl_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_ns_data {
    pub nsze: u64,
    pub ncap: u64,
    pub nuse: u64,
    pub nsfeat: spdk_nvme_ns_data__bindgen_ty_1,
    pub nlbaf: u8,
    pub flbas: spdk_nvme_ns_data__bindgen_ty_2,
    pub mc: spdk_nvme_ns_data__bindgen_ty_3,
    pub dpc: spdk_nvme_ns_data__bindgen_ty_4,
    pub dps: spdk_nvme_ns_data__bindgen_ty_5,
    pub nmic: spdk_nvme_ns_data__bindgen_ty_6,
    pub nsrescap: spdk_nvme_ns_data__bindgen_ty_7,
    pub fpi: spdk_nvme_ns_data__bindgen_ty_8,
    pub dlfeat: spdk_nvme_ns_data__bindgen_ty_9,
    pub nawun: u16,
    pub nawupf: u16,
    pub nacwu: u16,
    pub nabsn: u16,
    pub nabo: u16,
    pub nabspf: u16,
    pub noiob: u16,
    pub nvmcap: [u64; 2usize],
    pub reserved64: [u8; 40usize],
    pub nguid: [u8; 16usize],
    pub eui64: u64,
    pub lbaf: [spdk_nvme_ns_data__bindgen_ty_10; 16usize],
    pub reserved6: [u8; 192usize],
    pub vendor_specific: [u8; 3712usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_1))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_1 {
    #[inline]
    pub fn thin_prov(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_thin_prov(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ns_atomic_write_unit(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ns_atomic_write_unit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dealloc_or_unwritten_error(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dealloc_or_unwritten_error(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn guid_never_reused(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_guid_never_reused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        thin_prov: u8,
        ns_atomic_write_unit: u8,
        dealloc_or_unwritten_error: u8,
        guid_never_reused: u8,
        reserved1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let thin_prov: u8 = unsafe { ::std::mem::transmute(thin_prov) };
            thin_prov as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ns_atomic_write_unit: u8 = unsafe { ::std::mem::transmute(ns_atomic_write_unit) };
            ns_atomic_write_unit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dealloc_or_unwritten_error: u8 =
                unsafe { ::std::mem::transmute(dealloc_or_unwritten_error) };
            dealloc_or_unwritten_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let guid_never_reused: u8 = unsafe { ::std::mem::transmute(guid_never_reused) };
            guid_never_reused as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_2))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_2 {
    #[inline]
    pub fn format(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_format(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn extended(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        format: u8,
        extended: u8,
        reserved2: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let format: u8 = unsafe { ::std::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let extended: u8 = unsafe { ::std::mem::transmute(extended) };
            extended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved2: u8 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_3>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_3>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_3))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_3 {
    #[inline]
    pub fn extended(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pointer(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pointer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        extended: u8,
        pointer: u8,
        reserved3: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let extended: u8 = unsafe { ::std::mem::transmute(extended) };
            extended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pointer: u8 = unsafe { ::std::mem::transmute(pointer) };
            pointer as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved3: u8 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_4>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_4>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_4))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_4 {
    #[inline]
    pub fn pit1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pit1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pit2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pit2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pit3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pit3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn md_start(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_md_start(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn md_end(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_md_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pit1: u8,
        pit2: u8,
        pit3: u8,
        md_start: u8,
        md_end: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pit1: u8 = unsafe { ::std::mem::transmute(pit1) };
            pit1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pit2: u8 = unsafe { ::std::mem::transmute(pit2) };
            pit2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pit3: u8 = unsafe { ::std::mem::transmute(pit3) };
            pit3 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let md_start: u8 = unsafe { ::std::mem::transmute(md_start) };
            md_start as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let md_end: u8 = unsafe { ::std::mem::transmute(md_end) };
            md_end as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_5 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_5>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_5>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_5))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_5 {
    #[inline]
    pub fn pit(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn md_start(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_md_start(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pit: u8,
        md_start: u8,
        reserved4: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pit: u8 = unsafe { ::std::mem::transmute(pit) };
            pit as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let md_start: u8 = unsafe { ::std::mem::transmute(md_start) };
            md_start as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved4: u8 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_6 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_6>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_6>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_6))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_6 {
    #[inline]
    pub fn can_share(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_share(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(can_share: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_share: u8 = unsafe { ::std::mem::transmute(can_share) };
            can_share as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ns_data__bindgen_ty_7 {
    pub rescap: spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1,
    pub raw: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn persist(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_persist(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_exclusive(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_exclusive(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive_access(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exclusive_access(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_exclusive_reg_only(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_exclusive_reg_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive_access_reg_only(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exclusive_access_reg_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_exclusive_all_reg(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_exclusive_all_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive_access_all_reg(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exclusive_access_all_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_existing_key(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_existing_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        persist: u8,
        write_exclusive: u8,
        exclusive_access: u8,
        write_exclusive_reg_only: u8,
        exclusive_access_reg_only: u8,
        write_exclusive_all_reg: u8,
        exclusive_access_all_reg: u8,
        ignore_existing_key: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let persist: u8 = unsafe { ::std::mem::transmute(persist) };
            persist as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let write_exclusive: u8 = unsafe { ::std::mem::transmute(write_exclusive) };
            write_exclusive as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let exclusive_access: u8 = unsafe { ::std::mem::transmute(exclusive_access) };
            exclusive_access as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write_exclusive_reg_only: u8 =
                unsafe { ::std::mem::transmute(write_exclusive_reg_only) };
            write_exclusive_reg_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exclusive_access_reg_only: u8 =
                unsafe { ::std::mem::transmute(exclusive_access_reg_only) };
            exclusive_access_reg_only as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let write_exclusive_all_reg: u8 =
                unsafe { ::std::mem::transmute(write_exclusive_all_reg) };
            write_exclusive_all_reg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let exclusive_access_all_reg: u8 =
                unsafe { ::std::mem::transmute(exclusive_access_all_reg) };
            exclusive_access_all_reg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ignore_existing_key: u8 = unsafe { ::std::mem::transmute(ignore_existing_key) };
            ignore_existing_key as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_7>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_7>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_7))
    );
}
impl Default for spdk_nvme_ns_data__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_8 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_8>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_8>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_8))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_8 {
    #[inline]
    pub fn percentage_remaining(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_percentage_remaining(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn fpi_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fpi_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        percentage_remaining: u8,
        fpi_supported: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let percentage_remaining: u8 = unsafe { ::std::mem::transmute(percentage_remaining) };
            percentage_remaining as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fpi_supported: u8 = unsafe { ::std::mem::transmute(fpi_supported) };
            fpi_supported as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ns_data__bindgen_ty_9 {
    pub raw: u8,
    pub bits: spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn read_value(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_read_value(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn write_zero_deallocate(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_zero_deallocate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn guard_value(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_guard_value(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_value: u8,
        write_zero_deallocate: u8,
        guard_value: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let read_value: u8 = unsafe { ::std::mem::transmute(read_value) };
            read_value as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write_zero_deallocate: u8 = unsafe { ::std::mem::transmute(write_zero_deallocate) };
            write_zero_deallocate as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let guard_value: u8 = unsafe { ::std::mem::transmute(guard_value) };
            guard_value as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_9>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_9>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_9))
    );
}
impl Default for spdk_nvme_ns_data__bindgen_ty_9 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_10 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_10>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_10>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_10)
        )
    );
}
impl spdk_nvme_ns_data__bindgen_ty_10 {
    #[inline]
    pub fn ms(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ms(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn lbads(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lbads(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ms: u32,
        lbads: u32,
        rp: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ms: u32 = unsafe { ::std::mem::transmute(ms) };
            ms as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let lbads: u32 = unsafe { ::std::mem::transmute(lbads) };
            lbads as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let rp: u32 = unsafe { ::std::mem::transmute(rp) };
            rp as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved6: u32 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data))
    );
}
impl Default for spdk_nvme_ns_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_NOT_REPORTED:
    spdk_nvme_dealloc_logical_block_read_value = 0;
pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_00:
    spdk_nvme_dealloc_logical_block_read_value = 1;
pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_FF:
    spdk_nvme_dealloc_logical_block_read_value = 2;
pub type spdk_nvme_dealloc_logical_block_read_value = u32;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE: spdk_nvme_reservation_type =
    1;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS:
    spdk_nvme_reservation_type = 2;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY:
    spdk_nvme_reservation_type = 3;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY:
    spdk_nvme_reservation_type = 4;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS:
    spdk_nvme_reservation_type = 5;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS:
    spdk_nvme_reservation_type = 6;
pub type spdk_nvme_reservation_type = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_reservation_acquire_data {
    pub crkey: u64,
    pub prkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_acquire_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_acquire_data>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_acquire_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_acquire_data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_acquire_data)
        )
    );
}
pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_ACQUIRE:
    spdk_nvme_reservation_acquire_action = 0;
pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT:
    spdk_nvme_reservation_acquire_action = 1;
pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT_ABORT:
    spdk_nvme_reservation_acquire_action = 2;
pub type spdk_nvme_reservation_acquire_action = u32;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_reservation_status_data {
    pub generation: u32,
    pub type_: u8,
    pub nr_regctl: u16,
    pub reserved1: u16,
    pub ptpl_state: u8,
    pub reserved: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_status_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_status_data>(),
        24usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_status_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_status_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_status_data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_reservation_ctrlr_data {
    pub ctrlr_id: u16,
    pub rcsts: spdk_nvme_reservation_ctrlr_data__bindgen_ty_1,
    pub reserved2: [u8; 5usize],
    pub host_id: u64,
    pub key: u64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_ctrlr_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_reservation_ctrlr_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_ctrlr_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_ctrlr_data__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(status: u8, reserved1: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let status: u8 = unsafe { ::std::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_ctrlr_data>(),
        24usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_ctrlr_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_ctrlr_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_ctrlr_data)
        )
    );
}
pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_NO_CHANGES:
    spdk_nvme_reservation_register_cptpl = 0;
pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON:
    spdk_nvme_reservation_register_cptpl = 2;
pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS:
    spdk_nvme_reservation_register_cptpl = 3;
pub type spdk_nvme_reservation_register_cptpl = u32;
pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REGISTER_KEY:
    spdk_nvme_reservation_register_action = 0;
pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_UNREGISTER_KEY:
    spdk_nvme_reservation_register_action = 1;
pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REPLACE_KEY:
    spdk_nvme_reservation_register_action = 2;
pub type spdk_nvme_reservation_register_action = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_reservation_register_data {
    pub crkey: u64,
    pub nrkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_register_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_register_data>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_register_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_register_data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_register_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_reservation_key_data {
    pub crkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_key_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_key_data>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_key_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_key_data>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_reservation_key_data))
    );
}
pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_RELEASE:
    spdk_nvme_reservation_release_action = 0;
pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_CLEAR:
    spdk_nvme_reservation_release_action = 1;
pub type spdk_nvme_reservation_release_action = u32;
pub const spdk_nvme_log_page_SPDK_NVME_LOG_ERROR: spdk_nvme_log_page = 1;
pub const spdk_nvme_log_page_SPDK_NVME_LOG_HEALTH_INFORMATION: spdk_nvme_log_page = 2;
pub const spdk_nvme_log_page_SPDK_NVME_LOG_FIRMWARE_SLOT: spdk_nvme_log_page = 3;
pub const spdk_nvme_log_page_SPDK_NVME_LOG_CHANGED_NS_LIST: spdk_nvme_log_page = 4;
pub const spdk_nvme_log_page_SPDK_NVME_LOG_COMMAND_EFFECTS_LOG: spdk_nvme_log_page = 5;
pub const spdk_nvme_log_page_SPDK_NVME_LOG_DISCOVERY: spdk_nvme_log_page = 112;
pub const spdk_nvme_log_page_SPDK_NVME_LOG_RESERVATION_NOTIFICATION: spdk_nvme_log_page = 128;
pub type spdk_nvme_log_page = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_error_information_entry {
    pub error_count: u64,
    pub sqid: u16,
    pub cid: u16,
    pub status: spdk_nvme_status,
    pub error_location: u16,
    pub lba: u64,
    pub nsid: u32,
    pub vendor_specific: u8,
    pub trtype: u8,
    pub reserved30: [u8; 2usize],
    pub command_specific: u64,
    pub trtype_specific: u16,
    pub reserved42: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_error_information_entry() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_error_information_entry>(),
        64usize,
        concat!("Size of: ", stringify!(spdk_nvme_error_information_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_error_information_entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_error_information_entry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_critical_warning_state {
    pub raw: u8,
    pub bits: spdk_nvme_critical_warning_state__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_critical_warning_state__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_critical_warning_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_critical_warning_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_critical_warning_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_critical_warning_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_critical_warning_state__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_critical_warning_state__bindgen_ty_1 {
    #[inline]
    pub fn available_spare(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_available_spare(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temperature(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_temperature(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn device_reliability(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_device_reliability(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_only(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn volatile_memory_backup(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_volatile_memory_backup(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        available_spare: u8,
        temperature: u8,
        device_reliability: u8,
        read_only: u8,
        volatile_memory_backup: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let available_spare: u8 = unsafe { ::std::mem::transmute(available_spare) };
            available_spare as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let temperature: u8 = unsafe { ::std::mem::transmute(temperature) };
            temperature as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let device_reliability: u8 = unsafe { ::std::mem::transmute(device_reliability) };
            device_reliability as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let read_only: u8 = unsafe { ::std::mem::transmute(read_only) };
            read_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let volatile_memory_backup: u8 =
                unsafe { ::std::mem::transmute(volatile_memory_backup) };
            volatile_memory_backup as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_critical_warning_state() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_critical_warning_state>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_critical_warning_state))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_critical_warning_state>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_critical_warning_state)
        )
    );
}
impl Default for spdk_nvme_critical_warning_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_health_information_page {
    pub critical_warning: spdk_nvme_critical_warning_state,
    pub temperature: u16,
    pub available_spare: u8,
    pub available_spare_threshold: u8,
    pub percentage_used: u8,
    pub reserved: [u8; 26usize],
    pub data_units_read: [u64; 2usize],
    pub data_units_written: [u64; 2usize],
    pub host_read_commands: [u64; 2usize],
    pub host_write_commands: [u64; 2usize],
    pub controller_busy_time: [u64; 2usize],
    pub power_cycles: [u64; 2usize],
    pub power_on_hours: [u64; 2usize],
    pub unsafe_shutdowns: [u64; 2usize],
    pub media_errors: [u64; 2usize],
    pub num_error_info_log_entries: [u64; 2usize],
    pub warning_temp_time: u32,
    pub critical_temp_time: u32,
    pub temp_sensor: [u16; 8usize],
    pub reserved2: [u8; 296usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_health_information_page() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_health_information_page>(),
        512usize,
        concat!("Size of: ", stringify!(spdk_nvme_health_information_page))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_health_information_page>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_health_information_page)
        )
    );
}
impl Default for spdk_nvme_health_information_page {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_cmds_and_effect_entry {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmds_and_effect_entry() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmds_and_effect_entry>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmds_and_effect_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmds_and_effect_entry>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmds_and_effect_entry))
    );
}
impl spdk_nvme_cmds_and_effect_entry {
    #[inline]
    pub fn csupp(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_csupp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lbcc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_lbcc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ncc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ncc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nic(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_nic(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ccc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ccc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn cse(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_cse(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        csupp: u16,
        lbcc: u16,
        ncc: u16,
        nic: u16,
        ccc: u16,
        reserved1: u16,
        cse: u16,
        reserved2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let csupp: u16 = unsafe { ::std::mem::transmute(csupp) };
            csupp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lbcc: u16 = unsafe { ::std::mem::transmute(lbcc) };
            lbcc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ncc: u16 = unsafe { ::std::mem::transmute(ncc) };
            ncc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nic: u16 = unsafe { ::std::mem::transmute(nic) };
            nic as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ccc: u16 = unsafe { ::std::mem::transmute(ccc) };
            ccc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let reserved1: u16 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let cse: u16 = unsafe { ::std::mem::transmute(cse) };
            cse as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved2: u16 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_cmds_and_effect_log_page {
    pub admin_cmds_supported: [spdk_nvme_cmds_and_effect_entry; 256usize],
    pub io_cmds_supported: [spdk_nvme_cmds_and_effect_entry; 256usize],
    pub reserved0: [u8; 2048usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmds_and_effect_log_page() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmds_and_effect_log_page>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmds_and_effect_log_page))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmds_and_effect_log_page>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmds_and_effect_log_page)
        )
    );
}
impl Default for spdk_nvme_cmds_and_effect_log_page {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_ERROR: spdk_nvme_async_event_type =
    0;
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_SMART: spdk_nvme_async_event_type =
    1;
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE: spdk_nvme_async_event_type =
    2;
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_IO: spdk_nvme_async_event_type = 6;
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_VENDOR: spdk_nvme_async_event_type =
    7;
pub type spdk_nvme_async_event_type = u32;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_WRITE_INVALID_DB:
    spdk_nvme_async_event_info_error = 0;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_INVALID_DB_WRITE:
    spdk_nvme_async_event_info_error = 1;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_DIAGNOSTIC_FAILURE:
    spdk_nvme_async_event_info_error = 2;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_PERSISTENT_INTERNAL:
    spdk_nvme_async_event_info_error = 3;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_TRANSIENT_INTERNAL:
    spdk_nvme_async_event_info_error = 4;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_FW_IMAGE_LOAD:
    spdk_nvme_async_event_info_error = 5;
pub type spdk_nvme_async_event_info_error = u32;
pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SUBSYSTEM_RELIABILITY:
    spdk_nvme_async_event_info_smart = 0;
pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_TEMPERATURE_THRESHOLD:
    spdk_nvme_async_event_info_smart = 1;
pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SPARE_BELOW_THRESHOLD:
    spdk_nvme_async_event_info_smart = 2;
pub type spdk_nvme_async_event_info_smart = u32;
pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED:
    spdk_nvme_async_event_info_notice = 0;
pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_FW_ACTIVATION_START:
    spdk_nvme_async_event_info_notice = 1;
pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_TELEMETRY_LOG_CHANGED:
    spdk_nvme_async_event_info_notice = 2;
pub type spdk_nvme_async_event_info_notice = u32;
pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_RESERVATION_LOG_AVAIL:
    spdk_nvme_async_event_info_nvm_command_set = 0;
pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_SANITIZE_COMPLETED:
    spdk_nvme_async_event_info_nvm_command_set = 1;
pub type spdk_nvme_async_event_info_nvm_command_set = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_async_event_completion {
    pub raw: u32,
    pub bits: spdk_nvme_async_event_completion__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_async_event_completion__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_async_event_completion__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_async_event_completion__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_async_event_completion__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_async_event_completion__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_async_event_completion__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_async_event_completion__bindgen_ty_1 {
    #[inline]
    pub fn async_event_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_async_event_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn async_event_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_async_event_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn log_page_identifier(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log_page_identifier(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        async_event_type: u32,
        reserved1: u32,
        async_event_info: u32,
        log_page_identifier: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let async_event_type: u32 = unsafe { ::std::mem::transmute(async_event_type) };
            async_event_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let async_event_info: u32 = unsafe { ::std::mem::transmute(async_event_info) };
            async_event_info as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let log_page_identifier: u32 = unsafe { ::std::mem::transmute(log_page_identifier) };
            log_page_identifier as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_async_event_completion() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_async_event_completion>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_async_event_completion))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_async_event_completion>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_async_event_completion)
        )
    );
}
impl Default for spdk_nvme_async_event_completion {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_arbitration {
    pub raw: u32,
    pub bits: spdk_nvme_feat_arbitration__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_arbitration__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_arbitration__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_arbitration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_arbitration__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_arbitration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_arbitration__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_arbitration__bindgen_ty_1 {
    #[inline]
    pub fn ab(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ab(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn lpw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lpw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mpw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mpw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn hpw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_hpw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ab: u32,
        reserved: u32,
        lpw: u32,
        mpw: u32,
        hpw: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ab: u32 = unsafe { ::std::mem::transmute(ab) };
            ab as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let lpw: u32 = unsafe { ::std::mem::transmute(lpw) };
            lpw as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let mpw: u32 = unsafe { ::std::mem::transmute(mpw) };
            mpw as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let hpw: u32 = unsafe { ::std::mem::transmute(hpw) };
            hpw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_arbitration() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_arbitration>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_arbitration))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_arbitration>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_arbitration))
    );
}
impl Default for spdk_nvme_feat_arbitration {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_power_management {
    pub raw: u32,
    pub bits: spdk_nvme_feat_power_management__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_power_management__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_power_management__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_power_management__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_power_management__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_power_management__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_power_management__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_power_management__bindgen_ty_1 {
    #[inline]
    pub fn ps(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_ps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn wh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_wh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ps: u32,
        wh: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ps: u32 = unsafe { ::std::mem::transmute(ps) };
            ps as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let wh: u32 = unsafe { ::std::mem::transmute(wh) };
            wh as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_power_management() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_power_management>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_power_management))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_power_management>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_power_management))
    );
}
impl Default for spdk_nvme_feat_power_management {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_lba_range_type {
    pub raw: u32,
    pub bits: spdk_nvme_feat_lba_range_type__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_lba_range_type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_lba_range_type__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_lba_range_type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_lba_range_type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_lba_range_type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_lba_range_type__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_lba_range_type__bindgen_ty_1 {
    #[inline]
    pub fn num(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(num: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let num: u32 = unsafe { ::std::mem::transmute(num) };
            num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_lba_range_type() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_lba_range_type>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_lba_range_type))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_lba_range_type>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_lba_range_type))
    );
}
impl Default for spdk_nvme_feat_lba_range_type {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_temperature_threshold {
    pub raw: u32,
    pub bits: spdk_nvme_feat_temperature_threshold__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_temperature_threshold__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_temperature_threshold__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_temperature_threshold__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_temperature_threshold__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_temperature_threshold__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_temperature_threshold__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_temperature_threshold__bindgen_ty_1 {
    #[inline]
    pub fn tmpth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tmpth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn tmpsel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tmpsel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn thsel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_thsel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tmpth: u32,
        tmpsel: u32,
        thsel: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let tmpth: u32 = unsafe { ::std::mem::transmute(tmpth) };
            tmpth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let tmpsel: u32 = unsafe { ::std::mem::transmute(tmpsel) };
            tmpsel as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let thsel: u32 = unsafe { ::std::mem::transmute(thsel) };
            thsel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_temperature_threshold() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_temperature_threshold>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_temperature_threshold)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_temperature_threshold>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_temperature_threshold)
        )
    );
}
impl Default for spdk_nvme_feat_temperature_threshold {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_error_recovery {
    pub raw: u32,
    pub bits: spdk_nvme_feat_error_recovery__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_error_recovery__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_error_recovery__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_error_recovery__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_error_recovery__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_error_recovery__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_error_recovery__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_error_recovery__bindgen_ty_1 {
    #[inline]
    pub fn tler(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tler(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn dulbe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dulbe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tler: u32,
        dulbe: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let tler: u32 = unsafe { ::std::mem::transmute(tler) };
            tler as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let dulbe: u32 = unsafe { ::std::mem::transmute(dulbe) };
            dulbe as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_error_recovery() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_error_recovery>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_error_recovery))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_error_recovery>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_error_recovery))
    );
}
impl Default for spdk_nvme_feat_error_recovery {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_volatile_write_cache {
    pub raw: u32,
    pub bits: spdk_nvme_feat_volatile_write_cache__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_volatile_write_cache__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_volatile_write_cache__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_volatile_write_cache__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_volatile_write_cache__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_volatile_write_cache__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 {
    #[inline]
    pub fn wce(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wce(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(wce: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wce: u32 = unsafe { ::std::mem::transmute(wce) };
            wce as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_volatile_write_cache() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_volatile_write_cache>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_volatile_write_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_volatile_write_cache>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_volatile_write_cache)
        )
    );
}
impl Default for spdk_nvme_feat_volatile_write_cache {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_number_of_queues {
    pub raw: u32,
    pub bits: spdk_nvme_feat_number_of_queues__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_number_of_queues__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_number_of_queues__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_number_of_queues__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_number_of_queues__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_number_of_queues__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_number_of_queues__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_number_of_queues__bindgen_ty_1 {
    #[inline]
    pub fn nsqr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_nsqr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ncqr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ncqr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(nsqr: u32, ncqr: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let nsqr: u32 = unsafe { ::std::mem::transmute(nsqr) };
            nsqr as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let ncqr: u32 = unsafe { ::std::mem::transmute(ncqr) };
            ncqr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_number_of_queues() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_number_of_queues>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_number_of_queues))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_number_of_queues>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_number_of_queues))
    );
}
impl Default for spdk_nvme_feat_number_of_queues {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_interrupt_vector_configuration {
    pub raw: u32,
    pub bits: spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 {
    #[inline]
    pub fn iv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_iv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        iv: u32,
        cd: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let iv: u32 = unsafe { ::std::mem::transmute(iv) };
            iv as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let cd: u32 = unsafe { ::std::mem::transmute(cd) };
            cd as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_interrupt_vector_configuration() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_interrupt_vector_configuration>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_interrupt_vector_configuration)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_interrupt_vector_configuration>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_interrupt_vector_configuration)
        )
    );
}
impl Default for spdk_nvme_feat_interrupt_vector_configuration {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_write_atomicity {
    pub raw: u32,
    pub bits: spdk_nvme_feat_write_atomicity__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_write_atomicity__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_write_atomicity__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_write_atomicity__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_write_atomicity__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_write_atomicity__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_write_atomicity__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_write_atomicity__bindgen_ty_1 {
    #[inline]
    pub fn dn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dn: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dn: u32 = unsafe { ::std::mem::transmute(dn) };
            dn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_write_atomicity() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_write_atomicity>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_write_atomicity))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_write_atomicity>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_write_atomicity))
    );
}
impl Default for spdk_nvme_feat_write_atomicity {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_async_event_configuration {
    pub raw: u32,
    pub bits: spdk_nvme_feat_async_event_configuration__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_feat_async_event_configuration__bindgen_ty_1 {
    pub crit_warn: spdk_nvme_critical_warning_state,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_async_event_configuration__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_async_event_configuration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_async_event_configuration__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_async_event_configuration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_async_event_configuration__bindgen_ty_1)
        )
    );
}
impl Default for spdk_nvme_feat_async_event_configuration__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl spdk_nvme_feat_async_event_configuration__bindgen_ty_1 {
    #[inline]
    pub fn ns_attr_notice(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ns_attr_notice(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fw_activation_notice(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fw_activation_notice(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn telemetry_log_notice(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_telemetry_log_notice(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ns_attr_notice: u32,
        fw_activation_notice: u32,
        telemetry_log_notice: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ns_attr_notice: u32 = unsafe { ::std::mem::transmute(ns_attr_notice) };
            ns_attr_notice as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fw_activation_notice: u32 = unsafe { ::std::mem::transmute(fw_activation_notice) };
            fw_activation_notice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let telemetry_log_notice: u32 = unsafe { ::std::mem::transmute(telemetry_log_notice) };
            telemetry_log_notice as u64
        });
        __bindgen_bitfield_unit.set(3usize, 21u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_async_event_configuration() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_async_event_configuration>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_async_event_configuration)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_async_event_configuration>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_async_event_configuration)
        )
    );
}
impl Default for spdk_nvme_feat_async_event_configuration {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_autonomous_power_state_transition {
    pub raw: u32,
    pub bits: spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 {
    #[inline]
    pub fn apste(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apste(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(apste: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let apste: u32 = unsafe { ::std::mem::transmute(apste) };
            apste as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_autonomous_power_state_transition() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_autonomous_power_state_transition>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_autonomous_power_state_transition)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_autonomous_power_state_transition>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_autonomous_power_state_transition)
        )
    );
}
impl Default for spdk_nvme_feat_autonomous_power_state_transition {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_host_mem_buffer {
    pub raw: u32,
    pub bits: spdk_nvme_feat_host_mem_buffer__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_mem_buffer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_mem_buffer__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_host_mem_buffer__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_mem_buffer__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_host_mem_buffer__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 {
    #[inline]
    pub fn ehm(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ehm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ehm: u32,
        mr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ehm: u32 = unsafe { ::std::mem::transmute(ehm) };
            ehm as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mr: u32 = unsafe { ::std::mem::transmute(mr) };
            mr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_mem_buffer() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_mem_buffer>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_host_mem_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_mem_buffer>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_host_mem_buffer))
    );
}
impl Default for spdk_nvme_feat_host_mem_buffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_keep_alive_timer {
    pub raw: u32,
    pub bits: spdk_nvme_feat_keep_alive_timer__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_keep_alive_timer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_keep_alive_timer__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_keep_alive_timer__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_keep_alive_timer__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_keep_alive_timer__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 {
    #[inline]
    pub fn kato(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_kato(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kato: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let kato: u32 = unsafe { ::std::mem::transmute(kato) };
            kato as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_keep_alive_timer() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_keep_alive_timer>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_keep_alive_timer))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_keep_alive_timer>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_keep_alive_timer))
    );
}
impl Default for spdk_nvme_feat_keep_alive_timer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_host_controlled_thermal_management {
    pub raw: u32,
    pub bits: spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 {
    #[inline]
    pub fn tmt2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tmt2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn tmt1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tmt1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(tmt2: u32, tmt1: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let tmt2: u32 = unsafe { ::std::mem::transmute(tmt2) };
            tmt2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let tmt1: u32 = unsafe { ::std::mem::transmute(tmt1) };
            tmt1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_controlled_thermal_management() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_controlled_thermal_management>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_host_controlled_thermal_management)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_controlled_thermal_management>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_host_controlled_thermal_management)
        )
    );
}
impl Default for spdk_nvme_feat_host_controlled_thermal_management {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_non_operational_power_state_config {
    pub raw: u32,
    pub bits: spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 {
    #[inline]
    pub fn noppme(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noppme(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(noppme: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let noppme: u32 = unsafe { ::std::mem::transmute(noppme) };
            noppme as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_non_operational_power_state_config() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_non_operational_power_state_config>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_non_operational_power_state_config)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_non_operational_power_state_config>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_non_operational_power_state_config)
        )
    );
}
impl Default for spdk_nvme_feat_non_operational_power_state_config {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_software_progress_marker {
    pub raw: u32,
    pub bits: spdk_nvme_feat_software_progress_marker__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_software_progress_marker__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_software_progress_marker__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_software_progress_marker__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_software_progress_marker__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_software_progress_marker__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_software_progress_marker__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_software_progress_marker__bindgen_ty_1 {
    #[inline]
    pub fn pbslc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pbslc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(pbslc: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let pbslc: u32 = unsafe { ::std::mem::transmute(pbslc) };
            pbslc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_software_progress_marker() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_software_progress_marker>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_software_progress_marker)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_software_progress_marker>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_software_progress_marker)
        )
    );
}
impl Default for spdk_nvme_feat_software_progress_marker {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_host_identifier {
    pub raw: u32,
    pub bits: spdk_nvme_feat_host_identifier__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_feat_host_identifier__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_identifier__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_identifier__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_host_identifier__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_identifier__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_host_identifier__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_host_identifier__bindgen_ty_1 {
    #[inline]
    pub fn exhid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exhid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(exhid: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let exhid: u32 = unsafe { ::std::mem::transmute(exhid) };
            exhid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_identifier() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_identifier>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_host_identifier))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_identifier>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_host_identifier))
    );
}
impl Default for spdk_nvme_feat_host_identifier {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_firmware_page {
    pub afi: spdk_nvme_firmware_page__bindgen_ty_1,
    pub reserved: [u8; 7usize],
    pub revision: [[u8; 8usize]; 7usize],
    pub reserved2: [u8; 448usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_firmware_page__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_firmware_page__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_firmware_page__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_firmware_page__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_firmware_page__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_firmware_page__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_firmware_page__bindgen_ty_1 {
    #[inline]
    pub fn active_slot(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_active_slot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn next_reset_slot(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_next_reset_slot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active_slot: u8,
        reserved3: u8,
        next_reset_slot: u8,
        reserved7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let active_slot: u8 = unsafe { ::std::mem::transmute(active_slot) };
            active_slot as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved3: u8 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let next_reset_slot: u8 = unsafe { ::std::mem::transmute(next_reset_slot) };
            next_reset_slot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved7: u8 = unsafe { ::std::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_firmware_page() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_firmware_page>(),
        512usize,
        concat!("Size of: ", stringify!(spdk_nvme_firmware_page))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_firmware_page>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_firmware_page))
    );
}
impl Default for spdk_nvme_firmware_page {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_ATTACH: spdk_nvme_ns_attach_type = 0;
pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_DETACH: spdk_nvme_ns_attach_type = 1;
pub type spdk_nvme_ns_attach_type = u32;
pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_CREATE:
    spdk_nvme_ns_management_type = 0;
pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_DELETE:
    spdk_nvme_ns_management_type = 1;
pub type spdk_nvme_ns_management_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_ns_list {
    pub ns_list: [u32; 1024usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_list() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_list>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_list))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_list>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_list))
    );
}
impl Default for spdk_nvme_ns_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_nidt_SPDK_NVME_NIDT_EUI64: spdk_nvme_nidt = 1;
pub const spdk_nvme_nidt_SPDK_NVME_NIDT_NGUID: spdk_nvme_nidt = 2;
pub const spdk_nvme_nidt_SPDK_NVME_NIDT_UUID: spdk_nvme_nidt = 3;
pub type spdk_nvme_nidt = u32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct spdk_nvme_ns_id_desc {
    pub nidt: u8,
    pub nidl: u8,
    pub reserved2: u8,
    pub reserved3: u8,
    pub nid: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_id_desc() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_id_desc>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_id_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_id_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_id_desc))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_ctrlr_list {
    pub ctrlr_count: u16,
    pub ctrlr_list: [u16; 2047usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_list() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_list>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_list>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ctrlr_list))
    );
}
impl Default for spdk_nvme_ctrlr_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE:
    spdk_nvme_secure_erase_setting = 0;
pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE:
    spdk_nvme_secure_erase_setting = 1;
pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE:
    spdk_nvme_secure_erase_setting = 2;
pub type spdk_nvme_secure_erase_setting = u32;
pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL: spdk_nvme_pi_location = 0;
pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD: spdk_nvme_pi_location = 1;
pub type spdk_nvme_pi_location = u32;
pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_DISABLE: spdk_nvme_pi_type = 0;
pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE1: spdk_nvme_pi_type = 1;
pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE2: spdk_nvme_pi_type = 2;
pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE3: spdk_nvme_pi_type = 3;
pub type spdk_nvme_pi_type = u32;
pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER:
    spdk_nvme_metadata_setting = 0;
pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA:
    spdk_nvme_metadata_setting = 1;
pub type spdk_nvme_metadata_setting = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_format {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_format() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_format>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_format))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_format>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_format))
    );
}
impl spdk_nvme_format {
    #[inline]
    pub fn lbaf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_lbaf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ms(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ms(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pil(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pil(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ses(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ses(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lbaf: u32,
        ms: u32,
        pi: u32,
        pil: u32,
        ses: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let lbaf: u32 = unsafe { ::std::mem::transmute(lbaf) };
            lbaf as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ms: u32 = unsafe { ::std::mem::transmute(ms) };
            ms as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let pi: u32 = unsafe { ::std::mem::transmute(pi) };
            pi as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let pil: u32 = unsafe { ::std::mem::transmute(pil) };
            pil as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let ses: u32 = unsafe { ::std::mem::transmute(ses) };
            ses as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_protection_info {
    pub guard: u16,
    pub app_tag: u16,
    pub ref_tag: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_protection_info() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_protection_info>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_protection_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_protection_info>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_protection_info))
    );
}
pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_IMG: spdk_nvme_fw_commit_action =
    0;
pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG:
    spdk_nvme_fw_commit_action = 1;
pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_ENABLE_IMG: spdk_nvme_fw_commit_action = 2;
pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_RUN_IMG: spdk_nvme_fw_commit_action = 3;
pub type spdk_nvme_fw_commit_action = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spdk_nvme_fw_commit {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_fw_commit() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_fw_commit>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_fw_commit))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_fw_commit>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_fw_commit))
    );
}
impl spdk_nvme_fw_commit {
    #[inline]
    pub fn fs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_fs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ca(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ca(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fs: u32,
        ca: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let fs: u32 = unsafe { ::std::mem::transmute(fs) };
            fs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let ca: u32 = unsafe { ::std::mem::transmute(ca) };
            ca as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV4: spdk_nvmf_adrfam = 1;
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV6: spdk_nvmf_adrfam = 2;
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IB: spdk_nvmf_adrfam = 3;
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_FC: spdk_nvmf_adrfam = 4;
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_INTRA_HOST: spdk_nvmf_adrfam = 254;
pub type spdk_nvmf_adrfam = u32;
/// Opaque handle to a controller. Returned by spdk_nvme_probe()'s attach_cb.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr {
    _unused: [u8; 0],
}
/// NVMe controller initialization options.
///
/// A pointer to this structure will be provided for each probe callback from spdk_nvme_probe() to
/// allow the user to request non-default options, and the actual options enabled on the controller
/// will be provided during the attach callback.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_ctrlr_opts {
    /// Number of I/O queues to request (used to set Number of Queues feature)
    pub num_io_queues: u32,
    /// Enable submission queue in controller memory buffer
    pub use_cmb_sqs: bool,
    /// Type of arbitration mechanism
    pub arb_mechanism: spdk_nvme_cc_ams,
    /// Keep alive timeout in milliseconds (0 = disabled).
    ///
    /// The NVMe library will set the Keep Alive Timer feature to this value and automatically
    /// send Keep Alive commands as needed.  The library user must call
    /// spdk_nvme_ctrlr_process_admin_completions() periodically to ensure Keep Alive commands
    /// are sent.
    pub keep_alive_timeout_ms: u32,
    /// Specify the retry number when there is issue with the transport
    pub transport_retry_count: ::std::os::raw::c_int,
    /// The queue depth of each NVMe I/O queue.
    pub io_queue_size: u32,
    /// The host NQN to use when connecting to NVMe over Fabrics controllers.
    ///
    /// Unused for local PCIe-attached NVMe devices.
    pub hostnqn: [::std::os::raw::c_char; 224usize],
    /// The number of requests to allocate for each NVMe I/O queue.
    ///
    /// This should be at least as large as io_queue_size.
    ///
    /// A single I/O may allocate more than one request, since splitting may be necessary to
    /// conform to the device's maximum transfer size, PRP list compatibility requirements,
    /// or driver-assisted striping.
    pub io_queue_requests: u32,
    /// Source address for NVMe-oF connections.
    /// Set src_addr and src_svcid to empty strings if no source address should be
    /// specified.
    pub src_addr: [::std::os::raw::c_char; 257usize],
    /// Source service ID (port) for NVMe-oF connections.
    /// Set src_addr and src_svcid to empty strings if no source address should be
    /// specified.
    pub src_svcid: [::std::os::raw::c_char; 33usize],
    /// The host identifier to use when connecting to controllers with 64-bit host ID support.
    ///
    /// Set to all zeroes to specify that no host ID should be provided to the controller.
    pub host_id: [u8; 8usize],
    /// The host identifier to use when connecting to controllers with extended (128-bit) host ID support.
    ///
    /// Set to all zeroes to specify that no host ID should be provided to the controller.
    pub extended_host_id: [u8; 16usize],
    /// The I/O command set to select.
    ///
    /// If the requested command set is not supported, the controller
    /// initialization process will not proceed. By default, the NVM
    /// command set is used.
    pub command_set: spdk_nvme_cc_css,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_opts() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_opts>(),
        572usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ctrlr_opts))
    );
}
impl Default for spdk_nvme_ctrlr_opts {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Get the default options for the creation of a specific NVMe controller.
    ///
    /// \param[out] opts Will be filled with the default option.
    /// \param opts_size Must be set to sizeof(struct spdk_nvme_ctrlr_opts).
    pub fn spdk_nvme_ctrlr_get_default_ctrlr_opts(
        opts: *mut spdk_nvme_ctrlr_opts,
        opts_size: usize,
    );
}
/// PCIe Transport (locally attached devices)
pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_PCIE: spdk_nvme_transport_type = 256;
/// RDMA Transport (RoCE, iWARP, etc.)
pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_RDMA: spdk_nvme_transport_type = 1;
/// Fibre Channel (FC) Transport
pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_FC: spdk_nvme_transport_type = 2;
/// NVMe library transports
///
/// NOTE: These are mapped directly to the NVMe over Fabrics TRTYPE values, except for PCIe,
/// which is a special case since NVMe over Fabrics does not define a TRTYPE for local PCIe.
///
/// Currently, this uses 256 for PCIe which is intentionally outside of the 8-bit range of TRTYPE.
/// If the NVMe-oF specification ever defines a PCIe TRTYPE, this should be updated.
pub type spdk_nvme_transport_type = u32;
/// NVMe transport identifier.
///
/// This identifies a unique endpoint on an NVMe fabric.
///
/// A string representation of a transport ID may be converted to this type using
/// spdk_nvme_transport_id_parse().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_transport_id {
    /// NVMe transport type.
    pub trtype: spdk_nvme_transport_type,
    /// Address family of the transport address.
    ///
    /// For PCIe, this value is ignored.
    pub adrfam: spdk_nvmf_adrfam,
    /// Transport address of the NVMe-oF endpoint. For transports which use IP
    /// addressing (e.g. RDMA), this should be an IP address. For PCIe, this
    /// can either be a zero length string (the whole bus) or a PCI address
    /// in the format DDDD:BB:DD.FF or DDDD.BB.DD.FF. For FC the string is
    /// formatted as: nn-0xWWNN:pn-0xWWPN” where WWNN is the Node_Name of the
    /// target NVMe_Port and WWPN is the N_Port_Name of the target NVMe_Port.
    pub traddr: [::std::os::raw::c_char; 257usize],
    /// Transport service id of the NVMe-oF endpoint.  For transports which use
    /// IP addressing (e.g. RDMA), this field shoud be the port number. For PCIe,
    /// and FC this is always a zero length string.
    pub trsvcid: [::std::os::raw::c_char; 33usize],
    /// Subsystem NQN of the NVMe over Fabrics endpoint. May be a zero length string.
    pub subnqn: [::std::os::raw::c_char; 224usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_transport_id() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_transport_id>(),
        524usize,
        concat!("Size of: ", stringify!(spdk_nvme_transport_id))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_transport_id>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_transport_id))
    );
}
impl Default for spdk_nvme_transport_id {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Parse the string representation of a transport ID.
    ///
    /// \param trid Output transport ID structure (must be allocated and initialized by caller).
    /// \param str Input string representation of a transport ID to parse.
    ///
    /// str must be a zero-terminated C string containing one or more key:value pairs
    /// separated by whitespace.
    ///
    /// Key          | Value
    /// ------------ | -----
    /// trtype       | Transport type (e.g. PCIe, RDMA)
    /// adrfam       | Address family (e.g. IPv4, IPv6)
    /// traddr       | Transport address (e.g. 0000:04:00.0 for PCIe, 192.168.100.8 for RDMA, or WWN for FC)
    /// trsvcid      | Transport service identifier (e.g. 4420)
    /// subnqn       | Subsystem NQN
    ///
    /// Unspecified fields of trid are left unmodified, so the caller must initialize
    /// trid (for example, memset() to 0) before calling this function.
    ///
    /// \return 0 if parsing was successful and trid is filled out, or negated errno
    /// values on failure.
    pub fn spdk_nvme_transport_id_parse(
        trid: *mut spdk_nvme_transport_id,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Parse the string representation of a transport ID tranport type.
    ///
    /// \param trtype Output transport type (allocated by caller).
    /// \param str Input string representation of transport type (e.g. "PCIe", "RDMA").
    ///
    /// \return 0 if parsing was successful and trtype is filled out, or negated errno
    /// values on failure.
    pub fn spdk_nvme_transport_id_parse_trtype(
        trtype: *mut spdk_nvme_transport_type,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Look up the string representation of a transport ID transport type.
    ///
    /// \param trtype Transport type to convert.
    ///
    /// \return static string constant describing trtype, or NULL if trtype not found.
    pub fn spdk_nvme_transport_id_trtype_str(
        trtype: spdk_nvme_transport_type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Look up the string representation of a transport ID address family.
    ///
    /// \param adrfam Address family to convert.
    ///
    /// \return static string constant describing adrfam, or NULL if adrmfam not found.
    pub fn spdk_nvme_transport_id_adrfam_str(
        adrfam: spdk_nvmf_adrfam,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Parse the string representation of a tranport ID address family.
    ///
    /// \param adrfam Output address family (allocated by caller).
    /// \param str Input string representation of address family (e.g. "IPv4", "IPv6").
    ///
    /// \return 0 if parsing was successful and adrfam is filled out, or negated errno
    /// values on failure.
    pub fn spdk_nvme_transport_id_parse_adrfam(
        adrfam: *mut spdk_nvmf_adrfam,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Compare two transport IDs.
    ///
    /// The result of this function may be used to sort transport IDs in a consistent
    /// order; however, the comparison result is not guaranteed to be consistent across
    /// library versions.
    ///
    /// This function uses a case-insensitive comparison for string fields, but it does
    /// not otherwise normalize the transport ID. It is the caller's responsibility to
    /// provide the transport IDs in a consistent format.
    ///
    /// \param trid1 First transport ID to compare.
    /// \param trid2 Second transport ID to compare.
    ///
    /// \return 0 if trid1 == trid2, less than 0 if trid1 < trid2, greater than 0 if
    /// trid1 > trid2.
    pub fn spdk_nvme_transport_id_compare(
        trid1: *const spdk_nvme_transport_id,
        trid2: *const spdk_nvme_transport_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Determine whether the NVMe library can handle a specific NVMe over Fabrics
    /// transport type.
    ///
    /// \param trtype NVMe over Fabrics transport type to check.
    ///
    /// \return true if trtype is supported or false if it is not supported.
    pub fn spdk_nvme_transport_available(trtype: spdk_nvme_transport_type) -> bool;
}
/// Callback for spdk_nvme_probe() enumeration.
///
/// \param cb_ctx Opaque value passed to spdk_nvme_probe().
/// \param trid NVMe transport identifier.
/// \param opts NVMe controller initialization options. This structure will be
/// populated with the default values on entry, and the user callback may update
/// any options to request a different value. The controller may not support all
/// requested parameters, so the final values will be provided during the attach
/// callback.
///
/// \return true to attach to this device.
pub type spdk_nvme_probe_cb = ::std::option::Option<
    unsafe extern "C" fn(
        cb_ctx: *mut ::std::os::raw::c_void,
        trid: *const spdk_nvme_transport_id,
        opts: *mut spdk_nvme_ctrlr_opts,
    ) -> bool,
>;
/// Callback for spdk_nvme_attach() to report a device that has been attached to
/// the userspace NVMe driver.
///
/// \param cb_ctx Opaque value passed to spdk_nvme_attach_cb().
/// \param trid NVMe transport identifier.
/// \param ctrlr Opaque handle to NVMe controller.
/// \param opts NVMe controller initialization options that were actually used.
/// Options may differ from the requested options from the attach call depending
/// on what the controller supports.
pub type spdk_nvme_attach_cb = ::std::option::Option<
    unsafe extern "C" fn(
        cb_ctx: *mut ::std::os::raw::c_void,
        trid: *const spdk_nvme_transport_id,
        ctrlr: *mut spdk_nvme_ctrlr,
        opts: *const spdk_nvme_ctrlr_opts,
    ),
>;
/// Callback for spdk_nvme_remove() to report that a device attached to the userspace
/// NVMe driver has been removed from the system.
///
/// The controller will remain in a failed state (any new I/O submitted will fail).
///
/// The controller must be detached from the userspace driver by calling spdk_nvme_detach()
/// once the controller is no longer in use. It is up to the library user to ensure
/// that no other threads are using the controller before calling spdk_nvme_detach().
///
/// \param cb_ctx Opaque value passed to spdk_nvme_remove_cb().
/// \param ctrlr NVMe controller instance that was removed.
pub type spdk_nvme_remove_cb = ::std::option::Option<
    unsafe extern "C" fn(cb_ctx: *mut ::std::os::raw::c_void, ctrlr: *mut spdk_nvme_ctrlr),
>;
extern "C" {
    /// Enumerate the bus indicated by the transport ID and attach the userspace NVMe
    /// driver to each device found if desired.
    ///
    /// This function is not thread safe and should only be called from one thread at
    /// a time while no other threads are actively using any NVMe devices.
    ///
    /// If called from a secondary process, only devices that have been attached to
    /// the userspace driver in the primary process will be probed.
    ///
    /// If called more than once, only devices that are not already attached to the
    /// SPDK NVMe driver will be reported.
    ///
    /// To stop using the the controller and release its associated resources,
    /// call spdk_nvme_detach() with the spdk_nvme_ctrlr instance from the attach_cb()
    /// function.
    ///
    /// \param trid The transport ID indicating which bus to enumerate. If the trtype
    /// is PCIe or trid is NULL, this will scan the local PCIe bus. If the trtype is
    /// RDMA, the traddr and trsvcid must point at the location of an NVMe-oF discovery
    /// service.
    /// \param cb_ctx Opaque value which will be passed back in cb_ctx parameter of
    /// the callbacks.
    /// \param probe_cb will be called once per NVMe device found in the system.
    /// \param attach_cb will be called for devices for which probe_cb returned true
    /// once that NVMe controller has been attached to the userspace driver.
    /// \param remove_cb will be called for devices that were attached in a previous
    /// spdk_nvme_probe() call but are no longer attached to the system. Optional;
    /// specify NULL if removal notices are not desired.
    ///
    /// \return 0 on success, -1 on failure.
    pub fn spdk_nvme_probe(
        trid: *const spdk_nvme_transport_id,
        cb_ctx: *mut ::std::os::raw::c_void,
        probe_cb: spdk_nvme_probe_cb,
        attach_cb: spdk_nvme_attach_cb,
        remove_cb: spdk_nvme_remove_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Connect the NVMe driver to the device located at the given transport ID.
    ///
    /// This function is not thread safe and should only be called from one thread at
    /// a time while no other threads are actively using this NVMe device.
    ///
    /// If called from a secondary process, only the device that has been attached to
    /// the userspace driver in the primary process will be connected.
    ///
    /// If connecting to multiple controllers, it is suggested to use spdk_nvme_probe()
    /// and filter the requested controllers with the probe callback. For PCIe controllers,
    /// spdk_nvme_probe() will be more efficient since the controller resets will happen
    /// in parallel.
    ///
    /// To stop using the the controller and release its associated resources, call
    /// spdk_nvme_detach() with the spdk_nvme_ctrlr instance returned by this function.
    ///
    /// \param trid The transport ID indicating which device to connect. If the trtype
    /// is PCIe, this will connect the local PCIe bus. If the trtype is RDMA, the traddr
    /// and trsvcid must point at the location of an NVMe-oF service.
    /// \param opts NVMe controller initialization options. Default values will be used
    /// if the user does not specify the options. The controller may not support all
    /// requested parameters.
    /// \param opts_size Must be set to sizeof(struct spdk_nvme_ctrlr_opts), or 0 if
    /// opts is NULL.
    ///
    /// \return pointer to the connected NVMe controller or NULL if there is any failure.
    ///
    pub fn spdk_nvme_connect(
        trid: *const spdk_nvme_transport_id,
        opts: *const spdk_nvme_ctrlr_opts,
        opts_size: usize,
    ) -> *mut spdk_nvme_ctrlr;
}
extern "C" {
    /// Detach specified device returned by spdk_nvme_probe()'s attach_cb from the
    /// NVMe driver.
    ///
    /// On success, the spdk_nvme_ctrlr handle is no longer valid.
    ///
    /// This function should be called from a single thread while no other threads
    /// are actively using the NVMe device.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return 0 on success, -1 on failure.
    pub fn spdk_nvme_detach(ctrlr: *mut spdk_nvme_ctrlr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Perform a full hardware reset of the NVMe controller.
    ///
    /// This function should be called from a single thread while no other threads
    /// are actively using the NVMe device.
    ///
    /// Any pointers returned from spdk_nvme_ctrlr_get_ns() and spdk_nvme_ns_get_data()
    /// may be invalidated by calling this function. The number of namespaces as returned
    /// by spdk_nvme_ctrlr_get_num_ns() may also change.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return 0 on success, -1 on failure.
    pub fn spdk_nvme_ctrlr_reset(ctrlr: *mut spdk_nvme_ctrlr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the identify controller data as defined by the NVMe specification.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return pointer to the identify controller data.
    pub fn spdk_nvme_ctrlr_get_data(ctrlr: *mut spdk_nvme_ctrlr) -> *const spdk_nvme_ctrlr_data;
}
extern "C" {
    /// Get the NVMe controller CSTS (Status) register.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return the NVMe controller CSTS (Status) register.
    pub fn spdk_nvme_ctrlr_get_regs_csts(ctrlr: *mut spdk_nvme_ctrlr) -> spdk_nvme_csts_register;
}
extern "C" {
    /// Get the NVMe controller CAP (Capabilities) register.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return the NVMe controller CAP (Capabilities) register.
    pub fn spdk_nvme_ctrlr_get_regs_cap(ctrlr: *mut spdk_nvme_ctrlr) -> spdk_nvme_cap_register;
}
extern "C" {
    /// Get the NVMe controller VS (Version) register.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return the NVMe controller VS (Version) register.
    pub fn spdk_nvme_ctrlr_get_regs_vs(ctrlr: *mut spdk_nvme_ctrlr) -> spdk_nvme_vs_register;
}
extern "C" {
    /// Get the number of namespaces for the given NVMe controller.
    ///
    /// This function is thread safe and can be called at any point while the
    /// controller is attached to the SPDK NVMe driver.
    ///
    /// This is equivalent to calling spdk_nvme_ctrlr_get_data() to get the
    /// spdk_nvme_ctrlr_data and then reading the nn field.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return the number of namespaces.
    pub fn spdk_nvme_ctrlr_get_num_ns(ctrlr: *mut spdk_nvme_ctrlr) -> u32;
}
extern "C" {
    /// Get the PCI device of a given NVMe controller.
    ///
    /// This only works for local (PCIe-attached) NVMe controllers; other transports
    /// will return NULL.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return PCI device of the NVMe controller, or NULL if not available.
    pub fn spdk_nvme_ctrlr_get_pci_device(ctrlr: *mut spdk_nvme_ctrlr) -> *mut spdk_pci_device;
}
extern "C" {
    /// Get the maximum data transfer size of a given NVMe controller.
    ///
    /// \return Maximum data transfer size of the NVMe controller in bytes.
    ///
    /// The I/O command helper functions, such as spdk_nvme_ns_cmd_read(), will split
    /// large I/Os automatically; however, it is up to the user to obey this limit for
    /// commands submitted with the raw command functions, such as spdk_nvme_ctrlr_cmd_io_raw().
    pub fn spdk_nvme_ctrlr_get_max_xfer_size(ctrlr: *const spdk_nvme_ctrlr) -> u32;
}
extern "C" {
    /// Check whether the nsid is an active nv for the given NVMe controller.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param nsid Namespace id.
    ///
    /// \return true if nsid is an active ns, or false otherwise.
    pub fn spdk_nvme_ctrlr_is_active_ns(ctrlr: *mut spdk_nvme_ctrlr, nsid: u32) -> bool;
}
extern "C" {
    /// Get the nsid of the first active namespace.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return the nsid of the first active namespace, 0 if there are no active namespaces.
    pub fn spdk_nvme_ctrlr_get_first_active_ns(ctrlr: *mut spdk_nvme_ctrlr) -> u32;
}
extern "C" {
    /// Get next active namespace given the previous nsid.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param prev_nsid Namespace id.
    ///
    /// \return a next active namespace given the previous nsid, 0 when there are no
    /// more active namespaces.
    pub fn spdk_nvme_ctrlr_get_next_active_ns(ctrlr: *mut spdk_nvme_ctrlr, prev_nsid: u32) -> u32;
}
extern "C" {
    /// Determine if a particular log page is supported by the given NVMe controller.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \sa spdk_nvme_ctrlr_cmd_get_log_page().
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param log_page Log page to query.
    ///
    /// \return true if supported, or false otherwise.
    pub fn spdk_nvme_ctrlr_is_log_page_supported(ctrlr: *mut spdk_nvme_ctrlr, log_page: u8)
        -> bool;
}
extern "C" {
    /// Determine if a particular feature is supported by the given NVMe controller.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \sa spdk_nvme_ctrlr_cmd_get_feature().
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param feature_code Feature to query.
    ///
    /// \return true if supported, or false otherwise.
    pub fn spdk_nvme_ctrlr_is_feature_supported(
        ctrlr: *mut spdk_nvme_ctrlr,
        feature_code: u8,
    ) -> bool;
}
/// Signature for callback function invoked when a command is completed.
///
/// \param spdk_nvme_cpl Completion queue entry that coontains the completion status.
pub type spdk_nvme_cmd_cb = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const spdk_nvme_cpl),
>;
/// Signature for callback function invoked when an asynchronous error request
/// command is completed.
///
/// \param ctrlr Opaque handle to NVMe controller.
/// \param aer_cb_arg Context specified by spdk_nvme_register_aer_callback().
/// \param spdk_nvme_cpl Completion queue entry that contains the completion status
/// of the asynchronous event request that was completed.
pub type spdk_nvme_aer_cb = ::std::option::Option<
    unsafe extern "C" fn(aer_cb_arg: *mut ::std::os::raw::c_void, arg1: *const spdk_nvme_cpl),
>;
extern "C" {
    /// Register callback function invoked when an AER command is completed for the
    /// given NVMe controller.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param aer_cb_fn Callback function invoked when an asynchronous error request
    /// command is completed.
    /// \param aer_cb_arg Argument passed to callback function.
    pub fn spdk_nvme_ctrlr_register_aer_callback(
        ctrlr: *mut spdk_nvme_ctrlr,
        aer_cb_fn: spdk_nvme_aer_cb,
        aer_cb_arg: *mut ::std::os::raw::c_void,
    );
}
/// Opaque handle to a queue pair.
///
/// I/O queue pairs may be allocated using spdk_nvme_ctrlr_alloc_io_qpair().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_qpair {
    _unused: [u8; 0],
}
/// Signature for the callback function invoked when a timeout is detected on a
/// request.
///
/// For timeouts detected on the admin queue pair, the qpair returned here will
/// be NULL.  If the controller has a serious error condition and is unable to
/// communicate with driver via completion queue, the controller can set Controller
/// Fatal Status field to 1, then reset is required to recover from such error.
/// Users may detect Controller Fatal Status when timeout happens.
///
/// \param cb_arg Argument passed to callback funciton.
/// \param ctrlr Opaque handle to NVMe controller.
/// \param qpair Opaque handle to a queue pair.
/// \param cid Command ID.
pub type spdk_nvme_timeout_cb = ::std::option::Option<
    unsafe extern "C" fn(
        cb_arg: *mut ::std::os::raw::c_void,
        ctrlr: *mut spdk_nvme_ctrlr,
        qpair: *mut spdk_nvme_qpair,
        cid: u16,
    ),
>;
extern "C" {
    /// Register for timeout callback on a controller.
    ///
    /// The application can choose to register for timeout callback or not register
    /// for timeout callback.
    ///
    /// \param ctrlr NVMe controller on which to monitor for timeout.
    /// \param timeout_us Timeout value in microseconds.
    /// \param cb_fn A function pointer that points to the callback function.
    /// \param cb_arg Argument to the callback function.
    pub fn spdk_nvme_ctrlr_register_timeout_callback(
        ctrlr: *mut spdk_nvme_ctrlr,
        timeout_us: u64,
        cb_fn: spdk_nvme_timeout_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
/// NVMe I/O queue pair initialization options.
///
/// These options may be passed to spdk_nvme_ctrlr_alloc_io_qpair() to configure queue pair
/// options at queue creation time.
///
/// The user may retrieve the default I/O queue pair creation options for a controller using
/// spdk_nvme_ctrlr_get_default_io_qpair_opts().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_io_qpair_opts {
    /// Queue priority for weighted round robin arbitration.  If a different arbitration
    /// method is in use, pass 0.
    pub qprio: spdk_nvme_qprio,
    /// The queue depth of this NVMe I/O queue. Overrides spdk_nvme_ctrlr_opts::io_queue_size.
    pub io_queue_size: u32,
    /// The number of requests to allocate for this NVMe I/O queue.
    ///
    /// Overrides spdk_nvme_ctrlr_opts::io_queue_requests.
    ///
    /// This should be at least as large as io_queue_size.
    ///
    /// A single I/O may allocate more than one request, since splitting may be
    /// necessary to conform to the device's maximum transfer size, PRP list
    /// compatibility requirements, or driver-assisted striping.
    pub io_queue_requests: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_io_qpair_opts() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_io_qpair_opts>(),
        12usize,
        concat!("Size of: ", stringify!(spdk_nvme_io_qpair_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_io_qpair_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_io_qpair_opts))
    );
}
impl Default for spdk_nvme_io_qpair_opts {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Get the default options for I/O qpair creation for a specific NVMe controller.
    ///
    /// \param ctrlr NVMe controller to retrieve the defaults from.
    /// \param[out] opts Will be filled with the default options for
    /// spdk_nvme_ctrlr_alloc_io_qpair().
    /// \param opts_size Must be set to sizeof(struct spdk_nvme_io_qpair_opts).
    pub fn spdk_nvme_ctrlr_get_default_io_qpair_opts(
        ctrlr: *mut spdk_nvme_ctrlr,
        opts: *mut spdk_nvme_io_qpair_opts,
        opts_size: usize,
    );
}
extern "C" {
    /// Allocate an I/O queue pair (submission and completion queue).
    ///
    /// Each queue pair should only be used from a single thread at a time (mutual
    /// exclusion must be enforced by the user).
    ///
    /// \param ctrlr NVMe controller for which to allocate the I/O queue pair.
    /// \param opts I/O qpair creation options, or NULL to use the defaults as returned
    /// by spdk_nvme_ctrlr_alloc_io_qpair().
    /// \param opts_size Must be set to sizeof(struct spdk_nvme_io_qpair_opts), or 0
    /// if opts is NULL.
    ///
    /// \return a pointer to the allocated I/O queue pair.
    pub fn spdk_nvme_ctrlr_alloc_io_qpair(
        ctrlr: *mut spdk_nvme_ctrlr,
        opts: *const spdk_nvme_io_qpair_opts,
        opts_size: usize,
    ) -> *mut spdk_nvme_qpair;
}
extern "C" {
    /// Free an I/O queue pair that was allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    ///
    /// \param qpair I/O queue pair to free.
    ///
    /// \return 0 on success, -1 on failure.
    pub fn spdk_nvme_ctrlr_free_io_qpair(qpair: *mut spdk_nvme_qpair) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Send the given NVM I/O command to the NVMe controller.
    ///
    /// This is a low level interface for submitting I/O commands directly. Prefer
    /// the spdk_nvme_ns_cmd_* functions instead. The validity of the command will
    /// not be checked!
    ///
    /// When constructing the nvme_command it is not necessary to fill out the PRP
    /// list/SGL or the CID. The driver will handle both of those for you.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param qpair I/O qpair to submit command.
    /// \param cmd NVM I/O command to submit.
    /// \param buf Virtual memory address of a single physically contiguous buffer.
    /// \param len Size of buffer.
    /// \param cb_fn Callback function invoked when the I/O command completes.
    /// \param cb_arg Argument passed to callback function.
    ///
    /// \return 0 on success, negated errno on failure.
    pub fn spdk_nvme_ctrlr_cmd_io_raw(
        ctrlr: *mut spdk_nvme_ctrlr,
        qpair: *mut spdk_nvme_qpair,
        cmd: *mut spdk_nvme_cmd,
        buf: *mut ::std::os::raw::c_void,
        len: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Send the given NVM I/O command with metadata to the NVMe controller.
    ///
    /// This is a low level interface for submitting I/O commands directly. Prefer
    /// the spdk_nvme_ns_cmd_* functions instead. The validity of the command will
    /// not be checked!
    ///
    /// When constructing the nvme_command it is not necessary to fill out the PRP
    /// list/SGL or the CID. The driver will handle both of those for you.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param qpair I/O qpair to submit command.
    /// \param cmd NVM I/O command to submit.
    /// \param buf Virtual memory address of a single physically contiguous buffer.
    /// \param len Size of buffer.
    /// \param md_buf Virtual memory address of a single physically contiguous metadata
    /// buffer.
    /// \param cb_fn Callback function invoked when the I/O command completes.
    /// \param cb_arg Argument passed to callback function.
    ///
    /// \return 0 on success, negated errno on failure.
    pub fn spdk_nvme_ctrlr_cmd_io_raw_with_md(
        ctrlr: *mut spdk_nvme_ctrlr,
        qpair: *mut spdk_nvme_qpair,
        cmd: *mut spdk_nvme_cmd,
        buf: *mut ::std::os::raw::c_void,
        len: u32,
        md_buf: *mut ::std::os::raw::c_void,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Process any outstanding completions for I/O submitted on a queue pair.
    ///
    /// This call is non-blocking, i.e. it only processes completions that are ready
    /// at the time of this function call. It does not wait for outstanding commands
    /// to finish.
    ///
    /// For each completed command, the request's callback function will be called if
    /// specified as non-NULL when the request was submitted.
    ///
    /// The caller must ensure that each queue pair is only used from one thread at a
    /// time.
    ///
    /// This function may be called at any point while the controller is attached to
    /// the SPDK NVMe driver.
    ///
    /// \sa spdk_nvme_cmd_cb
    ///
    /// \param qpair Queue pair to check for completions.
    /// \param max_completions Limit the number of completions to be processed in one
    /// call, or 0 for unlimited.
    ///
    /// \return number of completions processed (may be 0) or negated on error.
    pub fn spdk_nvme_qpair_process_completions(
        qpair: *mut spdk_nvme_qpair,
        max_completions: u32,
    ) -> i32;
}
extern "C" {
    /// Send the given admin command to the NVMe controller.
    ///
    /// This is a low level interface for submitting admin commands directly. Prefer
    /// the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will
    /// not be checked!
    ///
    /// When constructing the nvme_command it is not necessary to fill out the PRP
    /// list/SGL or the CID. The driver will handle both of those for you.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion
    /// of commands submitted through this function.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param cmd NVM admin command to submit.
    /// \param buf Virtual memory address of a single physically contiguous buffer.
    /// \param len Size of buffer.
    /// \param cb_fn Callback function invoked when the admin command completes.
    /// \param cb_arg Argument passed to callback function.
    ///
    /// \return 0 on success, negated errno on failure.
    pub fn spdk_nvme_ctrlr_cmd_admin_raw(
        ctrlr: *mut spdk_nvme_ctrlr,
        cmd: *mut spdk_nvme_cmd,
        buf: *mut ::std::os::raw::c_void,
        len: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Process any outstanding completions for admin commands.
    ///
    /// This will process completions for admin commands submitted on any thread.
    ///
    /// This call is non-blocking, i.e. it only processes completions that are ready
    /// at the time of this function call. It does not wait for outstanding commands
    /// to finish.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    ///
    /// \return number of completions processed (may be 0) or negated on error.
    pub fn spdk_nvme_ctrlr_process_admin_completions(ctrlr: *mut spdk_nvme_ctrlr) -> i32;
}
/// Opaque handle to a namespace. Obtained by calling spdk_nvme_ctrlr_get_ns().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns {
    _unused: [u8; 0],
}
extern "C" {
    /// Get a handle to a namespace for the given controller.
    ///
    /// Namespaces are numbered from 1 to the total number of namespaces. There will
    /// never be any gaps in the numbering. The number of namespaces is obtained by
    /// calling spdk_nvme_ctrlr_get_num_ns().
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param ns_id Namespace id.
    ///
    /// \return a pointer to the namespace.
    pub fn spdk_nvme_ctrlr_get_ns(ctrlr: *mut spdk_nvme_ctrlr, ns_id: u32) -> *mut spdk_nvme_ns;
}
extern "C" {
    /// Get a specific log page from the NVMe controller.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of
    /// commands submitted through this function.
    ///
    /// \sa spdk_nvme_ctrlr_is_log_page_supported()
    ///
    /// \param ctrlr Opaque handle to NVMe controller.
    /// \param log_page The log page identifier.
    /// \param nsid Depending on the log page, this may be 0, a namespace identifier,
    /// or SPDK_NVME_GLOBAL_NS_TAG.
    /// \param payload The pointer to the payload buffer.
    /// \param payload_size The size of payload buffer.
    /// \param offset Offset in bytes within the log page to start retrieving log page
    /// data. May only be non-zero if the controller supports extended data for Get Log
    /// Page as reported in the controller data log page attributes.
    /// \param cb_fn Callback function to invoke when the log page has been retrieved.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if resources could not be
    /// allocated for this request.
    pub fn spdk_nvme_ctrlr_cmd_get_log_page(
        ctrlr: *mut spdk_nvme_ctrlr,
        log_page: u8,
        nsid: u32,
        payload: *mut ::std::os::raw::c_void,
        payload_size: u32,
        offset: u64,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Abort a specific previously-submitted NVMe command.
    ///
    /// \sa spdk_nvme_ctrlr_register_timeout_callback()
    ///
    /// \param ctrlr NVMe controller to which the command was submitted.
    /// \param qpair NVMe queue pair to which the command was submitted. For admin
    ///  commands, pass NULL for the qpair.
    /// \param cid Command ID of the command to abort.
    /// \param cb_fn Callback function to invoke when the abort has completed.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno value otherwise.
    pub fn spdk_nvme_ctrlr_cmd_abort(
        ctrlr: *mut spdk_nvme_ctrlr,
        qpair: *mut spdk_nvme_qpair,
        cid: u16,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set specific feature for the given NVMe controller.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of
    /// commands submitted through this function.
    ///
    /// \sa spdk_nvme_ctrlr_cmd_get_feature().
    ///
    /// \param ctrlr NVMe controller to manipulate.
    /// \param feature The feature identifier.
    /// \param cdw11 as defined by the specification for this command.
    /// \param cdw12 as defined by the specification for this command.
    /// \param payload The pointer to the payload buffer.
    /// \param payload_size The size of payload buffer.
    /// \param cb_fn Callback function to invoke when the feature has been set.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if resources could not be
    /// allocated for this request.
    pub fn spdk_nvme_ctrlr_cmd_set_feature(
        ctrlr: *mut spdk_nvme_ctrlr,
        feature: u8,
        cdw11: u32,
        cdw12: u32,
        payload: *mut ::std::os::raw::c_void,
        payload_size: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get specific feature from given NVMe controller.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of
    /// commands submitted through this function.
    ///
    /// \sa spdk_nvme_ctrlr_cmd_set_feature()
    ///
    /// \param ctrlr NVMe controller to query.
    /// \param feature The feature identifier.
    /// \param cdw11 as defined by the specification for this command.
    /// \param payload The pointer to the payload buffer.
    /// \param payload_size The size of payload buffer.
    /// \param cb_fn Callback function to invoke when the feature has been retrieved.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, ENOMEM if resources could not be allocated
    /// for this request.
    pub fn spdk_nvme_ctrlr_cmd_get_feature(
        ctrlr: *mut spdk_nvme_ctrlr,
        feature: u8,
        cdw11: u32,
        payload: *mut ::std::os::raw::c_void,
        payload_size: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get specific feature from given NVMe controller.
    ///
    /// \param ctrlr NVMe controller to query.
    /// \param feature The feature identifier.
    /// \param cdw11 as defined by the specification for this command.
    /// \param payload The pointer to the payload buffer.
    /// \param payload_size The size of payload buffer.
    /// \param cb_fn Callback function to invoke when the feature has been retrieved.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param ns_id The namespace identifier.
    ///
    /// \return 0 if successfully submitted, ENOMEM if resources could not be allocated
    /// for this request
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
    /// of commands submitted through this function.
    ///
    /// \sa spdk_nvme_ctrlr_cmd_set_feature_ns()
    pub fn spdk_nvme_ctrlr_cmd_get_feature_ns(
        ctrlr: *mut spdk_nvme_ctrlr,
        feature: u8,
        cdw11: u32,
        payload: *mut ::std::os::raw::c_void,
        payload_size: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        ns_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set specific feature for the given NVMe controller and namespace ID.
    ///
    /// \param ctrlr NVMe controller to manipulate.
    /// \param feature The feature identifier.
    /// \param cdw11 as defined by the specification for this command.
    /// \param cdw12 as defined by the specification for this command.
    /// \param payload The pointer to the payload buffer.
    /// \param payload_size The size of payload buffer.
    /// \param cb_fn Callback function to invoke when the feature has been set.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param ns_id The namespace identifier.
    ///
    /// \return 0 if successfully submitted, ENOMEM if resources could not be allocated
    /// for this request.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
    /// of commands submitted through this function.
    ///
    /// \sa spdk_nvme_ctrlr_cmd_get_feature_ns()
    pub fn spdk_nvme_ctrlr_cmd_set_feature_ns(
        ctrlr: *mut spdk_nvme_ctrlr,
        feature: u8,
        cdw11: u32,
        cdw12: u32,
        payload: *mut ::std::os::raw::c_void,
        payload_size: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        ns_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Receive security protocol data from controller.
    ///
    /// This function is thread safe and can be called at any point after spdk_nvme_probe().
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of
    /// commands submitted through this function.
    ///
    /// \param ctrlr NVMe controller to use for security receive command submission.
    /// \param secp Security Protocol that is used.
    /// \param spsp Security Protocol Specific field.
    /// \param nssf NVMe Security Specific field. Indicate RPMB target when using Security
    /// Protocol EAh.
    /// \param payload The pointer to the payload buffer.
    /// \param payload_size The size of payload buffer.
    /// \param cb_fn Callback function to invoke when the security receive has completed.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if resources could not be allocated
    /// for this request.
    pub fn spdk_nvme_ctrlr_cmd_security_receive(
        ctrlr: *mut spdk_nvme_ctrlr,
        secp: u8,
        spsp: u16,
        nssf: u8,
        payload: *mut ::std::os::raw::c_void,
        payload_size: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Send security protocol data to controller.
    ///
    /// This function is thread safe and can be called at any point after spdk_nvme_probe().
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of
    /// commands submitted through this function.
    ///
    /// \param ctrlr NVMe controller to use for security send command submission.
    /// \param secp Security Protocol that is used.
    /// \param spsp Security Protocol Specific field.
    /// \param nssf NVMe Security Specific field. Indicate RPMB target when using Security
    /// Protocol EAh.
    /// \param payload The pointer to the payload buffer.
    /// \param payload_size The size of payload buffer.
    /// \param cb_fn Callback function to invoke when the security send has completed.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if resources could not be allocated
    /// for this request.
    pub fn spdk_nvme_ctrlr_cmd_security_send(
        ctrlr: *mut spdk_nvme_ctrlr,
        secp: u8,
        spsp: u16,
        nssf: u8,
        payload: *mut ::std::os::raw::c_void,
        payload_size: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Attach the specified namespace to controllers.
    ///
    /// This function is thread safe and can be called at any point after spdk_nvme_probe().
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of
    /// commands submitted through this function.
    ///
    /// \param ctrlr NVMe controller to use for command submission.
    /// \param nsid Namespace identifier for namespace to attach.
    /// \param payload The pointer to the controller list.
    ///
    /// \return 0 if successfully submitted, ENOMEM if resources could not be allocated
    /// for this request.
    pub fn spdk_nvme_ctrlr_attach_ns(
        ctrlr: *mut spdk_nvme_ctrlr,
        nsid: u32,
        payload: *mut spdk_nvme_ctrlr_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Detach the specified namespace from controllers.
    ///
    /// This function is thread safe and can be called at any point after spdk_nvme_probe().
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of
    /// commands submitted through this function.
    ///
    /// \param ctrlr NVMe controller to use for command submission.
    /// \param nsid Namespace ID to detach.
    /// \param payload The pointer to the controller list.
    ///
    /// \return 0 if successfully submitted, ENOMEM if resources could not be allocated
    /// for this request
    pub fn spdk_nvme_ctrlr_detach_ns(
        ctrlr: *mut spdk_nvme_ctrlr,
        nsid: u32,
        payload: *mut spdk_nvme_ctrlr_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a namespace.
    ///
    /// This function is thread safe and can be called at any point after spdk_nvme_probe().
    ///
    /// \param ctrlr NVMe controller to create namespace on.
    /// \param payload The pointer to the NVMe namespace data.
    ///
    /// \return Namespace ID (>= 1) if successfully created, or 0 if the request failed.
    pub fn spdk_nvme_ctrlr_create_ns(
        ctrlr: *mut spdk_nvme_ctrlr,
        payload: *mut spdk_nvme_ns_data,
    ) -> u32;
}
extern "C" {
    /// Delete a namespace.
    ///
    /// This function is thread safe and can be called at any point after spdk_nvme_probe().
    ///
    /// Call spdk_nvme_ctrlr_process_admin_completions() to poll for completion of
    /// commands submitted through this function.
    ///
    /// \param ctrlr NVMe controller to delete namespace from.
    /// \param nsid The namespace identifier.
    ///
    /// \return 0 if successfully submitted, negated errno if resources could not be
    /// allocated
    /// for this request
    pub fn spdk_nvme_ctrlr_delete_ns(
        ctrlr: *mut spdk_nvme_ctrlr,
        nsid: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Format NVM.
    ///
    /// This function requests a low-level format of the media.
    ///
    /// This function is thread safe and can be called at any point after spdk_nvme_probe().
    ///
    /// \param ctrlr NVMe controller to format.
    /// \param nsid The namespace identifier. May be SPDK_NVME_GLOBAL_NS_TAG to format
    /// all namespaces.
    /// \param format The format information for the command.
    ///
    /// \return 0 if successfully submitted, negated errno if resources could not be
    /// allocated for this request
    pub fn spdk_nvme_ctrlr_format(
        ctrlr: *mut spdk_nvme_ctrlr,
        nsid: u32,
        format: *mut spdk_nvme_format,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Download a new firmware image.
    ///
    /// This function is thread safe and can be called at any point after spdk_nvme_probe().
    ///
    /// \param ctrlr NVMe controller to perform firmware operation on.
    /// \param payload The data buffer for the firmware image.
    /// \param size The data size will be downloaded.
    /// \param slot The slot that the firmware image will be committed to.
    /// \param commit_action The action to perform when firmware is committed.
    /// \param completion_status output parameter. Contains the completion status of
    /// the firmware commit operation.
    ///
    /// \return 0 if successfully submitted, ENOMEM if resources could not be allocated
    /// for this request, -1 if the size is not multiple of 4.
    pub fn spdk_nvme_ctrlr_update_firmware(
        ctrlr: *mut spdk_nvme_ctrlr,
        payload: *mut ::std::os::raw::c_void,
        size: u32,
        slot: ::std::os::raw::c_int,
        commit_action: spdk_nvme_fw_commit_action,
        completion_status: *mut spdk_nvme_status,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate an I/O buffer from the controller memory buffer (Experimental).
    ///
    /// This function allocates registered memory which belongs to the Controller
    /// Memory Buffer (CMB) of the specified NVMe controller. Note that the CMB has
    /// to support the WDS and RDS capabilities for the allocation to be successful.
    /// Also, due to vtophys contraints the CMB must be at least 4MiB in size. Free
    /// memory allocated with this function using spdk_nvme_ctrlr_free_cmb_io_buffer().
    ///
    /// \param ctrlr Controller from which to allocate memory buffer.
    /// \param size Size of buffer to allocate in bytes.
    ///
    /// \return Pointer to controller memory buffer allocation, or NULL if allocation
    /// was not possible.
    pub fn spdk_nvme_ctrlr_alloc_cmb_io_buffer(
        ctrlr: *mut spdk_nvme_ctrlr,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Free a controller memory I/O buffer (Experimental).
    ///
    /// Note this function is currently a NOP which is one reason why this and
    /// spdk_nvme_ctrlr_alloc_cmb_io_buffer() are currently marked as experimental.
    ///
    /// \param ctrlr Controller from which the buffer was allocated.
    /// \param buf Buffer previously allocated by spdk_nvme_ctrlr_alloc_cmb_io_buffer().
    /// \param size Size of buf in bytes.
    pub fn spdk_nvme_ctrlr_free_cmb_io_buffer(
        ctrlr: *mut spdk_nvme_ctrlr,
        buf: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    /// Get the identify namespace data as defined by the NVMe specification.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace.
    ///
    /// \return a pointer to the namespace data.
    pub fn spdk_nvme_ns_get_data(ns: *mut spdk_nvme_ns) -> *const spdk_nvme_ns_data;
}
extern "C" {
    /// Get the namespace id (index number) from the given namespace handle.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace.
    ///
    /// \return namespace id.
    pub fn spdk_nvme_ns_get_id(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// Get the controller with which this namespace is associated.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace.
    ///
    /// \return a pointer to the controller.
    pub fn spdk_nvme_ns_get_ctrlr(ns: *mut spdk_nvme_ns) -> *mut spdk_nvme_ctrlr;
}
extern "C" {
    /// Determine whether a namespace is active.
    ///
    /// Inactive namespaces cannot be the target of I/O commands.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return true if active, or false if inactive.
    pub fn spdk_nvme_ns_is_active(ns: *mut spdk_nvme_ns) -> bool;
}
extern "C" {
    /// Get the maximum transfer size, in bytes, for an I/O sent to the given namespace.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return the maximum transfer size in bytes.
    pub fn spdk_nvme_ns_get_max_io_xfer_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// Get the sector size, in bytes, of the given namespace.
    ///
    /// This function returns the size of the data sector only.  It does not
    /// include metadata size.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// /return the sector size in bytes.
    pub fn spdk_nvme_ns_get_sector_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// Get the extended sector size, in bytes, of the given namespace.
    ///
    /// This function returns the size of the data sector plus metadata.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// /return the extended sector size in bytes.
    pub fn spdk_nvme_ns_get_extended_sector_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// Get the number of sectors for the given namespace.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return the number of sectors.
    pub fn spdk_nvme_ns_get_num_sectors(ns: *mut spdk_nvme_ns) -> u64;
}
extern "C" {
    /// Get the size, in bytes, of the given namespace.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return the size of the given namespace in bytes.
    pub fn spdk_nvme_ns_get_size(ns: *mut spdk_nvme_ns) -> u64;
}
extern "C" {
    /// Get the end-to-end data protection information type of the given namespace.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return the end-to-end data protection information type.
    pub fn spdk_nvme_ns_get_pi_type(ns: *mut spdk_nvme_ns) -> spdk_nvme_pi_type;
}
extern "C" {
    /// Get the metadata size, in bytes, of the given namespace.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return the metadata size of the given namespace in bytes.
    pub fn spdk_nvme_ns_get_md_size(ns: *mut spdk_nvme_ns) -> u32;
}
extern "C" {
    /// Check whether if the namespace can support extended LBA when end-to-end data
    /// protection enabled.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return true if the namespace can support extended LBA when end-to-end data
    /// protection enabled, or false otherwise.
    pub fn spdk_nvme_ns_supports_extended_lba(ns: *mut spdk_nvme_ns) -> bool;
}
extern "C" {
    /// Determine the value returned when reading deallocated blocks.
    ///
    /// If deallocated blocks return 0, the deallocate command can be used as a more
    /// efficient alternative to the write_zeroes command, especially for large requests.
    ///
    /// \param ns Namespace.
    ///
    /// \return the logical block read value.
    pub fn spdk_nvme_ns_get_dealloc_logical_block_read_value(
        ns: *mut spdk_nvme_ns,
    ) -> spdk_nvme_dealloc_logical_block_read_value;
}
extern "C" {
    /// Get the optimal I/O boundary, in blocks, for the given namespace.
    ///
    /// Read and write commands should not cross the optimal I/O boundary for best
    /// performance.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return Optimal granularity of I/O commands, in blocks, or 0 if no optimal
    /// granularity is reported.
    pub fn spdk_nvme_ns_get_optimal_io_boundary(ns: *mut spdk_nvme_ns) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_uuid {
    _unused: [u8; 0],
}
extern "C" {
    /// Get the UUID for the given namespace.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return a pointer to namespace UUID, or NULL if ns does not have a UUID.
    pub fn spdk_nvme_ns_get_uuid(ns: *const spdk_nvme_ns) -> *const spdk_uuid;
}
///< The deallocate command is supported
pub const spdk_nvme_ns_flags_SPDK_NVME_NS_DEALLOCATE_SUPPORTED: spdk_nvme_ns_flags = 1;
///< The flush command is supported
pub const spdk_nvme_ns_flags_SPDK_NVME_NS_FLUSH_SUPPORTED: spdk_nvme_ns_flags = 2;
///< The reservation command is supported
pub const spdk_nvme_ns_flags_SPDK_NVME_NS_RESERVATION_SUPPORTED: spdk_nvme_ns_flags = 4;
///< The write zeroes command is supported
pub const spdk_nvme_ns_flags_SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED: spdk_nvme_ns_flags = 8;
///< The end-to-end data protection is supported
pub const spdk_nvme_ns_flags_SPDK_NVME_NS_DPS_PI_SUPPORTED: spdk_nvme_ns_flags = 16;
///< The extended lba format is supported,
///metadata is transferred as a contiguous
///part of the logical block that it is associated with
pub const spdk_nvme_ns_flags_SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED: spdk_nvme_ns_flags = 32;
/// \brief Namespace command support flags.
pub type spdk_nvme_ns_flags = u32;
extern "C" {
    /// Get the flags for the given namespace.
    ///
    /// See spdk_nvme_ns_flags for the possible flags returned.
    ///
    /// This function is thread safe and can be called at any point while the controller
    /// is attached to the SPDK NVMe driver.
    ///
    /// \param ns Namespace to query.
    ///
    /// \return the flags for the given namespace.
    pub fn spdk_nvme_ns_get_flags(ns: *mut spdk_nvme_ns) -> u32;
}
/// Restart the SGL walk to the specified offset when the command has scattered payloads.
///
/// \param cb_arg Argument passed to readv/writev.
/// \param offset Offset for SGL.
pub type spdk_nvme_req_reset_sgl_cb =
    ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void, offset: u32)>;
/// Fill out *address and *length with the current SGL entry and advance to the next
/// entry for the next time the callback is invoked.
///
/// The described segment must be physically contiguous.
///
/// \param cb_arg Argument passed to readv/writev.
/// \param address Virtual address of this segment.
/// \param length Length of this physical segment.
pub type spdk_nvme_req_next_sge_cb = ::std::option::Option<
    unsafe extern "C" fn(
        cb_arg: *mut ::std::os::raw::c_void,
        address: *mut *mut ::std::os::raw::c_void,
        length: *mut u32,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Submit a write I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the write I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer to the data payload.
    /// \param lba Starting LBA to write the data.
    /// \param lba_count Length (in sectors) for the write operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in
    /// spdk/nvme_spec.h, for this I/O.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request
    pub fn spdk_nvme_ns_cmd_write(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut ::std::os::raw::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a write I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the write I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param lba Starting LBA to write the data.
    /// \param lba_count Length (in sectors) for the write operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined in nvme_spec.h, for this I/O.
    /// \param reset_sgl_fn Callback function to reset scattered payload.
    /// \param next_sge_fn Callback function to iterate each scattered payload memory
    /// segment.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_writev(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
        reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
        next_sge_fn: spdk_nvme_req_next_sge_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a write I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the write I/O
    /// \param qpair I/O queue pair to submit the request
    /// \param lba starting LBA to write the data
    /// \param lba_count length (in sectors) for the write operation
    /// \param cb_fn callback function to invoke when the I/O is completed
    /// \param cb_arg argument to pass to the callback function
    /// \param io_flags set flags, defined in nvme_spec.h, for this I/O
    /// \param reset_sgl_fn callback function to reset scattered payload
    /// \param next_sge_fn callback function to iterate each scattered
    /// payload memory segment
    /// \param metadata virtual address pointer to the metadata payload, the length
    /// of metadata is specified by spdk_nvme_ns_get_md_size()
    /// \param apptag_mask application tag mask.
    /// \param apptag application tag to use end-to-end protection information.
    ///
    /// \return 0 if successfully submitted, ENOMEM if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_writev_with_md(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
        reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
        next_sge_fn: spdk_nvme_req_next_sge_cb,
        metadata: *mut ::std::os::raw::c_void,
        apptag_mask: u16,
        apptag: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a write I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the write I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer to the data payload.
    /// \param metadata Virtual address pointer to the metadata payload, the length
    /// of metadata is specified by spdk_nvme_ns_get_md_size().
    /// \param lba Starting LBA to write the data.
    /// \param lba_count Length (in sectors) for the write operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in
    /// spdk/nvme_spec.h, for this I/O.
    /// \param apptag_mask Application tag mask.
    /// \param apptag Application tag to use end-to-end protection information.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_write_with_md(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut ::std::os::raw::c_void,
        metadata: *mut ::std::os::raw::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
        apptag_mask: u16,
        apptag: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a write zeroes I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the write zeroes I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param lba Starting LBA for this command.
    /// \param lba_count Length (in sectors) for the write zero operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in
    /// spdk/nvme_spec.h, for this I/O.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_write_zeroes(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Submits a read I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the read I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer to the data payload.
    /// \param lba Starting LBA to read the data.
    /// \param lba_count Length (in sectors) for the read operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined in nvme_spec.h, for this I/O.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_read(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut ::std::os::raw::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a read I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the read I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param lba Starting LBA to read the data.
    /// \param lba_count Length (in sectors) for the read operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined in nvme_spec.h, for this I/O.
    /// \param reset_sgl_fn Callback function to reset scattered payload.
    /// \param next_sge_fn Callback function to iterate each scattered payload memory
    /// segment.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_readv(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
        reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
        next_sge_fn: spdk_nvme_req_next_sge_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a read I/O to the specified NVMe namespace.
    ///
    /// \param ns NVMe namespace to submit the read I/O
    /// \param qpair I/O queue pair to submit the request
    /// \param lba starting LBA to read the data
    /// \param lba_count length (in sectors) for the read operation
    /// \param cb_fn callback function to invoke when the I/O is completed
    /// \param cb_arg argument to pass to the callback function
    /// \param io_flags set flags, defined in nvme_spec.h, for this I/O
    /// \param reset_sgl_fn callback function to reset scattered payload
    /// \param next_sge_fn callback function to iterate each scattered
    /// payload memory segment
    /// \param metadata virtual address pointer to the metadata payload, the length
    ///	           of metadata is specified by spdk_nvme_ns_get_md_size()
    /// \param apptag_mask application tag mask.
    /// \param apptag application tag to use end-to-end protection information.
    ///
    /// \return 0 if successfully submitted, ENOMEM if an nvme_request
    ///	     structure cannot be allocated for the I/O request
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any given time.
    pub fn spdk_nvme_ns_cmd_readv_with_md(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
        reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
        next_sge_fn: spdk_nvme_req_next_sge_cb,
        metadata: *mut ::std::os::raw::c_void,
        apptag_mask: u16,
        apptag: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submits a read I/O to the specified NVMe namespace.
    ///
    /// \param ns NVMe namespace to submit the read I/O
    /// \param qpair I/O queue pair to submit the request
    /// \param payload virtual address pointer to the data payload
    /// \param metadata virtual address pointer to the metadata payload, the length
    /// of metadata is specified by spdk_nvme_ns_get_md_size().
    /// \param lba starting LBA to read the data.
    /// \param lba_count Length (in sectors) for the read operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined in nvme_spec.h, for this I/O.
    /// \param apptag_mask Application tag mask.
    /// \param apptag Application tag to use end-to-end protection information.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_read_with_md(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut ::std::os::raw::c_void,
        metadata: *mut ::std::os::raw::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
        apptag_mask: u16,
        apptag: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a data set management request to the specified NVMe namespace. Data set
    /// management operations are designed to optimize interaction with the block
    /// translation layer inside the device. The most common type of operation is
    /// deallocate, which is often referred to as TRIM or UNMAP.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// This is a convenience wrapper that will automatically allocate and construct
    /// the correct data buffers. Therefore, ranges does not need to be allocated from
    /// pinned memory and can be placed on the stack. If a higher performance, zero-copy
    /// version of DSM is required, simply build and submit a raw command using
    /// spdk_nvme_ctrlr_cmd_io_raw().
    ///
    /// \param ns NVMe namespace to submit the DSM request
    /// \param type A bit field constructed from \ref spdk_nvme_dsm_attribute.
    /// \param qpair I/O queue pair to submit the request
    /// \param ranges An array of \ref spdk_nvme_dsm_range elements describing the LBAs
    /// to operate on.
    /// \param num_ranges The number of elements in the ranges array.
    /// \param cb_fn Callback function to invoke when the I/O is completed
    /// \param cb_arg Argument to pass to the callback function
    ///
    /// \return 0 if successfully submitted, negated POSIX errno values otherwise.
    pub fn spdk_nvme_ns_cmd_dataset_management(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        type_: u32,
        ranges: *const spdk_nvme_dsm_range,
        num_ranges: u16,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a flush request to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the flush request.
    /// \param qpair I/O queue pair to submit the request.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_flush(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a reservation register to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the reservation register request.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer to the reservation register data.
    /// \param ignore_key '1' the current reservation key check is disabled.
    /// \param action Specifies the registration action.
    /// \param cptpl Change the Persist Through Power Loss state.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_reservation_register(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut spdk_nvme_reservation_register_data,
        ignore_key: bool,
        action: spdk_nvme_reservation_register_action,
        cptpl: spdk_nvme_reservation_register_cptpl,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submits a reservation release to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the reservation release request.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer to current reservation key.
    /// \param ignore_key '1' the current reservation key check is disabled.
    /// \param action Specifies the reservation release action.
    /// \param type Reservation type for the namespace.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_reservation_release(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut spdk_nvme_reservation_key_data,
        ignore_key: bool,
        action: spdk_nvme_reservation_release_action,
        type_: spdk_nvme_reservation_type,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submits a reservation acquire to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the reservation acquire request.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer to reservation acquire data.
    /// \param ignore_key '1' the current reservation key check is disabled.
    /// \param action Specifies the reservation acquire action.
    /// \param type Reservation type for the namespace.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_reservation_acquire(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut spdk_nvme_reservation_acquire_data,
        ignore_key: bool,
        action: spdk_nvme_reservation_acquire_action,
        type_: spdk_nvme_reservation_type,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a reservation report to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the reservation report request.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer for reservation status data.
    /// \param len Length bytes for reservation status data structure.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_reservation_report(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut ::std::os::raw::c_void,
        len: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a compare I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the compare I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer to the data payload.
    /// \param lba Starting LBA to compare the data.
    /// \param lba_count Length (in sectors) for the compare operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined in nvme_spec.h, for this I/O.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_compare(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut ::std::os::raw::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a compare I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the compare I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param lba Starting LBA to compare the data.
    /// \param lba_count Length (in sectors) for the compare operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined in nvme_spec.h, for this I/O.
    /// \param reset_sgl_fn Callback function to reset scattered payload.
    /// \param next_sge_fn Callback function to iterate each scattered payload memory
    /// segment.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_comparev(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
        reset_sgl_fn: spdk_nvme_req_reset_sgl_cb,
        next_sge_fn: spdk_nvme_req_next_sge_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Submit a compare I/O to the specified NVMe namespace.
    ///
    /// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
    /// The user must ensure that only one thread submits I/O on a given qpair at any
    /// given time.
    ///
    /// \param ns NVMe namespace to submit the compare I/O.
    /// \param qpair I/O queue pair to submit the request.
    /// \param payload Virtual address pointer to the data payload.
    /// \param metadata Virtual address pointer to the metadata payload, the length
    /// of metadata is specified by spdk_nvme_ns_get_md_size().
    /// \param lba Starting LBA to compare the data.
    /// \param lba_count Length (in sectors) for the compare operation.
    /// \param cb_fn Callback function to invoke when the I/O is completed.
    /// \param cb_arg Argument to pass to the callback function.
    /// \param io_flags Set flags, defined in nvme_spec.h, for this I/O.
    /// \param apptag_mask Application tag mask.
    /// \param apptag Application tag to use end-to-end protection information.
    ///
    /// \return 0 if successfully submitted, negated errno if an nvme_request structure
    /// cannot be allocated for the I/O request.
    pub fn spdk_nvme_ns_cmd_compare_with_md(
        ns: *mut spdk_nvme_ns,
        qpair: *mut spdk_nvme_qpair,
        payload: *mut ::std::os::raw::c_void,
        metadata: *mut ::std::os::raw::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: spdk_nvme_cmd_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        io_flags: u32,
        apptag_mask: u16,
        apptag: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Inject an error for the next request with a given opcode.
    ///
    /// \param ctrlr NVMe controller.
    /// \param qpair I/O queue pair to add the error command,
    ///              NULL for Admin queue pair.
    /// \param opc Opcode for Admin or I/O commands.
    /// \param do_not_submit True if matching requests should not be submitted
    ///                      to the controller, but instead completed manually
    ///                      after timeout_in_us has expired.  False if matching
    ///                      requests should be submitted to the controller and
    ///                      have their completion status modified after the
    ///                      controller completes the request.
    /// \param timeout_in_us Wait specified microseconds when do_not_submit is true.
    /// \param err_count Number of matching requests to inject errors.
    /// \param sct Status code type.
    /// \param sc Status code.
    ///
    /// \return 0 if successfully enabled, ENOMEM if an error command
    ///	     structure cannot be allocated.
    ///
    /// The function can be called multiple times to inject errors for different
    /// commands.  If the opcode matches an existing entry, the existing entry
    /// will be updated with the values specified.
    pub fn spdk_nvme_qpair_add_cmd_error_injection(
        ctrlr: *mut spdk_nvme_ctrlr,
        qpair: *mut spdk_nvme_qpair,
        opc: u8,
        do_not_submit: bool,
        timeout_in_us: u64,
        err_count: u32,
        sct: u8,
        sc: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Clear the specified NVMe command with error status.
    ///
    /// \param ctrlr NVMe controller.
    /// \param qpair I/O queue pair to remove the error command,
    /// \            NULL for Admin queue pair.
    /// \param opc Opcode for Admin or I/O commands.
    ///
    /// The function will remove specified command in the error list.
    pub fn spdk_nvme_qpair_remove_cmd_error_injection(
        ctrlr: *mut spdk_nvme_ctrlr,
        qpair: *mut spdk_nvme_qpair,
        opc: u8,
    );
}
